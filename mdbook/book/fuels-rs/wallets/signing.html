<!DOCTYPE HTML>
<html lang="en" class="fuel-dark" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Signing - Fuel Docs Hub</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "fuel-dark" : "fuel-dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('fuel-dark')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Sway Language</li><li class="chapter-item expanded affix "><li class="part-title">Summary</li><li class="chapter-item expanded "><a href="../../sway/introduction/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../sway/introduction/getting_started.html"><strong aria-hidden="true">1.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../../sway/introduction/fuel_toolchain.html"><strong aria-hidden="true">1.2.</strong> The Fuel Toolchain</a></li><li class="chapter-item expanded "><a href="../../sway/introduction/forc_project.html"><strong aria-hidden="true">1.3.</strong> A Forc Project</a></li><li class="chapter-item expanded "><a href="../../sway/introduction/standard_library.html"><strong aria-hidden="true">1.4.</strong> Standard Library</a></li><li class="chapter-item expanded "><a href="../../sway/introduction/sway_standards.html"><strong aria-hidden="true">1.5.</strong> Sway Language Standards</a></li></ol></li><li class="chapter-item expanded "><a href="../../sway/examples/index.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../sway/examples/counter.html"><strong aria-hidden="true">2.1.</strong> Counter</a></li><li class="chapter-item expanded "><a href="../../sway/examples/fizzbuzz.html"><strong aria-hidden="true">2.2.</strong> FizzBuzz</a></li><li class="chapter-item expanded "><a href="../../sway/examples/wallet_smart_contract.html"><strong aria-hidden="true">2.3.</strong> Wallet Smart Contract</a></li><li class="chapter-item expanded "><a href="../../sway/examples/liquidity_pool.html"><strong aria-hidden="true">2.4.</strong> Liquidity Pool</a></li><li class="chapter-item expanded "><a href="../../sway/examples/sway_applications.html"><strong aria-hidden="true">2.5.</strong> Sway Applications</a></li></ol></li><li class="chapter-item expanded "><a href="../../sway/sway-program-types/index.html"><strong aria-hidden="true">3.</strong> Program Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../sway/sway-program-types/smart_contracts.html"><strong aria-hidden="true">3.1.</strong> Contracts</a></li><li class="chapter-item expanded "><a href="../../sway/sway-program-types/libraries.html"><strong aria-hidden="true">3.2.</strong> Libraries</a></li><li class="chapter-item expanded "><a href="../../sway/sway-program-types/scripts.html"><strong aria-hidden="true">3.3.</strong> Scripts</a></li><li class="chapter-item expanded "><a href="../../sway/sway-program-types/predicates.html"><strong aria-hidden="true">3.4.</strong> Predicates</a></li></ol></li><li class="chapter-item expanded "><a href="../../sway/basics/index.html"><strong aria-hidden="true">4.</strong> Sway Language Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../sway/basics/variables.html"><strong aria-hidden="true">4.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../../sway/basics/built_in_types.html"><strong aria-hidden="true">4.2.</strong> Built-in Types</a></li><li class="chapter-item expanded "><a href="../../sway/basics/commonly_used_library_types.html"><strong aria-hidden="true">4.3.</strong> Commonly Used Library Types</a></li><li class="chapter-item expanded "><a href="../../sway/basics/blockchain_types.html"><strong aria-hidden="true">4.4.</strong> Blockchain Types</a></li><li class="chapter-item expanded "><a href="../../sway/basics/converting_types.html"><strong aria-hidden="true">4.5.</strong> Converting Types</a></li><li class="chapter-item expanded "><a href="../../sway/basics/functions.html"><strong aria-hidden="true">4.6.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../../sway/basics/structs_tuples_and_enums.html"><strong aria-hidden="true">4.7.</strong> Structs, Tuples, and Enums</a></li><li class="chapter-item expanded "><a href="../../sway/basics/methods_and_associated_functions.html"><strong aria-hidden="true">4.8.</strong> Methods and Associated Functions</a></li><li class="chapter-item expanded "><a href="../../sway/basics/constants.html"><strong aria-hidden="true">4.9.</strong> Constants</a></li><li class="chapter-item expanded "><a href="../../sway/basics/comments_and_logging.html"><strong aria-hidden="true">4.10.</strong> Comments and Logging</a></li><li class="chapter-item expanded "><a href="../../sway/basics/control_flow.html"><strong aria-hidden="true">4.11.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="../../sway/blockchain-development/index.html"><strong aria-hidden="true">5.</strong> Blockchain Development with Sway</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../sway/blockchain-development/hashing_and_cryptography.html"><strong aria-hidden="true">5.1.</strong> Hashing and Cryptography</a></li><li class="chapter-item expanded "><a href="../../sway/blockchain-development/storage.html"><strong aria-hidden="true">5.2.</strong> Contract Storage</a></li><li class="chapter-item expanded "><a href="../../sway/blockchain-development/purity.html"><strong aria-hidden="true">5.3.</strong> Function Purity</a></li><li class="chapter-item expanded "><a href="../../sway/blockchain-development/identifiers.html"><strong aria-hidden="true">5.4.</strong> Identifiers</a></li><li class="chapter-item expanded "><a href="../../sway/blockchain-development/native_assets.html"><strong aria-hidden="true">5.5.</strong> Native Assets</a></li><li class="chapter-item expanded "><a href="../../sway/blockchain-development/access_control.html"><strong aria-hidden="true">5.6.</strong> Access Control</a></li><li class="chapter-item expanded "><a href="../../sway/blockchain-development/calling_contracts.html"><strong aria-hidden="true">5.7.</strong> Calling Contracts</a></li><li class="chapter-item expanded "><a href="../../sway/blockchain-development/external_code.html"><strong aria-hidden="true">5.8.</strong> External Code</a></li></ol></li><li class="chapter-item expanded "><a href="../../sway/advanced/index.html"><strong aria-hidden="true">6.</strong> Advanced Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../sway/advanced/advanced_types.html"><strong aria-hidden="true">6.1.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="../../sway/advanced/advanced_storage.html"><strong aria-hidden="true">6.2.</strong> Advanced Storage</a></li><li class="chapter-item expanded "><a href="../../sway/advanced/generic_types.html"><strong aria-hidden="true">6.3.</strong> Generic Types</a></li><li class="chapter-item expanded "><a href="../../sway/advanced/traits.html"><strong aria-hidden="true">6.4.</strong> Traits</a></li><li class="chapter-item expanded "><a href="../../sway/advanced/associated_types.html"><strong aria-hidden="true">6.5.</strong> Associated Types</a></li><li class="chapter-item expanded "><a href="../../sway/advanced/generics_and_trait_constraints.html"><strong aria-hidden="true">6.6.</strong> Generics and Trait Constraints</a></li><li class="chapter-item expanded "><a href="../../sway/advanced/assembly.html"><strong aria-hidden="true">6.7.</strong> Assembly</a></li><li class="chapter-item expanded "><a href="../../sway/advanced/never_type.html"><strong aria-hidden="true">6.8.</strong> Never Type</a></li></ol></li><li class="chapter-item expanded "><a href="../../sway/common-collections/index.html"><strong aria-hidden="true">7.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../sway/common-collections/vec.html"><strong aria-hidden="true">7.1.</strong> Vectors on the Heap</a></li><li class="chapter-item expanded "><a href="../../sway/common-collections/storage_vec.html"><strong aria-hidden="true">7.2.</strong> Storage Vectors</a></li><li class="chapter-item expanded "><a href="../../sway/common-collections/storage_map.html"><strong aria-hidden="true">7.3.</strong> Storage Maps</a></li></ol></li><li class="chapter-item expanded "><a href="../../sway/testing/index.html"><strong aria-hidden="true">8.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../sway/testing/unit-testing.html"><strong aria-hidden="true">8.1.</strong> Unit Testing</a></li><li class="chapter-item expanded "><a href="../../sway/testing/testing-with-rust.html"><strong aria-hidden="true">8.2.</strong> Testing with Rust</a></li></ol></li><li class="chapter-item expanded "><a href="../../sway/debugging/index.html"><strong aria-hidden="true">9.</strong> Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../sway/debugging/debugging_with_cli.html"><strong aria-hidden="true">9.1.</strong> Debugging with CLI</a></li><li class="chapter-item expanded "><a href="../../sway/debugging/debugging_with_ide.html"><strong aria-hidden="true">9.2.</strong> Debugging with IDE</a></li></ol></li><li class="chapter-item expanded "><a href="../../sway/lsp/index.html"><strong aria-hidden="true">10.</strong> Sway LSP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../sway/lsp/installation.html"><strong aria-hidden="true">10.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../../sway/lsp/features.html"><strong aria-hidden="true">10.2.</strong> Features</a></li><li class="chapter-item expanded "><a href="../../sway/lsp/troubleshooting.html"><strong aria-hidden="true">10.3.</strong> Troubleshooting</a></li></ol></li><li class="chapter-item expanded "><a href="../../sway/reference/index.html"><strong aria-hidden="true">11.</strong> Sway Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../sway/reference/sway_libs.html"><strong aria-hidden="true">11.1.</strong> Sway Libraries</a></li><li class="chapter-item expanded "><a href="../../sway/reference/compiler_intrinsics.html"><strong aria-hidden="true">11.2.</strong> Compiler Intrinsics</a></li><li class="chapter-item expanded "><a href="../../sway/reference/attributes.html"><strong aria-hidden="true">11.3.</strong> Attributes</a></li><li class="chapter-item expanded "><a href="../../sway/reference/style_guide.html"><strong aria-hidden="true">11.4.</strong> Style Guide</a></li><li class="chapter-item expanded "><a href="../../sway/reference/known_issues_and_workarounds.html"><strong aria-hidden="true">11.5.</strong> Known Issues and Workarounds</a></li><li class="chapter-item expanded "><a href="../../sway/reference/undefined_behavior.html"><strong aria-hidden="true">11.6.</strong> Behavior Considered Undefined</a></li><li class="chapter-item expanded "><a href="../../sway/reference/solidity_differences.html"><strong aria-hidden="true">11.7.</strong> Differences From Solidity</a></li><li class="chapter-item expanded "><a href="../../sway/reference/rust_differences.html"><strong aria-hidden="true">11.8.</strong> Differences From Rust</a></li><li class="chapter-item expanded "><a href="../../sway/reference/contributing_to_sway.html"><strong aria-hidden="true">11.9.</strong> Contributing To Sway</a></li><li class="chapter-item expanded "><a href="../../sway/reference/keywords.html"><strong aria-hidden="true">11.10.</strong> Keywords</a></li></ol></li><li class="chapter-item expanded "><a href="../../sway/forc/index.html"><strong aria-hidden="true">12.</strong> Forc Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../sway/forc/manifest_reference.html"><strong aria-hidden="true">12.1.</strong> Manifest Reference</a></li><li class="chapter-item expanded "><a href="../../sway/forc/workspaces.html"><strong aria-hidden="true">12.2.</strong> Workspaces</a></li><li class="chapter-item expanded "><a href="../../sway/forc/dependencies.html"><strong aria-hidden="true">12.3.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="../../sway/forc/commands/index.html"><strong aria-hidden="true">12.4.</strong> Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../sway/forc/commands/forc_addr2line.html"><strong aria-hidden="true">12.4.1.</strong> forc addr2line</a></li><li class="chapter-item expanded "><a href="../../sway/forc/commands/forc_build.html"><strong aria-hidden="true">12.4.2.</strong> forc build</a></li><li class="chapter-item expanded "><a href="../../sway/forc/commands/forc_check.html"><strong aria-hidden="true">12.4.3.</strong> forc check</a></li><li class="chapter-item expanded "><a href="../../sway/forc/commands/forc_clean.html"><strong aria-hidden="true">12.4.4.</strong> forc clean</a></li><li class="chapter-item expanded "><a href="../../sway/forc/commands/forc_completions.html"><strong aria-hidden="true">12.4.5.</strong> forc completions</a></li><li class="chapter-item expanded "><a href="../../sway/forc/commands/forc_contract-id.html"><strong aria-hidden="true">12.4.6.</strong> forc contract-id</a></li><li class="chapter-item expanded "><a href="../../sway/forc/commands/forc_init.html"><strong aria-hidden="true">12.4.7.</strong> forc init</a></li><li class="chapter-item expanded "><a href="../../sway/forc/commands/forc_new.html"><strong aria-hidden="true">12.4.8.</strong> forc new</a></li><li class="chapter-item expanded "><a href="../../sway/forc/commands/forc_parse-bytecode.html"><strong aria-hidden="true">12.4.9.</strong> forc parse-bytecode</a></li><li class="chapter-item expanded "><a href="../../sway/forc/commands/forc_plugins.html"><strong aria-hidden="true">12.4.10.</strong> forc plugins</a></li><li class="chapter-item expanded "><a href="../../sway/forc/commands/forc_predicate-root.html"><strong aria-hidden="true">12.4.11.</strong> forc predicate-root</a></li><li class="chapter-item expanded "><a href="../../sway/forc/commands/forc_test.html"><strong aria-hidden="true">12.4.12.</strong> forc test</a></li><li class="chapter-item expanded "><a href="../../sway/forc/commands/forc_update.html"><strong aria-hidden="true">12.4.13.</strong> forc update</a></li><li class="chapter-item expanded "><a href="../../sway/forc/commands/forc_template.html"><strong aria-hidden="true">12.4.14.</strong> forc template</a></li></ol></li><li class="chapter-item expanded "><a href="../../sway/forc/plugins/index.html"><strong aria-hidden="true">12.5.</strong> Plugins</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../sway/forc/plugins/forc_client/index.html"><strong aria-hidden="true">12.5.1.</strong> forc client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../sway/forc/plugins/forc_client/forc_deploy.html"><strong aria-hidden="true">12.5.1.1.</strong> forc deploy</a></li><li class="chapter-item expanded "><a href="../../sway/forc/plugins/forc_client/forc_run.html"><strong aria-hidden="true">12.5.1.2.</strong> forc run</a></li><li class="chapter-item expanded "><a href="../../sway/forc/plugins/forc_client/forc_submit.html"><strong aria-hidden="true">12.5.1.3.</strong> forc submit</a></li><li class="chapter-item expanded "><a href="../../sway/forc/plugins/forc_client/forc_call.html"><strong aria-hidden="true">12.5.1.4.</strong> forc call</a></li></ol></li><li class="chapter-item expanded "><a href="../../sway/forc/plugins/forc_crypto.html"><strong aria-hidden="true">12.5.2.</strong> forc crypto</a></li><li class="chapter-item expanded "><a href="../../sway/forc/plugins/forc_debug.html"><strong aria-hidden="true">12.5.3.</strong> forc debug</a></li><li class="chapter-item expanded "><a href="../../sway/forc/plugins/forc_doc.html"><strong aria-hidden="true">12.5.4.</strong> forc doc</a></li><li class="chapter-item expanded "><a href="../../sway/forc/plugins/forc_explore.html"><strong aria-hidden="true">12.5.5.</strong> forc explore</a></li><li class="chapter-item expanded "><a href="../../sway/forc/plugins/forc_fmt.html"><strong aria-hidden="true">12.5.6.</strong> forc fmt</a></li><li class="chapter-item expanded "><a href="../../sway/forc/plugins/forc_lsp.html"><strong aria-hidden="true">12.5.7.</strong> forc lsp</a></li><li class="chapter-item expanded "><a href="../../sway/forc/plugins/forc_migrate.html"><strong aria-hidden="true">12.5.8.</strong> forc migrate</a></li><li class="chapter-item expanded "><a href="../../sway/forc/plugins/forc_node.html"><strong aria-hidden="true">12.5.9.</strong> forc node</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">Sway Libraries</li><li class="chapter-item expanded affix "><li class="part-title">Summary</li><li class="chapter-item expanded "><a href="../../sway-libs/getting_started/index.html"><strong aria-hidden="true">13.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../sway-libs/getting_started/running_tests.html"><strong aria-hidden="true">13.1.</strong> Running Tests</a></li></ol></li><li class="chapter-item expanded "><a href="../../sway-libs/asset/index.html"><strong aria-hidden="true">14.</strong> Asset Library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../sway-libs/asset/base.html"><strong aria-hidden="true">14.1.</strong> Base</a></li><li class="chapter-item expanded "><a href="../../sway-libs/asset/supply.html"><strong aria-hidden="true">14.2.</strong> Supply</a></li><li class="chapter-item expanded "><a href="../../sway-libs/asset/metadata.html"><strong aria-hidden="true">14.3.</strong> Metadata</a></li></ol></li><li class="chapter-item expanded "><a href="../../sway-libs/admin/index.html"><strong aria-hidden="true">15.</strong> Admin Library</a></li><li class="chapter-item expanded "><a href="../../sway-libs/ownership/index.html"><strong aria-hidden="true">16.</strong> Ownership Library</a></li><li class="chapter-item expanded "><a href="../../sway-libs/pausable/index.html"><strong aria-hidden="true">17.</strong> Pausable Library</a></li><li class="chapter-item expanded "><a href="../../sway-libs/reentrancy/index.html"><strong aria-hidden="true">18.</strong> Reentrancy Guard Library</a></li><li class="chapter-item expanded "><a href="../../sway-libs/bytecode/index.html"><strong aria-hidden="true">19.</strong> Bytecode Library</a></li><li class="chapter-item expanded "><a href="../../sway-libs/merkle/index.html"><strong aria-hidden="true">20.</strong> Merkle Library</a></li><li class="chapter-item expanded "><a href="../../sway-libs/signed_integers/index.html"><strong aria-hidden="true">21.</strong> Signed Integers Library</a></li><li class="chapter-item expanded "><a href="../../sway-libs/queue/index.html"><strong aria-hidden="true">22.</strong> Queue Library</a></li><li class="chapter-item expanded "><a href="../../sway-libs/upgradability/index.html"><strong aria-hidden="true">23.</strong> Upgradability</a></li><li class="chapter-item expanded affix "><li class="part-title">Sway Standards</li><li class="chapter-item expanded affix "><li class="part-title">Summary</li><li class="chapter-item expanded "><a href="../../sway-standards/src-2-inline-documentation.html"><strong aria-hidden="true">24.</strong> SRC-2: Inline Documentation</a></li><li class="chapter-item expanded "><a href="../../sway-standards/src-3-minting-and-burning.html"><strong aria-hidden="true">25.</strong> SRC-3: Minting and Burning</a></li><li class="chapter-item expanded "><a href="../../sway-standards/src-5-ownership.html"><strong aria-hidden="true">26.</strong> SRC-5: Ownership</a></li><li class="chapter-item expanded "><a href="../../sway-standards/src-6-vault.html"><strong aria-hidden="true">27.</strong> SRC-6: Vault</a></li><li class="chapter-item expanded "><a href="../../sway-standards/src-7-asset-metadata.html"><strong aria-hidden="true">28.</strong> SRC-7: Onchain Asset Metadata</a></li><li class="chapter-item expanded "><a href="../../sway-standards/src-8-bridged-asset.html"><strong aria-hidden="true">29.</strong> SRC-8: Bridged Asset</a></li><li class="chapter-item expanded "><a href="../../sway-standards/src-9-metadata-keys.html"><strong aria-hidden="true">30.</strong> SRC-9: Metadata Keys</a></li><li class="chapter-item expanded "><a href="../../sway-standards/src-10-native-bridge.html"><strong aria-hidden="true">31.</strong> SRC-10: Native Bridge</a></li><li class="chapter-item expanded "><a href="../../sway-standards/src-11-security-information.html"><strong aria-hidden="true">32.</strong> SRC-11: Security Information</a></li><li class="chapter-item expanded "><a href="../../sway-standards/src-12-contract-factory.html"><strong aria-hidden="true">33.</strong> SRC-12: Contract Factory</a></li><li class="chapter-item expanded "><a href="../../sway-standards/src-13-soulbound-address.html"><strong aria-hidden="true">34.</strong> SRC-13: Soulbound Address</a></li><li class="chapter-item expanded "><a href="../../sway-standards/src-14-simple-upgradeable-proxies.html"><strong aria-hidden="true">35.</strong> SRC-14: Simple Upgradeable Contract</a></li><li class="chapter-item expanded "><a href="../../sway-standards/src-15-offchain-asset-metadata.html"><strong aria-hidden="true">36.</strong> SRC-15: Offchain Asset Metadata</a></li><li class="chapter-item expanded "><a href="../../sway-standards/src-16-typed-structured-data.html"><strong aria-hidden="true">37.</strong> SRC-16: Typed Structured Data</a></li><li class="chapter-item expanded "><a href="../../sway-standards/src-20-native-asset.html"><strong aria-hidden="true">38.</strong> SRC-20: Native Asset</a></li><li class="chapter-item expanded affix "><li class="part-title">Sway by Example</li><li class="chapter-item expanded affix "><li class="part-title">Summary</li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/solidity.html"><strong aria-hidden="true">39.</strong> Solidity</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/hello-sway.html"><strong aria-hidden="true">40.</strong> Hello Sway</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/variables.html"><strong aria-hidden="true">41.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/primitive-types.html"><strong aria-hidden="true">42.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/compound-types.html"><strong aria-hidden="true">43.</strong> Compound Types</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/blockchain-types.html"><strong aria-hidden="true">44.</strong> Blockchain Types</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/functions.html"><strong aria-hidden="true">45.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/imports.html"><strong aria-hidden="true">46.</strong> Imports</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/structs.html"><strong aria-hidden="true">47.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/tuples.html"><strong aria-hidden="true">48.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/enums.html"><strong aria-hidden="true">49.</strong> Enums</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/constants.html"><strong aria-hidden="true">50.</strong> Constants</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/configurable-constants.html"><strong aria-hidden="true">51.</strong> Configurable Constants</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/options.html"><strong aria-hidden="true">52.</strong> Options</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/results.html"><strong aria-hidden="true">53.</strong> Results</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/if.html"><strong aria-hidden="true">54.</strong> Ifs</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/match.html"><strong aria-hidden="true">55.</strong> Matches</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/while-loop.html"><strong aria-hidden="true">56.</strong> While Loops</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/logging.html"><strong aria-hidden="true">57.</strong> Logging</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/storage-map.html"><strong aria-hidden="true">58.</strong> Storage Map</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/vector.html"><strong aria-hidden="true">59.</strong> Vector</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/base-asset.html"><strong aria-hidden="true">60.</strong> Base Asset</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/library.html"><strong aria-hidden="true">61.</strong> Library</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/predicate.html"><strong aria-hidden="true">62.</strong> Predicate</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/script.html"><strong aria-hidden="true">63.</strong> Script</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/big-numbers.html"><strong aria-hidden="true">64.</strong> Big Numbers</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/src20.html"><strong aria-hidden="true">65.</strong> SRC20</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/hashing.html"><strong aria-hidden="true">66.</strong> Hashing</a></li><li class="chapter-item expanded "><a href="../../sway-by-example-lib/verify-signature.html"><strong aria-hidden="true">67.</strong> Verify-Signature</a></li><li class="chapter-item expanded affix "><li class="part-title">Migrations and Disclosures</li><li class="chapter-item expanded affix "><li class="part-title">Summary</li><li class="chapter-item expanded "><a href="../../migrations-and-disclosures/migrations/index.html"><strong aria-hidden="true">68.</strong> Migrations</a></li><li class="chapter-item expanded "><a href="../../migrations-and-disclosures/migrations/sway.html"><strong aria-hidden="true">69.</strong> Sway</a></li><li class="chapter-item expanded "><a href="../../migrations-and-disclosures/migrations/rust-sdk.html"><strong aria-hidden="true">70.</strong> Rust SDK</a></li><li class="chapter-item expanded "><a href="../../migrations-and-disclosures/migrations/typescript-sdk.html"><strong aria-hidden="true">71.</strong> Typescript SDK</a></li><li class="chapter-item expanded "><a href="../../migrations-and-disclosures/breaking-changes-archive.html"><strong aria-hidden="true">72.</strong> Betas Migrations Archive</a></li><li class="chapter-item expanded affix "><li class="part-title">Verified Addresses</li><li class="chapter-item expanded affix "><li class="part-title">Summary</li><li class="chapter-item expanded "><a href="../../verified-addresses/assets.html"><strong aria-hidden="true">73.</strong> Assets</a></li><li class="chapter-item expanded "><a href="../../verified-addresses/contracts.html"><strong aria-hidden="true">74.</strong> Contracts</a></li><li class="chapter-item expanded "><a href="../../verified-addresses/security-council.html"><strong aria-hidden="true">75.</strong> Security Council</a></li><li class="chapter-item expanded affix "><li class="part-title">Fuel Token Overview</li><li class="chapter-item expanded affix "><li class="part-title">Fuel Token Overview</li><li class="chapter-item expanded "><a href="../../fuel-token-overview/tokenomics.html"><strong aria-hidden="true">76.</strong> Tokenomics</a></li><li class="chapter-item expanded "><a href="../../fuel-token-overview/fuel-v1-upgrade.html"><strong aria-hidden="true">77.</strong> Fuel V1 to FUEL Upgrade</a></li><li class="chapter-item expanded "><a href="../../fuel-token-overview/claim-genesis-drop.html"><strong aria-hidden="true">78.</strong> Claim Genesis Drop</a></li><li class="chapter-item expanded "><a href="../../fuel-token-overview/stake-on-fuel.html"><strong aria-hidden="true">79.</strong> Stake on Fuel Ignition</a></li><li class="chapter-item expanded "><a href="../../fuel-token-overview/stake-on-ethereum.html"><strong aria-hidden="true">80.</strong> Stake on Ethereum</a></li><li class="chapter-item expanded affix "><li class="part-title">Fuel Book</li><li class="chapter-item expanded affix "><li class="part-title">Summary</li><li class="chapter-item expanded "><a href="../../fuel-book/why-fuel/index.html"><strong aria-hidden="true">81.</strong> Chapter 1: Why Fuel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuel-book/why-fuel/beginnings.html"><strong aria-hidden="true">81.1.</strong> 1.1 - Beginnings</a></li><li class="chapter-item expanded "><a href="../../fuel-book/why-fuel/the-problem.html"><strong aria-hidden="true">81.2.</strong> 1.2 - The Problem</a></li><li class="chapter-item expanded "><a href="../../fuel-book/why-fuel/the-fuel-way.html"><strong aria-hidden="true">81.3.</strong> 1.3 - The Fuel Way</a></li><li class="chapter-item expanded "><a href="../../fuel-book/why-fuel/what-is-fuel.html"><strong aria-hidden="true">81.4.</strong> 1.4 - So What is Fuel?</a></li><li class="chapter-item expanded "><a href="../../fuel-book/why-fuel/building-on-fuel-an-overview.html"><strong aria-hidden="true">81.5.</strong> 1.5 - Building on Fuel: An Overview</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuel-book/the-architecture/index.html"><strong aria-hidden="true">82.</strong> Chapter 2: The Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuel-book/the-architecture/the-fuelvm.html"><strong aria-hidden="true">82.1.</strong> 2.1 - The FuelVM</a></li><li class="chapter-item expanded "><a href="../../fuel-book/the-architecture/transactions-on-fuel.html"><strong aria-hidden="true">82.2.</strong> 2.2 - Transactions on Fuel</a></li><li class="chapter-item expanded "><a href="../../fuel-book/the-architecture/fuel-blocks.html"><strong aria-hidden="true">82.3.</strong> 2.3 - Fuel Blocks</a></li><li class="chapter-item expanded "><a href="../../fuel-book/the-architecture/block-building-in-fuel.html"><strong aria-hidden="true">82.4.</strong> 2.4 - Block Building in Fuel</a></li><li class="chapter-item expanded "><a href="../../fuel-book/the-architecture/fuel-and-ethereum.html"><strong aria-hidden="true">82.5.</strong> 2.5 - Fuel and Ethereum</a></li><li class="chapter-item expanded "><a href="../../fuel-book/the-architecture/security-on-fuel.html"><strong aria-hidden="true">82.6.</strong> 2.6 - Security on Fuel</a></li><li class="chapter-item expanded "><a href="../../fuel-book/the-architecture/fees-on-fuel.html"><strong aria-hidden="true">82.7.</strong> 2.7 - Fees on Fuel</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuel-book/fuels-future/index.html"><strong aria-hidden="true">83.</strong> Chapter 3: Fuel's Future</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuel-book/fuels-future/network-of-interconnection.html"><strong aria-hidden="true">83.1.</strong> 3.1 - A Network of Interconnected L2s & L3s</a></li><li class="chapter-item expanded "><a href="../../fuel-book/fuels-future/decentralized-block-building.html"><strong aria-hidden="true">83.2.</strong> 3.2 - Decentralized Block Building</a></li><li class="chapter-item expanded "><a href="../../fuel-book/fuels-future/snap-fast-finality-gadget.html"><strong aria-hidden="true">83.3.</strong> 3.3 - SNAP Fast Finality Gadget</a></li><li class="chapter-item expanded "><a href="../../fuel-book/fuels-future/state-rehydration.html"><strong aria-hidden="true">83.4.</strong> 3.4 - State Rehydration</a></li><li class="chapter-item expanded "><a href="../../fuel-book/fuels-future/data-streaming.html"><strong aria-hidden="true">83.5.</strong> 3.5 - Data Streaming</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuel-book/conclusion/index.html"><strong aria-hidden="true">84.</strong> Conclusion</a></li><li class="chapter-item expanded "><a href="../../fuel-book/glossary/index.html"><strong aria-hidden="true">85.</strong> Glossary</a></li><li class="chapter-item expanded affix "><li class="part-title">Integration Docs</li><li class="chapter-item expanded affix "><li class="part-title">Summary</li><li class="chapter-item expanded affix "><li class="part-title">Node Operator</li><li class="chapter-item expanded affix "><li class="part-title">Summary</li><li class="chapter-item expanded "><a href="../../node-operator/fuel-ignition/index.html"><strong aria-hidden="true">86.</strong> Fuel Ignition</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node-operator/fuel-ignition/local-node.html"><strong aria-hidden="true">86.1.</strong> Local Node</a></li><li class="chapter-item expanded "><a href="../../node-operator/fuel-ignition/testnet-node.html"><strong aria-hidden="true">86.2.</strong> Testnet Node</a></li><li class="chapter-item expanded "><a href="../../node-operator/fuel-ignition/mainnet-node.html"><strong aria-hidden="true">86.3.</strong> Mainnet Node</a></li></ol></li><li class="chapter-item expanded "><a href="../../node-operator/fuel-sequencer/index.html"><strong aria-hidden="true">87.</strong> Fuel Sequencer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../node-operator/fuel-sequencer/testnet-node.html"><strong aria-hidden="true">87.1.</strong> Testnet Node</a></li><li class="chapter-item expanded "><a href="../../node-operator/fuel-sequencer/testnet-validator.html"><strong aria-hidden="true">87.2.</strong> Testnet Validator</a></li><li class="chapter-item expanded "><a href="../../node-operator/fuel-sequencer/mainnet-node.html"><strong aria-hidden="true">87.3.</strong> Mainnet Node</a></li><li class="chapter-item expanded "><a href="../../node-operator/fuel-sequencer/mainnet-validator.html"><strong aria-hidden="true">87.4.</strong> Mainnet Validator</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Fuels-rs (Rust SDK)</li><li class="chapter-item expanded affix "><li class="part-title">Summary</li><li class="chapter-item expanded "><a href="../../fuels-rs/getting-started.html"><strong aria-hidden="true">88.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/connecting/index.html"><strong aria-hidden="true">89.</strong> Connecting to a Fuel node</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-rs/connecting/external-node.html"><strong aria-hidden="true">89.1.</strong> Connecting to the Testnet or an external node</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/connecting/short-lived.html"><strong aria-hidden="true">89.2.</strong> Running a short-lived Fuel node with the SDK</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/connecting/rocksdb.html"><strong aria-hidden="true">89.3.</strong> RocksDB</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/connecting/querying.html"><strong aria-hidden="true">89.4.</strong> Querying the blockchain</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/connecting/retrying.html"><strong aria-hidden="true">89.5.</strong> Retrying upon errors</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-rs/accounts.html"><strong aria-hidden="true">90.</strong> Accounts</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/wallets/index.html"><strong aria-hidden="true">91.</strong> Managing wallets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-rs/wallets/private-keys.html"><strong aria-hidden="true">91.1.</strong> Creating a wallet from a private key</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/wallets/mnemonic-wallet.html"><strong aria-hidden="true">91.2.</strong> Creating a wallet from mnemonic phrases</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/wallets/access.html"><strong aria-hidden="true">91.3.</strong> Wallet Access</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/wallets/encrypting-and-storing.html"><strong aria-hidden="true">91.4.</strong> Encrypting and storing wallets</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/wallets/checking-balances-and-coins.html"><strong aria-hidden="true">91.5.</strong> Checking balances and coins</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/wallets/test-wallets.html"><strong aria-hidden="true">91.6.</strong> Setting up test wallets</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/wallets/signing.html" class="active"><strong aria-hidden="true">91.7.</strong> Signing</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-rs/abigen/index.html"><strong aria-hidden="true">92.</strong> Generating bindings with abigen!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-rs/abigen/the-json-abi-file.html"><strong aria-hidden="true">92.1.</strong> The JSON ABI file</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/abigen/the-abigen-macro.html"><strong aria-hidden="true">92.2.</strong> The abigen! macro</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-rs/deploying/index.html"><strong aria-hidden="true">93.</strong> Deploying contracts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-rs/deploying/configurable-constants.html"><strong aria-hidden="true">93.1.</strong> Configurable constants</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/deploying/storage-slots.html"><strong aria-hidden="true">93.2.</strong> Storage slots</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/deploying/interacting-with-contracts.html"><strong aria-hidden="true">93.3.</strong> Interacting with contracts</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/deploying/the-fuelvm-binary-file.html"><strong aria-hidden="true">93.4.</strong> The FuelVM Binary file</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/deploying/large_contracts.html"><strong aria-hidden="true">93.5.</strong> Large contracts</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-rs/calling-contracts/index.html"><strong aria-hidden="true">94.</strong> Calling contracts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-rs/calling-contracts/calls-with-different-wallets.html"><strong aria-hidden="true">94.1.</strong> Connecting wallets</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/calling-contracts/tx-policies.html"><strong aria-hidden="true">94.2.</strong> Transaction policies</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/calling-contracts/call-params.html"><strong aria-hidden="true">94.3.</strong> Call parameters</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/calling-contracts/custom-asset-transfer.html"><strong aria-hidden="true">94.4.</strong> Custom asset transfer</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/calling-contracts/call-response.html"><strong aria-hidden="true">94.5.</strong> Call response</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/calling-contracts/logs.html"><strong aria-hidden="true">94.6.</strong> Logs</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/calling-contracts/variable-outputs.html"><strong aria-hidden="true">94.7.</strong> Variable outputs and messages</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/calling-contracts/simulation.html"><strong aria-hidden="true">94.8.</strong> Simulating calls</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/calling-contracts/other-contracts.html"><strong aria-hidden="true">94.9.</strong> Calling other contracts</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/calling-contracts/multicalls.html"><strong aria-hidden="true">94.10.</strong> Multiple contract calls</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/calling-contracts/tx-dependency-estimation.html"><strong aria-hidden="true">94.11.</strong> Transaction dependency estimation</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/calling-contracts/cost-estimation.html"><strong aria-hidden="true">94.12.</strong> Estimating cost</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/calling-contracts/low-level-calls.html"><strong aria-hidden="true">94.13.</strong> Low-level calls</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-rs/running-scripts.html"><strong aria-hidden="true">95.</strong> Running scripts</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/predicates/index.html"><strong aria-hidden="true">96.</strong> Predicates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-rs/predicates/send-spend-predicate.html"><strong aria-hidden="true">96.1.</strong> Signatures example</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-rs/preuploading-code.html"><strong aria-hidden="true">97.</strong> Pre-uploading code</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/custom-transactions/index.html"><strong aria-hidden="true">98.</strong> Custom transactions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-rs/custom-transactions/transaction-builders.html"><strong aria-hidden="true">98.1.</strong> Transaction builders</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/custom-transactions/custom-calls.html"><strong aria-hidden="true">98.2.</strong> Custom contract and script calls</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-rs/types/index.html"><strong aria-hidden="true">99.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-rs/types/bytes32.html"><strong aria-hidden="true">99.1.</strong> Bytes32</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/types/address.html"><strong aria-hidden="true">99.2.</strong> Address</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/types/contract-id.html"><strong aria-hidden="true">99.3.</strong> ContractId</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/types/asset-id.html"><strong aria-hidden="true">99.4.</strong> AssetId</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/types/bech32.html"><strong aria-hidden="true">99.5.</strong> Bech32</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/types/custom_types.html"><strong aria-hidden="true">99.6.</strong> Structs and enums</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/types/string.html"><strong aria-hidden="true">99.7.</strong> String</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/types/bits256.html"><strong aria-hidden="true">99.8.</strong> Bits256</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/types/bytes.html"><strong aria-hidden="true">99.9.</strong> Bytes</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/types/B512.html"><strong aria-hidden="true">99.10.</strong> B512</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/types/evm_address.html"><strong aria-hidden="true">99.11.</strong> EvmAddress</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/types/vectors.html"><strong aria-hidden="true">99.12.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/types/conversion.html"><strong aria-hidden="true">99.13.</strong> Converting types</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-rs/codec/index.html"><strong aria-hidden="true">100.</strong> Codec</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-rs/codec/encoding.html"><strong aria-hidden="true">100.1.</strong> Encoding</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/codec/decoding.html"><strong aria-hidden="true">100.2.</strong> Decoding</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-rs/reference.html"><strong aria-hidden="true">101.</strong> API Reference</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/testing/index.html"><strong aria-hidden="true">102.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-rs/testing/basics.html"><strong aria-hidden="true">102.1.</strong> Testing basics</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/testing/the-setup-program-test-macro.html"><strong aria-hidden="true">102.2.</strong> The setup_program_test! macro</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/testing/chains.html"><strong aria-hidden="true">102.3.</strong> Tweaking the blockchain</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-rs/cookbook/index.html"><strong aria-hidden="true">103.</strong> Cookbook</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-rs/cookbook/custom-chain.html"><strong aria-hidden="true">103.1.</strong> Custom consensus parameters</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/cookbook/deposit-and-withdraw.html"><strong aria-hidden="true">103.2.</strong> Deposit and Withdraw</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/cookbook/transfer-all-assets.html"><strong aria-hidden="true">103.3.</strong> Transfer all assets</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-rs/debugging/index.html"><strong aria-hidden="true">104.</strong> Debugging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-rs/debugging/function-selector.html"><strong aria-hidden="true">104.1.</strong> The Function selector</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/debugging/decoding-script-transactions.html"><strong aria-hidden="true">104.2.</strong> Decoding script transactions</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-rs/glossary.html"><strong aria-hidden="true">105.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="../../fuels-rs/contributing/CONTRIBUTING.html"><strong aria-hidden="true">106.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-rs/contributing/tests-structure.html"><strong aria-hidden="true">106.1.</strong> Integration tests structure</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-rs/cli/index.html"><strong aria-hidden="true">107.</strong> Command Line Interfaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-rs/cli/fuels-abi-cli.html"><strong aria-hidden="true">107.1.</strong> fuels-abi-cli</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Fuels-ts (TypeScript SDK)</li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/getting-started/index.html"><strong aria-hidden="true">108.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-ts/guide/getting-started/installation.html"><strong aria-hidden="true">108.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/getting-started/connecting-to-the-network.html"><strong aria-hidden="true">108.2.</strong> Connecting to the Network</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/getting-started/running-a-local-fuel-node.html"><strong aria-hidden="true">108.3.</strong> Running a local Fuel node</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/getting-started/react-example.html"><strong aria-hidden="true">108.4.</strong> React Example</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/getting-started/cdn-usage.html"><strong aria-hidden="true">108.5.</strong> CDN Usage</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/getting-started/next-steps.html"><strong aria-hidden="true">108.6.</strong> Next Steps</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/the-utxo-model/index.html"><strong aria-hidden="true">109.</strong> The UTXO Model</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/creating-a-fuel-dapp/index.html"><strong aria-hidden="true">110.</strong> Creating a Fuel dApp</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-ts/guide/creating-a-fuel-dapp/options.html"><strong aria-hidden="true">110.1.</strong> Options</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/creating-a-fuel-dapp/deploying-a-dapp-to-testnet.html"><strong aria-hidden="true">110.2.</strong> Deploying a dApp to Testnet</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/creating-a-fuel-dapp/working-with-predicates.html"><strong aria-hidden="true">110.3.</strong> Working with Predicates</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/fuels-cli/index.html"><strong aria-hidden="true">111.</strong> fuels CLI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-ts/guide/fuels-cli/config-file.html"><strong aria-hidden="true">111.1.</strong> Config File</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/fuels-cli/commands.html"><strong aria-hidden="true">111.2.</strong> Commands</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/fuels-cli/abi-typegen.html"><strong aria-hidden="true">111.3.</strong> ABI Typegen</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/fuels-cli/generating-types.html"><strong aria-hidden="true">111.4.</strong> Generating Types</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/fuels-cli/using-generated-types.html"><strong aria-hidden="true">111.5.</strong> Using Generated Types</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/provider/index.html"><strong aria-hidden="true">112.</strong> Provider</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-ts/guide/provider/provider-options.html"><strong aria-hidden="true">112.1.</strong> Provider Options</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/provider/pagination.html"><strong aria-hidden="true">112.2.</strong> Pagination</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/provider/querying-the-chain.html"><strong aria-hidden="true">112.3.</strong> Querying the Chain</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/wallets/index.html"><strong aria-hidden="true">113.</strong> Wallets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-ts/guide/wallets/instantiating-wallets.html"><strong aria-hidden="true">113.1.</strong> Instantiating Wallets</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/wallets/private-keys.html"><strong aria-hidden="true">113.2.</strong> Private Keys</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/wallets/mnemonic-wallet.html"><strong aria-hidden="true">113.3.</strong> Mnemonic Wallet</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/wallets/encrypting-and-decrypting.html"><strong aria-hidden="true">113.4.</strong> Encrypting and Decrypting</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/wallets/checking-balances.html"><strong aria-hidden="true">113.5.</strong> Checking Balances</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/wallets/wallet-transferring.html"><strong aria-hidden="true">113.6.</strong> Wallet Transferring</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/wallets/signing.html"><strong aria-hidden="true">113.7.</strong> Signing</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/wallets/connectors.html"><strong aria-hidden="true">113.8.</strong> Connectors</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/wallets/wallet-manager.html"><strong aria-hidden="true">113.9.</strong> Wallet Manager</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/wallets/locking-and-unlocking.html"><strong aria-hidden="true">113.10.</strong> Locking and Unlocking</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/index.html"><strong aria-hidden="true">114.</strong> Contracts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/methods.html"><strong aria-hidden="true">114.1.</strong> Methods</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/call-parameters.html"><strong aria-hidden="true">114.2.</strong> Call Parameters</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/contract-balance.html"><strong aria-hidden="true">114.3.</strong> Contract Balance</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/cost-estimation.html"><strong aria-hidden="true">114.4.</strong> Cost Estimation</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/dependency-estimation.html"><strong aria-hidden="true">114.5.</strong> Dependency Estimation</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/variable-outputs.html"><strong aria-hidden="true">114.6.</strong> Variable Outputs</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/logs.html"><strong aria-hidden="true">114.7.</strong> Logs</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/inter-contract-calls.html"><strong aria-hidden="true">114.8.</strong> Inter-contract Calls</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/multi-contract-calls.html"><strong aria-hidden="true">114.9.</strong> Multi-contract calls</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/using-different-wallets.html"><strong aria-hidden="true">114.10.</strong> Using different Wallets</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/transferring-assets.html"><strong aria-hidden="true">114.11.</strong> Transferring Assets</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/deploying-contracts.html"><strong aria-hidden="true">114.12.</strong> Deploying Contracts</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/storage-slots.html"><strong aria-hidden="true">114.13.</strong> Storage Slots</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/configurable-constants.html"><strong aria-hidden="true">114.14.</strong> Configurable Constants</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/minted-token-asset-id.html"><strong aria-hidden="true">114.15.</strong> Minted Token Asset ID</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/managing-deployed-contracts.html"><strong aria-hidden="true">114.16.</strong> Managing Deployed Contracts</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/proxy-contracts.html"><strong aria-hidden="true">114.17.</strong> Proxy Contracts</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/contracts/understanding-the-fuelvm-binary-file.html"><strong aria-hidden="true">114.18.</strong> Understanding the FuelVM Binary File</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/scripts/index.html"><strong aria-hidden="true">115.</strong> Scripts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-ts/guide/scripts/instantiating-a-script.html"><strong aria-hidden="true">115.1.</strong> Instantiating A Script</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/scripts/deploying-scripts.html"><strong aria-hidden="true">115.2.</strong> Deploying Scripts</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/scripts/configurable-constants.html"><strong aria-hidden="true">115.3.</strong> Configurable Constants</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/scripts/running-scripts.html"><strong aria-hidden="true">115.4.</strong> Running scripts</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/scripts/custom-script-call.html"><strong aria-hidden="true">115.5.</strong> Custom script Call</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/predicates/index.html"><strong aria-hidden="true">116.</strong> Predicates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-ts/guide/predicates/instantiating-a-predicate.html"><strong aria-hidden="true">116.1.</strong> Instantiating A Predicate</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/predicates/deploying-predicates.html"><strong aria-hidden="true">116.2.</strong> Deploying Predicates</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/predicates/configurable-constants.html"><strong aria-hidden="true">116.3.</strong> Configurable Constants</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/predicates/send-and-spend-funds-from-predicates.html"><strong aria-hidden="true">116.4.</strong> Send And Spend Funds From Predicates</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/predicates/methods.html"><strong aria-hidden="true">116.5.</strong> Methods</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/predicates/custom-transactions.html"><strong aria-hidden="true">116.6.</strong> Custom Transactions</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/transactions/index.html"><strong aria-hidden="true">117.</strong> Transactions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-ts/guide/transactions/modifying-the-request.html"><strong aria-hidden="true">117.1.</strong> Modifying the Request</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/transactions/adding-parameters.html"><strong aria-hidden="true">117.2.</strong> Adding Parameters</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/transactions/adding-policies.html"><strong aria-hidden="true">117.3.</strong> Adding Policies</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/transactions/getting-the-response.html"><strong aria-hidden="true">117.4.</strong> Getting the Response</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/transactions/optimizing-frontend-apps.html"><strong aria-hidden="true">117.5.</strong> Optimizing Frontend Apps</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/encoding/index.html"><strong aria-hidden="true">118.</strong> Encoding</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-ts/guide/encoding/encode-and-decode.html"><strong aria-hidden="true">118.1.</strong> Encode and Decode</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/encoding/working-with-bytes.html"><strong aria-hidden="true">118.2.</strong> Working with Bytes</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/utilities/index.html"><strong aria-hidden="true">119.</strong> Utilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-ts/guide/utilities/date-conversion.html"><strong aria-hidden="true">119.1.</strong> Date conversion</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/utilities/address-conversion.html"><strong aria-hidden="true">119.2.</strong> Address conversion</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/utilities/unit-conversion.html"><strong aria-hidden="true">119.3.</strong> Unit conversion</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/utilities/using-assets.html"><strong aria-hidden="true">119.4.</strong> Using assets</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/utilities/asset-api.html"><strong aria-hidden="true">119.5.</strong> Asset API</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/cookbook/index.html"><strong aria-hidden="true">120.</strong> Cookbook</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-ts/guide/cookbook/deposit-and-withdraw.html"><strong aria-hidden="true">120.1.</strong> Deposit And Withdraw</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/cookbook/wallet-sdk-and-react-hooks.html"><strong aria-hidden="true">120.2.</strong> Wallet SDK and React Hooks</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/cookbook/custom-transactions.html"><strong aria-hidden="true">120.3.</strong> Custom Transactions</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/cookbook/custom-transactions-from-contract-calls.html"><strong aria-hidden="true">120.4.</strong> Custom Transactions from Contract Calls</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/cookbook/generate-fake-resources.html"><strong aria-hidden="true">120.5.</strong> Generate Fake Resources</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/cookbook/transactions-with-multiple-signers.html"><strong aria-hidden="true">120.6.</strong> Transactions with Multiple Signers</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/cookbook/graphql-integration.html"><strong aria-hidden="true">120.7.</strong> GraphQL Integration</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/cookbook/resubmitting-failed-transactions.html"><strong aria-hidden="true">120.8.</strong> Resubmitting Failed Transactions</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/cookbook/combining-utxos.html"><strong aria-hidden="true">120.9.</strong> Combining UTXOs</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/cookbook/splitting-utxos.html"><strong aria-hidden="true">120.10.</strong> Splitting UTXOs</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/cookbook/optimized-react-example.html"><strong aria-hidden="true">120.11.</strong> Optimized React Example</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/testing/index.html"><strong aria-hidden="true">121.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-ts/guide/testing/launching-a-test-node.html"><strong aria-hidden="true">121.1.</strong> Launching a Test Node</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/testing/test-node-options.html"><strong aria-hidden="true">121.2.</strong> Test Node Options</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/testing/fuel-core-options.html"><strong aria-hidden="true">121.3.</strong> Fuel Core Options</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/testing/basic-example.html"><strong aria-hidden="true">121.4.</strong> Basic Example</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/testing/advanced-example.html"><strong aria-hidden="true">121.5.</strong> Advanced Example</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/testing/custom-blocks.html"><strong aria-hidden="true">121.6.</strong> Custom Blocks</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/testing/setting-up-test-wallets.html"><strong aria-hidden="true">121.7.</strong> Setting up test wallets</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/index.html"><strong aria-hidden="true">122.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/address.html"><strong aria-hidden="true">122.1.</strong> Address</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/arrays.html"><strong aria-hidden="true">122.2.</strong> Arrays</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/asset-id.html"><strong aria-hidden="true">122.3.</strong> Asset Id</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/b256.html"><strong aria-hidden="true">122.4.</strong> B256</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/b512.html"><strong aria-hidden="true">122.5.</strong> B512</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/bytes.html"><strong aria-hidden="true">122.6.</strong> Bytes</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/bytes32.html"><strong aria-hidden="true">122.7.</strong> Bytes32</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/enums.html"><strong aria-hidden="true">122.8.</strong> Enums</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/evm-address.html"><strong aria-hidden="true">122.9.</strong> Evm Address</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/native-parameters.html"><strong aria-hidden="true">122.10.</strong> Native Parameters</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/numbers.html"><strong aria-hidden="true">122.11.</strong> Numbers</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/options.html"><strong aria-hidden="true">122.12.</strong> Options</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/raw-slice.html"><strong aria-hidden="true">122.13.</strong> Raw Slice</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/std-string.html"><strong aria-hidden="true">122.14.</strong> Std String</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/string.html"><strong aria-hidden="true">122.15.</strong> String</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/structs.html"><strong aria-hidden="true">122.16.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/tuples.html"><strong aria-hidden="true">122.17.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/types/vectors.html"><strong aria-hidden="true">122.18.</strong> Vectors</a></li></ol></li><li class="chapter-item expanded "><a href="../../fuels-ts/guide/errors/index.html"><strong aria-hidden="true">123.</strong> Errors</a></li><li class="chapter-item expanded affix "><li class="part-title">Specs</li><li class="chapter-item expanded affix "><li class="part-title">Summary</li><li class="chapter-item expanded "><a href="../../specs/tx-format/index.html"><strong aria-hidden="true">124.</strong> Transaction Format</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../specs/tx-format/consensus_parameters.html"><strong aria-hidden="true">124.1.</strong> Consensus Parameters</a></li><li class="chapter-item expanded "><a href="../../specs/tx-format/transaction.html"><strong aria-hidden="true">124.2.</strong> Transaction</a></li><li class="chapter-item expanded "><a href="../../specs/tx-format/upgrade_purpose.html"><strong aria-hidden="true">124.3.</strong> UpgradePurpose</a></li><li class="chapter-item expanded "><a href="../../specs/tx-format/policy.html"><strong aria-hidden="true">124.4.</strong> Policy</a></li><li class="chapter-item expanded "><a href="../../specs/tx-format/input.html"><strong aria-hidden="true">124.5.</strong> Input</a></li><li class="chapter-item expanded "><a href="../../specs/tx-format/output.html"><strong aria-hidden="true">124.6.</strong> Output</a></li><li class="chapter-item expanded "><a href="../../specs/tx-format/witness.html"><strong aria-hidden="true">124.7.</strong> Witness</a></li><li class="chapter-item expanded "><a href="../../specs/tx-format/tx-pointer.html"><strong aria-hidden="true">124.8.</strong> Transaction Pointer</a></li></ol></li><li class="chapter-item expanded "><a href="../../specs/identifiers/index.html"><strong aria-hidden="true">125.</strong> Computing Identifiers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../specs/identifiers/asset.html"><strong aria-hidden="true">125.1.</strong> Asset ID</a></li><li class="chapter-item expanded "><a href="../../specs/identifiers/blob-id.html"><strong aria-hidden="true">125.2.</strong> Blob ID</a></li><li class="chapter-item expanded "><a href="../../specs/identifiers/contract-id.html"><strong aria-hidden="true">125.3.</strong> Contract ID</a></li><li class="chapter-item expanded "><a href="../../specs/identifiers/predicate-id.html"><strong aria-hidden="true">125.4.</strong> Predicate ID</a></li><li class="chapter-item expanded "><a href="../../specs/identifiers/transaction-id.html"><strong aria-hidden="true">125.5.</strong> Transaction ID</a></li><li class="chapter-item expanded "><a href="../../specs/identifiers/utxo-id.html"><strong aria-hidden="true">125.6.</strong> UTXO ID</a></li></ol></li><li class="chapter-item expanded "><a href="../../specs/protocol/index.html"><strong aria-hidden="true">126.</strong> Protocol</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../specs/protocol/tx-validity.html"><strong aria-hidden="true">126.1.</strong> Transaction Validity Rules</a></li><li class="chapter-item expanded "><a href="../../specs/protocol/cryptographic-primitives.html"><strong aria-hidden="true">126.2.</strong> Cryptographic Primitives</a></li><li class="chapter-item expanded "><a href="../../specs/protocol/storage-initialization.html"><strong aria-hidden="true">126.3.</strong> Storage Slot Initialization</a></li><li class="chapter-item expanded "><a href="../../specs/protocol/block-header.html"><strong aria-hidden="true">126.4.</strong> Block Header Format</a></li><li class="chapter-item expanded "><a href="../../specs/protocol/relayer.html"><strong aria-hidden="true">126.5.</strong> Layer 1 Relayer/Bridge Protocol</a></li></ol></li><li class="chapter-item expanded "><a href="../../specs/abi/index.html"><strong aria-hidden="true">127.</strong> Application Binary Interface (ABI)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../specs/abi/json-abi-format.html"><strong aria-hidden="true">127.1.</strong> JSON ABI Format</a></li><li class="chapter-item expanded "><a href="../../specs/abi/receipts.html"><strong aria-hidden="true">127.2.</strong> Receipts</a></li><li class="chapter-item expanded "><a href="../../specs/abi/fn-selector-encoding.html"><strong aria-hidden="true">127.3.</strong> Function Selector Encoding</a></li><li class="chapter-item expanded "><a href="../../specs/abi/argument-encoding.html"><strong aria-hidden="true">127.4.</strong> Argument Encoding</a></li><li class="chapter-item expanded "><a href="../../specs/abi/hash-based-ids.html"><strong aria-hidden="true">127.5.</strong> Hash Based Ids</a></li></ol></li><li class="chapter-item expanded "><a href="../../specs/fuel-vm/index.html"><strong aria-hidden="true">128.</strong> FuelVM</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../specs/fuel-vm/instruction-set.html"><strong aria-hidden="true">128.1.</strong> Instruction Set</a></li></ol></li><li class="chapter-item expanded "><a href="../../specs/networks/index.html"><strong aria-hidden="true">129.</strong> Networks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../specs/networks/poa.html"><strong aria-hidden="true">129.1.</strong> Proof of Authority (PoA)</a></li></ol></li><li class="chapter-item expanded "><a href="../../specs/tests/index.html"><strong aria-hidden="true">130.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../specs/tests/sparse-merkle-tree-tests.html"><strong aria-hidden="true">130.1.</strong> Sparse Merkle Tree</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Guides</li><li class="chapter-item expanded "><a href="../../guides/intro-to-sway/contract-abi.html"><strong aria-hidden="true">131.</strong> ABI</a></li><li class="chapter-item expanded "><a href="../../guides/counter-dapp/building-a-frontend.html"><strong aria-hidden="true">132.</strong> Building a Frontend</a></li><li class="chapter-item expanded "><a href="../../guides/counter-dapp/building-a-smart-contract.html"><strong aria-hidden="true">133.</strong> Building a Smart Contract</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-sway/checkpoint.html"><strong aria-hidden="true">134.</strong> Checkpoint</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-predicates/checkpoint.html"><strong aria-hidden="true">135.</strong> Checkpoint</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-predicates/configurables.html"><strong aria-hidden="true">136.</strong> Configurables</a></li><li class="chapter-item expanded "><a href="../../guides/contract-quickstart/index.html"><strong aria-hidden="true">137.</strong> Contract Quickstart</a></li><li class="chapter-item expanded "><a href="../../guides/counter-dapp/index.html"><strong aria-hidden="true">138.</strong> Counter Dapp</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-predicates/debugging-with-scripts.html"><strong aria-hidden="true">139.</strong> Debugging with Scripts</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-sway/contract-errors.html"><strong aria-hidden="true">140.</strong> Errors</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-sway/explore-fuel.html"><strong aria-hidden="true">141.</strong> Explore Fuel</a></li><li class="chapter-item expanded "><a href="../../guides/frontend-quickstart/index.html"><strong aria-hidden="true">142.</strong> Frontend Quickstart</a></li><li class="chapter-item expanded "><a href="../../guides/fuel-connectors/index.html"><strong aria-hidden="true">143.</strong> Fuel Connectors</a></li><li class="chapter-item expanded "><a href="../../guides/installation/codespace.html"><strong aria-hidden="true">144.</strong> Fuel Github Codespace</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-sway/contract-functions.html"><strong aria-hidden="true">145.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-sway/contract-imports.html"><strong aria-hidden="true">146.</strong> Imports</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-predicates/imports.html"><strong aria-hidden="true">147.</strong> Imports</a></li><li class="chapter-item expanded "><a href="../../guides/installation/index.html"><strong aria-hidden="true">148.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-predicates/index.html"><strong aria-hidden="true">149.</strong> Intro to Predicates</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-sway/index.html"><strong aria-hidden="true">150.</strong> Intro to Sway</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-predicates/debugging-with-scripts-rust.html"><strong aria-hidden="true">151.</strong> Logging in Rust tests</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-predicates/main.html"><strong aria-hidden="true">152.</strong> Main</a></li><li class="chapter-item expanded "><a href="../../guides/fuel-connectors/non-technical-guide.html"><strong aria-hidden="true">153.</strong> Non-technical Guide</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-predicates/predicate-limitations.html"><strong aria-hidden="true">154.</strong> Predicate Limitations</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-predicates/predicate-root.html"><strong aria-hidden="true">155.</strong> Predicate Root</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-sway/prerequisites.html"><strong aria-hidden="true">156.</strong> Prerequisites</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-predicates/prerequisites.html"><strong aria-hidden="true">157.</strong> Prerequisites</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-sway/rust-sdk.html"><strong aria-hidden="true">158.</strong> Rust Testing</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-predicates/rust-sdk.html"><strong aria-hidden="true">159.</strong> Rust Testing</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-predicates/signature-verification.html"><strong aria-hidden="true">160.</strong> Signature Verification</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-sway/contract-storage.html"><strong aria-hidden="true">161.</strong> Storage</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-sway/contract-structs.html"><strong aria-hidden="true">162.</strong> Structs</a></li><li class="chapter-item expanded "><a href="../../guides/intro-to-sway/typescript-sdk.html"><strong aria-hidden="true">163.</strong> Typescript Frontend</a></li><li class="chapter-item expanded affix "><li class="part-title">Introduction</li><li class="chapter-item expanded "><a href="../../intro/glossary.html"><strong aria-hidden="true">164.</strong> glossary</a></li><li class="chapter-item expanded "><a href="../../intro/quickstart.html"><strong aria-hidden="true">165.</strong> quickstart</a></li><li class="chapter-item expanded "><a href="../../intro/what-is-fuel.html"><strong aria-hidden="true">166.</strong> what is fuel</a></li><li class="chapter-item expanded affix "><li class="part-title">Contributing</li><li class="chapter-item expanded "><a href="../../contributing/index.html"><strong aria-hidden="true">167.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="../../contributing/documentation.html"><strong aria-hidden="true">168.</strong> Documentation</a></li><li class="chapter-item expanded "><a href="../../contributing/general.html"><strong aria-hidden="true">169.</strong> General</a></li><li class="chapter-item expanded "><a href="../../contributing/github-workflows.html"><strong aria-hidden="true">170.</strong> GitHub Workflows</a></li><li class="chapter-item expanded "><a href="../../contributing/guides.html"><strong aria-hidden="true">171.</strong> Guides</a></li><li class="chapter-item expanded "><a href="../../contributing/style-guide.html"><strong aria-hidden="true">172.</strong> Style Guide</a></li><li class="chapter-item expanded "><a href="../../contributing/versions.html"><strong aria-hidden="true">173.</strong> Versions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fuel Docs Hub</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="signing"><a class="header" href="#signing">Signing</a></h1>
<p>Once you've instantiated your wallet in an unlocked state using one of the previously discussed methods, you can sign a message with <code>wallet.sign</code>. Below is a full example of how to sign and recover a message.</p>
<pre><code class="language-rust ignore">use std::collections::HashMap;

use async_trait::async_trait;
use fuel_core_client::client::pagination::{PaginatedResult, PaginationRequest};
use fuel_tx::{Output, Receipt, TxId, TxPointer, UtxoId};
use fuel_types::{AssetId, Bytes32, ContractId, Nonce};
use fuels_core::types::{
    bech32::{Bech32Address, Bech32ContractId},
    coin::Coin,
    coin_type::CoinType,
    coin_type_id::CoinTypeId,
    errors::Result,
    input::Input,
    message::Message,
    transaction::{Transaction, TxPolicies},
    transaction_builders::{BuildableTransaction, ScriptTransactionBuilder, TransactionBuilder},
    transaction_response::TransactionResponse,
};

use crate::{
    accounts_utils::{
        add_base_change_if_needed, available_base_assets_and_amount, calculate_missing_base_amount,
        extract_message_nonce, split_into_utxo_ids_and_nonces,
    },
    provider::{Provider, ResourceFilter},
};

#[cfg_attr(not(target_arch = "wasm32"), async_trait)]
pub trait ViewOnlyAccount: std::fmt::Debug + Send + Sync + Clone {
    fn address(&amp;self) -&gt; &amp;Bech32Address;

    fn try_provider(&amp;self) -&gt; Result&lt;&amp;Provider&gt;;

    async fn get_transactions(
        &amp;self,
        request: PaginationRequest&lt;String&gt;,
    ) -&gt; Result&lt;PaginatedResult&lt;TransactionResponse, String&gt;&gt; {
        Ok(self
            .try_provider()?
            .get_transactions_by_owner(self.address(), request)
            .await?)
    }

    /// Gets all unspent coins of asset `asset_id` owned by the account.
    async fn get_coins(&amp;self, asset_id: AssetId) -&gt; Result&lt;Vec&lt;Coin&gt;&gt; {
        Ok(self
            .try_provider()?
            .get_coins(self.address(), asset_id)
            .await?)
    }

    /// Get the balance of all spendable coins `asset_id` for address `address`. This is different
    /// from getting coins because we are just returning a number (the sum of UTXOs amount) instead
    /// of the UTXOs.
    async fn get_asset_balance(&amp;self, asset_id: &amp;AssetId) -&gt; Result&lt;u64&gt; {
        self.try_provider()?
            .get_asset_balance(self.address(), *asset_id)
            .await
    }

    /// Gets all unspent messages owned by the account.
    async fn get_messages(&amp;self) -&gt; Result&lt;Vec&lt;Message&gt;&gt; {
        Ok(self.try_provider()?.get_messages(self.address()).await?)
    }

    /// Get all the spendable balances of all assets for the account. This is different from getting
    /// the coins because we are only returning the sum of UTXOs coins amount and not the UTXOs
    /// coins themselves.
    async fn get_balances(&amp;self) -&gt; Result&lt;HashMap&lt;String, u128&gt;&gt; {
        self.try_provider()?.get_balances(self.address()).await
    }

    /// Get some spendable resources (coins and messages) of asset `asset_id` owned by the account
    /// that add up at least to amount `amount`. The returned coins (UTXOs) are actual coins that
    /// can be spent. The number of UXTOs is optimized to prevent dust accumulation.
    async fn get_spendable_resources(
        &amp;self,
        asset_id: AssetId,
        amount: u64,
        excluded_coins: Option&lt;Vec&lt;CoinTypeId&gt;&gt;,
    ) -&gt; Result&lt;Vec&lt;CoinType&gt;&gt; {
        let (excluded_utxos, excluded_message_nonces) =
            split_into_utxo_ids_and_nonces(excluded_coins);

        let filter = ResourceFilter {
            from: self.address().clone(),
            asset_id: Some(asset_id),
            amount,
            excluded_utxos,
            excluded_message_nonces,
        };

        self.try_provider()?.get_spendable_resources(filter).await
    }

    /// Returns a vector containing the output coin and change output given an asset and amount
    fn get_asset_outputs_for_amount(
        &amp;self,
        to: &amp;Bech32Address,
        asset_id: AssetId,
        amount: u64,
    ) -&gt; Vec&lt;Output&gt; {
        vec![
            Output::coin(to.into(), amount, asset_id),
            // Note that the change will be computed by the node.
            // Here we only have to tell the node who will own the change and its asset ID.
            Output::change(self.address().into(), 0, asset_id),
        ]
    }

    /// Returns a vector consisting of `Input::Coin`s and `Input::Message`s for the given
    /// asset ID and amount.
    async fn get_asset_inputs_for_amount(
        &amp;self,
        asset_id: AssetId,
        amount: u64,
        excluded_coins: Option&lt;Vec&lt;CoinTypeId&gt;&gt;,
    ) -&gt; Result&lt;Vec&lt;Input&gt;&gt;;

    /// Add base asset inputs to the transaction to cover the estimated fee
    /// and add a change output for the base asset if needed.
    /// Requires contract inputs to be at the start of the transactions inputs vec
    /// so that their indexes are retained
    async fn adjust_for_fee&lt;Tb: TransactionBuilder + Sync&gt;(
        &amp;self,
        tb: &amp;mut Tb,
        used_base_amount: u64,
    ) -&gt; Result&lt;()&gt; {
        let provider = self.try_provider()?;
        let consensus_parameters = provider.consensus_parameters().await?;
        let (base_assets, base_amount) =
            available_base_assets_and_amount(tb, consensus_parameters.base_asset_id());
        let missing_base_amount =
            calculate_missing_base_amount(tb, base_amount, used_base_amount, provider).await?;

        if missing_base_amount &gt; 0 {
            let new_base_inputs = self
                .get_asset_inputs_for_amount(
                    *consensus_parameters.base_asset_id(),
                    missing_base_amount,
                    Some(base_assets),
                )
                .await
                // if there query fails do nothing
                .unwrap_or_default();

            tb.inputs_mut().extend(new_base_inputs);
        };

        add_base_change_if_needed(tb, self.address(), consensus_parameters.base_asset_id());

        Ok(())
    }
}

#[cfg_attr(not(target_arch = "wasm32"), async_trait)]
pub trait Account: ViewOnlyAccount {
    // Add signatures to the builder if the underlying account is a wallet
    fn add_witnesses&lt;Tb: TransactionBuilder&gt;(&amp;self, _tb: &amp;mut Tb) -&gt; Result&lt;()&gt; {
        Ok(())
    }

    /// Transfer funds from this account to another `Address`.
    /// Fails if amount for asset ID is larger than address's spendable coins.
    /// Returns the transaction ID that was sent and the list of receipts.
    async fn transfer(
        &amp;self,
        to: &amp;Bech32Address,
        amount: u64,
        asset_id: AssetId,
        tx_policies: TxPolicies,
    ) -&gt; Result&lt;(TxId, Vec&lt;Receipt&gt;)&gt; {
        let provider = self.try_provider()?;

        let inputs = self
            .get_asset_inputs_for_amount(asset_id, amount, None)
            .await?;
        let outputs = self.get_asset_outputs_for_amount(to, asset_id, amount);

        let mut tx_builder =
            ScriptTransactionBuilder::prepare_transfer(inputs, outputs, tx_policies);

        self.add_witnesses(&amp;mut tx_builder)?;

        let consensus_parameters = provider.consensus_parameters().await?;
        let used_base_amount = if asset_id == *consensus_parameters.base_asset_id() {
            amount
        } else {
            0
        };
        self.adjust_for_fee(&amp;mut tx_builder, used_base_amount)
            .await?;

        let tx = tx_builder.build(provider).await?;
        let tx_id = tx.id(consensus_parameters.chain_id());

        let tx_status = provider.send_transaction_and_await_commit(tx).await?;

        let receipts = tx_status.take_receipts_checked(None)?;

        Ok((tx_id, receipts))
    }

    /// Unconditionally transfers `balance` of type `asset_id` to
    /// the contract at `to`.
    /// Fails if balance for `asset_id` is larger than this account's spendable balance.
    /// Returns the corresponding transaction ID and the list of receipts.
    ///
    /// CAUTION !!!
    ///
    /// This will transfer coins to a contract, possibly leading
    /// to the PERMANENT LOSS OF COINS if not used with care.
    async fn force_transfer_to_contract(
        &amp;self,
        to: &amp;Bech32ContractId,
        balance: u64,
        asset_id: AssetId,
        tx_policies: TxPolicies,
    ) -&gt; Result&lt;(String, Vec&lt;Receipt&gt;)&gt; {
        let provider = self.try_provider()?;

        let zeroes = Bytes32::zeroed();
        let plain_contract_id: ContractId = to.into();

        let mut inputs = vec![Input::contract(
            UtxoId::new(zeroes, 0),
            zeroes,
            zeroes,
            TxPointer::default(),
            plain_contract_id,
        )];

        inputs.extend(
            self.get_asset_inputs_for_amount(asset_id, balance, None)
                .await?,
        );

        let outputs = vec![
            Output::contract(0, zeroes, zeroes),
            Output::change(self.address().into(), 0, asset_id),
        ];

        // Build transaction and sign it
        let mut tb = ScriptTransactionBuilder::prepare_contract_transfer(
            plain_contract_id,
            balance,
            asset_id,
            inputs,
            outputs,
            tx_policies,
        );

        self.add_witnesses(&amp;mut tb)?;
        self.adjust_for_fee(&amp;mut tb, balance).await?;

        let tx = tb.build(provider).await?;

        let consensus_parameters = provider.consensus_parameters().await?;
        let tx_id = tx.id(consensus_parameters.chain_id());
        let tx_status = provider.send_transaction_and_await_commit(tx).await?;

        let receipts = tx_status.take_receipts_checked(None)?;

        Ok((tx_id.to_string(), receipts))
    }

    /// Withdraws an amount of the base asset to
    /// an address on the base chain.
    /// Returns the transaction ID, message ID and the list of receipts.
    async fn withdraw_to_base_layer(
        &amp;self,
        to: &amp;Bech32Address,
        amount: u64,
        tx_policies: TxPolicies,
    ) -&gt; Result&lt;(TxId, Nonce, Vec&lt;Receipt&gt;)&gt; {
        let provider = self.try_provider()?;
        let consensus_parameters = provider.consensus_parameters().await?;

        let inputs = self
            .get_asset_inputs_for_amount(*consensus_parameters.base_asset_id(), amount, None)
            .await?;

        let mut tb = ScriptTransactionBuilder::prepare_message_to_output(
            to.into(),
            amount,
            inputs,
            tx_policies,
            *consensus_parameters.base_asset_id(),
        );

        self.add_witnesses(&amp;mut tb)?;
        self.adjust_for_fee(&amp;mut tb, amount).await?;

        let tx = tb.build(provider).await?;

        let tx_id = tx.id(consensus_parameters.chain_id());
        let tx_status = provider.send_transaction_and_await_commit(tx).await?;

        let receipts = tx_status.take_receipts_checked(None)?;

        let nonce = extract_message_nonce(&amp;receipts)
            .expect("MessageId could not be retrieved from tx receipts.");

        Ok((tx_id, nonce, receipts))
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use fuel_crypto::{Message, SecretKey, Signature};
    use fuel_tx::{Address, ConsensusParameters, Output, Transaction as FuelTransaction};
    use fuels_core::{
        traits::Signer,
        types::{transaction::Transaction, DryRun, DryRunner},
    };
    use rand::{rngs::StdRng, RngCore, SeedableRng};

    use super::*;
    use crate::wallet::WalletUnlocked;

    #[tokio::test]
    async fn sign_and_verify() -&gt; Result&lt;()&gt; {
        // ANCHOR: sign_message
        let mut rng = StdRng::seed_from_u64(2322u64);
        let mut secret_seed = [0u8; 32];
        rng.fill_bytes(&amp;mut secret_seed);

        let secret = secret_seed.as_slice().try_into()?;

        // Create a wallet using the private key created above.
        let wallet = WalletUnlocked::new_from_private_key(secret, None);

        let message = Message::new("my message".as_bytes());
        let signature = wallet.sign(message).await?;

        // Check if signature is what we expect it to be
        assert_eq!(signature, Signature::from_str("0x8eeb238db1adea4152644f1cd827b552dfa9ab3f4939718bb45ca476d167c6512a656f4d4c7356bfb9561b14448c230c6e7e4bd781df5ee9e5999faa6495163d")?);

        // Recover address that signed the message
        let recovered_address = signature.recover(&amp;message)?;

        assert_eq!(wallet.address().hash(), recovered_address.hash());

        // Verify signature
        signature.verify(&amp;recovered_address, &amp;message)?;
        // ANCHOR_END: sign_message

        Ok(())
    }

    #[derive(Default)]
    struct MockDryRunner {
        c_param: ConsensusParameters,
    }

    #[cfg_attr(not(target_arch = "wasm32"), async_trait)]
    impl DryRunner for MockDryRunner {
        async fn dry_run(&amp;self, _: FuelTransaction) -&gt; Result&lt;DryRun&gt; {
            Ok(DryRun {
                succeeded: true,
                script_gas: 0,
                variable_outputs: 0,
            })
        }

        async fn consensus_parameters(&amp;self) -&gt; Result&lt;ConsensusParameters&gt; {
            Ok(self.c_param.clone())
        }

        async fn estimate_gas_price(&amp;self, _block_header: u32) -&gt; Result&lt;u64&gt; {
            Ok(0)
        }

        async fn estimate_predicates(
            &amp;self,
            _: &amp;FuelTransaction,
            _: Option&lt;u32&gt;,
        ) -&gt; Result&lt;FuelTransaction&gt; {
            unimplemented!()
        }
    }

    #[tokio::test]
    async fn sign_tx_and_verify() -&gt; std::result::Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        // ANCHOR: sign_tb
        let secret = SecretKey::from_str(
            "5f70feeff1f229e4a95e1056e8b4d80d0b24b565674860cc213bdb07127ce1b1",
        )?;
        let wallet = WalletUnlocked::new_from_private_key(secret, None);

        // Set up a transaction
        let mut tb = {
            let input_coin = Input::ResourceSigned {
                resource: CoinType::Coin(Coin {
                    amount: 10000000,
                    owner: wallet.address().clone(),
                    ..Default::default()
                }),
            };

            let output_coin = Output::coin(
                Address::from_str(
                    "0xc7862855b418ba8f58878db434b21053a61a2025209889cc115989e8040ff077",
                )?,
                1,
                Default::default(),
            );
            let change = Output::change(wallet.address().into(), 0, Default::default());

            ScriptTransactionBuilder::prepare_transfer(
                vec![input_coin],
                vec![output_coin, change],
                Default::default(),
            )
        };

        // Add `Signer` to the transaction builder
        tb.add_signer(wallet.clone())?;
        // ANCHOR_END: sign_tb

        let tx = tb.build(MockDryRunner::default()).await?; // Resolve signatures and add corresponding witness indexes

        // Extract the signature from the tx witnesses
        let bytes = &lt;[u8; Signature::LEN]&gt;::try_from(tx.witnesses().first().unwrap().as_ref())?;
        let tx_signature = Signature::from_bytes(bytes);

        // Sign the transaction manually
        let message = Message::from_bytes(*tx.id(0.into()));
        let signature = wallet.sign(message).await?;

        // Check if the signatures are the same
        assert_eq!(signature, tx_signature);

        // Check if the signature is what we expect it to be
        assert_eq!(signature, Signature::from_str("faa616776a1c336ef6257f7cb0cb5cd932180e2d15faba5f17481dae1cbcaf314d94617bd900216a6680bccb1ea62438e4ca93b0d5733d33788ef9d79cc24e9f")?);

        // Recover the address that signed the transaction
        let recovered_address = signature.recover(&amp;message)?;

        assert_eq!(wallet.address().hash(), recovered_address.hash());

        // Verify signature
        signature.verify(&amp;recovered_address, &amp;message)?;

        Ok(())
    }
}</code></pre>
<h2 id="adding-signers-to-a-transaction-builder"><a class="header" href="#adding-signers-to-a-transaction-builder">Adding <code>Signers</code> to a transaction builder</a></h2>
<p>Every signed resource in the inputs needs to have a witness index that points to a valid witness. Changing the witness index inside an input will change the transaction ID. This means that we need to set all witness indexes before finally signing the transaction. Previously, the user had to make sure that the witness indexes and the order of the witnesses are correct. To automate this process, the SDK will keep track of the signers in the transaction builder and resolve the final transaction automatically. This is done by storing signers until the final transaction is built.</p>
<p>Below is a full example of how to create a transaction builder and add signers to it.</p>
<blockquote>
<p>Note: When you add a <code>Signer</code> to a transaction builder, the signer is stored inside it and the transaction will not be resolved until you call <code>build()</code>!</p>
</blockquote>
<pre><code class="language-rust ignore">use std::collections::HashMap;

use async_trait::async_trait;
use fuel_core_client::client::pagination::{PaginatedResult, PaginationRequest};
use fuel_tx::{Output, Receipt, TxId, TxPointer, UtxoId};
use fuel_types::{AssetId, Bytes32, ContractId, Nonce};
use fuels_core::types::{
    bech32::{Bech32Address, Bech32ContractId},
    coin::Coin,
    coin_type::CoinType,
    coin_type_id::CoinTypeId,
    errors::Result,
    input::Input,
    message::Message,
    transaction::{Transaction, TxPolicies},
    transaction_builders::{BuildableTransaction, ScriptTransactionBuilder, TransactionBuilder},
    transaction_response::TransactionResponse,
};

use crate::{
    accounts_utils::{
        add_base_change_if_needed, available_base_assets_and_amount, calculate_missing_base_amount,
        extract_message_nonce, split_into_utxo_ids_and_nonces,
    },
    provider::{Provider, ResourceFilter},
};

#[cfg_attr(not(target_arch = "wasm32"), async_trait)]
pub trait ViewOnlyAccount: std::fmt::Debug + Send + Sync + Clone {
    fn address(&amp;self) -&gt; &amp;Bech32Address;

    fn try_provider(&amp;self) -&gt; Result&lt;&amp;Provider&gt;;

    async fn get_transactions(
        &amp;self,
        request: PaginationRequest&lt;String&gt;,
    ) -&gt; Result&lt;PaginatedResult&lt;TransactionResponse, String&gt;&gt; {
        Ok(self
            .try_provider()?
            .get_transactions_by_owner(self.address(), request)
            .await?)
    }

    /// Gets all unspent coins of asset `asset_id` owned by the account.
    async fn get_coins(&amp;self, asset_id: AssetId) -&gt; Result&lt;Vec&lt;Coin&gt;&gt; {
        Ok(self
            .try_provider()?
            .get_coins(self.address(), asset_id)
            .await?)
    }

    /// Get the balance of all spendable coins `asset_id` for address `address`. This is different
    /// from getting coins because we are just returning a number (the sum of UTXOs amount) instead
    /// of the UTXOs.
    async fn get_asset_balance(&amp;self, asset_id: &amp;AssetId) -&gt; Result&lt;u64&gt; {
        self.try_provider()?
            .get_asset_balance(self.address(), *asset_id)
            .await
    }

    /// Gets all unspent messages owned by the account.
    async fn get_messages(&amp;self) -&gt; Result&lt;Vec&lt;Message&gt;&gt; {
        Ok(self.try_provider()?.get_messages(self.address()).await?)
    }

    /// Get all the spendable balances of all assets for the account. This is different from getting
    /// the coins because we are only returning the sum of UTXOs coins amount and not the UTXOs
    /// coins themselves.
    async fn get_balances(&amp;self) -&gt; Result&lt;HashMap&lt;String, u128&gt;&gt; {
        self.try_provider()?.get_balances(self.address()).await
    }

    /// Get some spendable resources (coins and messages) of asset `asset_id` owned by the account
    /// that add up at least to amount `amount`. The returned coins (UTXOs) are actual coins that
    /// can be spent. The number of UXTOs is optimized to prevent dust accumulation.
    async fn get_spendable_resources(
        &amp;self,
        asset_id: AssetId,
        amount: u64,
        excluded_coins: Option&lt;Vec&lt;CoinTypeId&gt;&gt;,
    ) -&gt; Result&lt;Vec&lt;CoinType&gt;&gt; {
        let (excluded_utxos, excluded_message_nonces) =
            split_into_utxo_ids_and_nonces(excluded_coins);

        let filter = ResourceFilter {
            from: self.address().clone(),
            asset_id: Some(asset_id),
            amount,
            excluded_utxos,
            excluded_message_nonces,
        };

        self.try_provider()?.get_spendable_resources(filter).await
    }

    /// Returns a vector containing the output coin and change output given an asset and amount
    fn get_asset_outputs_for_amount(
        &amp;self,
        to: &amp;Bech32Address,
        asset_id: AssetId,
        amount: u64,
    ) -&gt; Vec&lt;Output&gt; {
        vec![
            Output::coin(to.into(), amount, asset_id),
            // Note that the change will be computed by the node.
            // Here we only have to tell the node who will own the change and its asset ID.
            Output::change(self.address().into(), 0, asset_id),
        ]
    }

    /// Returns a vector consisting of `Input::Coin`s and `Input::Message`s for the given
    /// asset ID and amount.
    async fn get_asset_inputs_for_amount(
        &amp;self,
        asset_id: AssetId,
        amount: u64,
        excluded_coins: Option&lt;Vec&lt;CoinTypeId&gt;&gt;,
    ) -&gt; Result&lt;Vec&lt;Input&gt;&gt;;

    /// Add base asset inputs to the transaction to cover the estimated fee
    /// and add a change output for the base asset if needed.
    /// Requires contract inputs to be at the start of the transactions inputs vec
    /// so that their indexes are retained
    async fn adjust_for_fee&lt;Tb: TransactionBuilder + Sync&gt;(
        &amp;self,
        tb: &amp;mut Tb,
        used_base_amount: u64,
    ) -&gt; Result&lt;()&gt; {
        let provider = self.try_provider()?;
        let consensus_parameters = provider.consensus_parameters().await?;
        let (base_assets, base_amount) =
            available_base_assets_and_amount(tb, consensus_parameters.base_asset_id());
        let missing_base_amount =
            calculate_missing_base_amount(tb, base_amount, used_base_amount, provider).await?;

        if missing_base_amount &gt; 0 {
            let new_base_inputs = self
                .get_asset_inputs_for_amount(
                    *consensus_parameters.base_asset_id(),
                    missing_base_amount,
                    Some(base_assets),
                )
                .await
                // if there query fails do nothing
                .unwrap_or_default();

            tb.inputs_mut().extend(new_base_inputs);
        };

        add_base_change_if_needed(tb, self.address(), consensus_parameters.base_asset_id());

        Ok(())
    }
}

#[cfg_attr(not(target_arch = "wasm32"), async_trait)]
pub trait Account: ViewOnlyAccount {
    // Add signatures to the builder if the underlying account is a wallet
    fn add_witnesses&lt;Tb: TransactionBuilder&gt;(&amp;self, _tb: &amp;mut Tb) -&gt; Result&lt;()&gt; {
        Ok(())
    }

    /// Transfer funds from this account to another `Address`.
    /// Fails if amount for asset ID is larger than address's spendable coins.
    /// Returns the transaction ID that was sent and the list of receipts.
    async fn transfer(
        &amp;self,
        to: &amp;Bech32Address,
        amount: u64,
        asset_id: AssetId,
        tx_policies: TxPolicies,
    ) -&gt; Result&lt;(TxId, Vec&lt;Receipt&gt;)&gt; {
        let provider = self.try_provider()?;

        let inputs = self
            .get_asset_inputs_for_amount(asset_id, amount, None)
            .await?;
        let outputs = self.get_asset_outputs_for_amount(to, asset_id, amount);

        let mut tx_builder =
            ScriptTransactionBuilder::prepare_transfer(inputs, outputs, tx_policies);

        self.add_witnesses(&amp;mut tx_builder)?;

        let consensus_parameters = provider.consensus_parameters().await?;
        let used_base_amount = if asset_id == *consensus_parameters.base_asset_id() {
            amount
        } else {
            0
        };
        self.adjust_for_fee(&amp;mut tx_builder, used_base_amount)
            .await?;

        let tx = tx_builder.build(provider).await?;
        let tx_id = tx.id(consensus_parameters.chain_id());

        let tx_status = provider.send_transaction_and_await_commit(tx).await?;

        let receipts = tx_status.take_receipts_checked(None)?;

        Ok((tx_id, receipts))
    }

    /// Unconditionally transfers `balance` of type `asset_id` to
    /// the contract at `to`.
    /// Fails if balance for `asset_id` is larger than this account's spendable balance.
    /// Returns the corresponding transaction ID and the list of receipts.
    ///
    /// CAUTION !!!
    ///
    /// This will transfer coins to a contract, possibly leading
    /// to the PERMANENT LOSS OF COINS if not used with care.
    async fn force_transfer_to_contract(
        &amp;self,
        to: &amp;Bech32ContractId,
        balance: u64,
        asset_id: AssetId,
        tx_policies: TxPolicies,
    ) -&gt; Result&lt;(String, Vec&lt;Receipt&gt;)&gt; {
        let provider = self.try_provider()?;

        let zeroes = Bytes32::zeroed();
        let plain_contract_id: ContractId = to.into();

        let mut inputs = vec![Input::contract(
            UtxoId::new(zeroes, 0),
            zeroes,
            zeroes,
            TxPointer::default(),
            plain_contract_id,
        )];

        inputs.extend(
            self.get_asset_inputs_for_amount(asset_id, balance, None)
                .await?,
        );

        let outputs = vec![
            Output::contract(0, zeroes, zeroes),
            Output::change(self.address().into(), 0, asset_id),
        ];

        // Build transaction and sign it
        let mut tb = ScriptTransactionBuilder::prepare_contract_transfer(
            plain_contract_id,
            balance,
            asset_id,
            inputs,
            outputs,
            tx_policies,
        );

        self.add_witnesses(&amp;mut tb)?;
        self.adjust_for_fee(&amp;mut tb, balance).await?;

        let tx = tb.build(provider).await?;

        let consensus_parameters = provider.consensus_parameters().await?;
        let tx_id = tx.id(consensus_parameters.chain_id());
        let tx_status = provider.send_transaction_and_await_commit(tx).await?;

        let receipts = tx_status.take_receipts_checked(None)?;

        Ok((tx_id.to_string(), receipts))
    }

    /// Withdraws an amount of the base asset to
    /// an address on the base chain.
    /// Returns the transaction ID, message ID and the list of receipts.
    async fn withdraw_to_base_layer(
        &amp;self,
        to: &amp;Bech32Address,
        amount: u64,
        tx_policies: TxPolicies,
    ) -&gt; Result&lt;(TxId, Nonce, Vec&lt;Receipt&gt;)&gt; {
        let provider = self.try_provider()?;
        let consensus_parameters = provider.consensus_parameters().await?;

        let inputs = self
            .get_asset_inputs_for_amount(*consensus_parameters.base_asset_id(), amount, None)
            .await?;

        let mut tb = ScriptTransactionBuilder::prepare_message_to_output(
            to.into(),
            amount,
            inputs,
            tx_policies,
            *consensus_parameters.base_asset_id(),
        );

        self.add_witnesses(&amp;mut tb)?;
        self.adjust_for_fee(&amp;mut tb, amount).await?;

        let tx = tb.build(provider).await?;

        let tx_id = tx.id(consensus_parameters.chain_id());
        let tx_status = provider.send_transaction_and_await_commit(tx).await?;

        let receipts = tx_status.take_receipts_checked(None)?;

        let nonce = extract_message_nonce(&amp;receipts)
            .expect("MessageId could not be retrieved from tx receipts.");

        Ok((tx_id, nonce, receipts))
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use fuel_crypto::{Message, SecretKey, Signature};
    use fuel_tx::{Address, ConsensusParameters, Output, Transaction as FuelTransaction};
    use fuels_core::{
        traits::Signer,
        types::{transaction::Transaction, DryRun, DryRunner},
    };
    use rand::{rngs::StdRng, RngCore, SeedableRng};

    use super::*;
    use crate::wallet::WalletUnlocked;

    #[tokio::test]
    async fn sign_and_verify() -&gt; Result&lt;()&gt; {
        // ANCHOR: sign_message
        let mut rng = StdRng::seed_from_u64(2322u64);
        let mut secret_seed = [0u8; 32];
        rng.fill_bytes(&amp;mut secret_seed);

        let secret = secret_seed.as_slice().try_into()?;

        // Create a wallet using the private key created above.
        let wallet = WalletUnlocked::new_from_private_key(secret, None);

        let message = Message::new("my message".as_bytes());
        let signature = wallet.sign(message).await?;

        // Check if signature is what we expect it to be
        assert_eq!(signature, Signature::from_str("0x8eeb238db1adea4152644f1cd827b552dfa9ab3f4939718bb45ca476d167c6512a656f4d4c7356bfb9561b14448c230c6e7e4bd781df5ee9e5999faa6495163d")?);

        // Recover address that signed the message
        let recovered_address = signature.recover(&amp;message)?;

        assert_eq!(wallet.address().hash(), recovered_address.hash());

        // Verify signature
        signature.verify(&amp;recovered_address, &amp;message)?;
        // ANCHOR_END: sign_message

        Ok(())
    }

    #[derive(Default)]
    struct MockDryRunner {
        c_param: ConsensusParameters,
    }

    #[cfg_attr(not(target_arch = "wasm32"), async_trait)]
    impl DryRunner for MockDryRunner {
        async fn dry_run(&amp;self, _: FuelTransaction) -&gt; Result&lt;DryRun&gt; {
            Ok(DryRun {
                succeeded: true,
                script_gas: 0,
                variable_outputs: 0,
            })
        }

        async fn consensus_parameters(&amp;self) -&gt; Result&lt;ConsensusParameters&gt; {
            Ok(self.c_param.clone())
        }

        async fn estimate_gas_price(&amp;self, _block_header: u32) -&gt; Result&lt;u64&gt; {
            Ok(0)
        }

        async fn estimate_predicates(
            &amp;self,
            _: &amp;FuelTransaction,
            _: Option&lt;u32&gt;,
        ) -&gt; Result&lt;FuelTransaction&gt; {
            unimplemented!()
        }
    }

    #[tokio::test]
    async fn sign_tx_and_verify() -&gt; std::result::Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
        // ANCHOR: sign_tb
        let secret = SecretKey::from_str(
            "5f70feeff1f229e4a95e1056e8b4d80d0b24b565674860cc213bdb07127ce1b1",
        )?;
        let wallet = WalletUnlocked::new_from_private_key(secret, None);

        // Set up a transaction
        let mut tb = {
            let input_coin = Input::ResourceSigned {
                resource: CoinType::Coin(Coin {
                    amount: 10000000,
                    owner: wallet.address().clone(),
                    ..Default::default()
                }),
            };

            let output_coin = Output::coin(
                Address::from_str(
                    "0xc7862855b418ba8f58878db434b21053a61a2025209889cc115989e8040ff077",
                )?,
                1,
                Default::default(),
            );
            let change = Output::change(wallet.address().into(), 0, Default::default());

            ScriptTransactionBuilder::prepare_transfer(
                vec![input_coin],
                vec![output_coin, change],
                Default::default(),
            )
        };

        // Add `Signer` to the transaction builder
        tb.add_signer(wallet.clone())?;
        // ANCHOR_END: sign_tb

        let tx = tb.build(MockDryRunner::default()).await?; // Resolve signatures and add corresponding witness indexes

        // Extract the signature from the tx witnesses
        let bytes = &lt;[u8; Signature::LEN]&gt;::try_from(tx.witnesses().first().unwrap().as_ref())?;
        let tx_signature = Signature::from_bytes(bytes);

        // Sign the transaction manually
        let message = Message::from_bytes(*tx.id(0.into()));
        let signature = wallet.sign(message).await?;

        // Check if the signatures are the same
        assert_eq!(signature, tx_signature);

        // Check if the signature is what we expect it to be
        assert_eq!(signature, Signature::from_str("faa616776a1c336ef6257f7cb0cb5cd932180e2d15faba5f17481dae1cbcaf314d94617bd900216a6680bccb1ea62438e4ca93b0d5733d33788ef9d79cc24e9f")?);

        // Recover the address that signed the transaction
        let recovered_address = signature.recover(&amp;message)?;

        assert_eq!(wallet.address().hash(), recovered_address.hash());

        // Verify signature
        signature.verify(&amp;recovered_address, &amp;message)?;

        Ok(())
    }
}</code></pre>
<h2 id="signing-a-built-transaction"><a class="header" href="#signing-a-built-transaction">Signing a built transaction</a></h2>
<p>If you have a built transaction and want to add a signature, you can use the <code>sign_with</code> method.</p>
<pre><code class="language-rust ignore">use std::time::Duration;

use fuel_tx::{
    consensus_parameters::{ConsensusParametersV1, FeeParametersV1},
    ConsensusParameters, FeeParameters, Output,
};
use fuels::{
    core::codec::{calldata, encode_fn_selector, DecoderConfig, EncoderConfig},
    prelude::*,
    programs::DEFAULT_MAX_FEE_ESTIMATION_TOLERANCE,
    tx::ContractParameters,
    types::{errors::transaction::Reason, input::Input, Bits256, Identity},
};
use tokio::time::Instant;

#[tokio::test]
async fn test_multiple_args() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "TestContract",
            project = "e2e/sway/contracts/contract_test"
        )),
        Deploy(
            name = "contract_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    // Make sure we can call the contract with multiple arguments
    let contract_methods = contract_instance.methods();
    let response = contract_methods.get(5, 6).call().await?;

    assert_eq!(response.value, 11);

    let t = MyType { x: 5, y: 6 };
    let response = contract_methods.get_alt(t.clone()).call().await?;
    assert_eq!(response.value, t);

    let response = contract_methods.get_single(5).call().await?;
    assert_eq!(response.value, 5);
    Ok(())
}

#[tokio::test]
async fn test_contract_calling_contract() -&gt; Result&lt;()&gt; {
    // Tests a contract call that calls another contract (FooCaller calls FooContract underneath)
    setup_program_test!(
        Wallets("wallet"),
        Abigen(
            Contract(
                name = "LibContract",
                project = "e2e/sway/contracts/lib_contract"
            ),
            Contract(
                name = "LibContractCaller",
                project = "e2e/sway/contracts/lib_contract_caller"
            ),
        ),
        Deploy(
            name = "lib_contract_instance",
            contract = "LibContract",
            wallet = "wallet",
            random_salt = false,
        ),
        Deploy(
            name = "lib_contract_instance2",
            contract = "LibContract",
            wallet = "wallet",
            random_salt = false,
        ),
        Deploy(
            name = "contract_caller_instance",
            contract = "LibContractCaller",
            wallet = "wallet",
            random_salt = false,
        ),
    );
    let lib_contract_id = lib_contract_instance.contract_id();
    let lib_contract_id2 = lib_contract_instance2.contract_id();

    // Call the contract directly. It increments the given value.
    let response = lib_contract_instance.methods().increment(42).call().await?;

    assert_eq!(43, response.value);

    let response = contract_caller_instance
        .methods()
        .increment_from_contracts(lib_contract_id, lib_contract_id2, 42)
        // Note that the two lib_contract_instances have different types
        .with_contracts(&amp;[&amp;lib_contract_instance, &amp;lib_contract_instance2])
        .call()
        .await?;

    assert_eq!(86, response.value);

    // ANCHOR: external_contract
    let response = contract_caller_instance
        .methods()
        .increment_from_contract(lib_contract_id, 42)
        .with_contracts(&amp;[&amp;lib_contract_instance])
        .call()
        .await?;
    // ANCHOR_END: external_contract

    assert_eq!(43, response.value);

    // ANCHOR: external_contract_ids
    let response = contract_caller_instance
        .methods()
        .increment_from_contract(lib_contract_id, 42)
        .with_contract_ids(&amp;[lib_contract_id.clone()])
        .call()
        .await?;
    // ANCHOR_END: external_contract_ids

    assert_eq!(43, response.value);
    Ok(())
}

#[tokio::test]
async fn test_reverting_transaction() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "RevertContract",
            project = "e2e/sway/contracts/revert_transaction_error"
        )),
        Deploy(
            name = "contract_instance",
            contract = "RevertContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    let response = contract_instance
        .methods()
        .make_transaction_fail(true)
        .call()
        .await;

    assert!(matches!(
        response,
        Err(Error::Transaction(Reason::Reverted { revert_id, .. })) if revert_id == 128
    ));

    Ok(())
}

#[tokio::test]
async fn test_multiple_read_calls() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "MultiReadContract",
            project = "e2e/sway/contracts/multiple_read_calls"
        )),
        Deploy(
            name = "contract_instance",
            contract = "MultiReadContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    let contract_methods = contract_instance.methods();
    contract_methods.store(42).call().await?;

    // Use "simulate" because the methods don't actually
    // run a transaction, but just a dry-run
    let stored = contract_methods
        .read()
        .simulate(Execution::StateReadOnly)
        .await?;

    assert_eq!(stored.value, 42);

    let stored = contract_methods
        .read()
        .simulate(Execution::StateReadOnly)
        .await?;

    assert_eq!(stored.value, 42);
    Ok(())
}

#[tokio::test]
async fn test_multi_call_beginner() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "TestContract",
            project = "e2e/sway/contracts/contract_test"
        )),
        Deploy(
            name = "contract_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    let contract_methods = contract_instance.methods();
    let call_handler_1 = contract_methods.get_single(7);
    let call_handler_2 = contract_methods.get_single(42);

    let multi_call_handler = CallHandler::new_multi_call(wallet.clone())
        .add_call(call_handler_1)
        .add_call(call_handler_2);

    let (val_1, val_2): (u64, u64) = multi_call_handler.call().await?.value;

    assert_eq!(val_1, 7);
    assert_eq!(val_2, 42);

    Ok(())
}

#[tokio::test]
async fn test_multi_call_pro() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "TestContract",
            project = "e2e/sway/contracts/contract_test"
        )),
        Deploy(
            name = "contract_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    let my_type_1 = MyType { x: 1, y: 2 };
    let my_type_2 = MyType { x: 3, y: 4 };

    let contract_methods = contract_instance.methods();
    let call_handler_1 = contract_methods.get_single(5);
    let call_handler_2 = contract_methods.get_single(6);
    let call_handler_3 = contract_methods.get_alt(my_type_1.clone());
    let call_handler_4 = contract_methods.get_alt(my_type_2.clone());
    let call_handler_5 = contract_methods.get_array([7; 2]);
    let call_handler_6 = contract_methods.get_array([42; 2]);

    let multi_call_handler = CallHandler::new_multi_call(wallet.clone())
        .add_call(call_handler_1)
        .add_call(call_handler_2)
        .add_call(call_handler_3)
        .add_call(call_handler_4)
        .add_call(call_handler_5)
        .add_call(call_handler_6);

    let (val_1, val_2, type_1, type_2, array_1, array_2): (
        u64,
        u64,
        MyType,
        MyType,
        [u64; 2],
        [u64; 2],
    ) = multi_call_handler.call().await?.value;

    assert_eq!(val_1, 5);
    assert_eq!(val_2, 6);
    assert_eq!(type_1, my_type_1);
    assert_eq!(type_2, my_type_2);
    assert_eq!(array_1, [7; 2]);
    assert_eq!(array_2, [42; 2]);

    Ok(())
}

#[tokio::test]
async fn test_contract_call_fee_estimation() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "TestContract",
            project = "e2e/sway/contracts/contract_test"
        )),
        Deploy(
            name = "contract_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    let gas_limit = 800;
    let tolerance = Some(0.2);
    let block_horizon = Some(1);
    let expected_gas_used = 960;
    let expected_metered_bytes_size = 824;

    let estimated_transaction_cost = contract_instance
        .methods()
        .initialize_counter(42)
        .with_tx_policies(TxPolicies::default().with_script_gas_limit(gas_limit))
        .estimate_transaction_cost(tolerance, block_horizon)
        .await?;

    assert_eq!(estimated_transaction_cost.gas_used, expected_gas_used);
    assert_eq!(
        estimated_transaction_cost.metered_bytes_size,
        expected_metered_bytes_size
    );

    Ok(())
}

#[tokio::test]
async fn contract_call_has_same_estimated_and_used_gas() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "TestContract",
            project = "e2e/sway/contracts/contract_test"
        )),
        Deploy(
            name = "contract_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );
    let contract_methods = contract_instance.methods();

    let tolerance = Some(0.0);
    let block_horizon = Some(1);

    let estimated_gas_used = contract_methods
        .initialize_counter(42)
        .estimate_transaction_cost(tolerance, block_horizon)
        .await?
        .gas_used;

    let gas_used = contract_methods
        .initialize_counter(42)
        .call()
        .await?
        .gas_used;

    assert_eq!(estimated_gas_used, gas_used);
    Ok(())
}

#[tokio::test]
async fn mult_call_has_same_estimated_and_used_gas() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "TestContract",
            project = "e2e/sway/contracts/contract_test"
        )),
        Deploy(
            name = "contract_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    let contract_methods = contract_instance.methods();
    let call_handler_1 = contract_methods.initialize_counter(42);
    let call_handler_2 = contract_methods.get_array([42; 2]);

    let multi_call_handler = CallHandler::new_multi_call(wallet.clone())
        .add_call(call_handler_1)
        .add_call(call_handler_2);

    let tolerance = Some(0.0);
    let block_horizon = Some(1);
    let estimated_gas_used = multi_call_handler
        .estimate_transaction_cost(tolerance, block_horizon)
        .await?
        .gas_used;

    let gas_used = multi_call_handler.call::&lt;(u64, [u64; 2])&gt;().await?.gas_used;

    assert_eq!(estimated_gas_used, gas_used);
    Ok(())
}

#[tokio::test]
async fn contract_method_call_respects_maturity() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "BlockHeightContract",
            project = "e2e/sway/contracts/transaction_block_height"
        )),
        Deploy(
            name = "contract_instance",
            contract = "BlockHeightContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    let call_w_maturity = |maturity| {
        contract_instance
            .methods()
            .calling_this_will_produce_a_block()
            .with_tx_policies(TxPolicies::default().with_maturity(maturity))
    };

    call_w_maturity(1).call().await.expect(
        "should have passed since we're calling with a maturity \
         that is less or equal to the current block height",
    );

    call_w_maturity(3).call().await.expect_err(
        "should have failed since we're calling with a maturity \
         that is greater than the current block height",
    );

    Ok(())
}

#[tokio::test]
async fn test_auth_msg_sender_from_sdk() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "AuthContract",
            project = "e2e/sway/contracts/auth_testing_contract"
        )),
        Deploy(
            name = "contract_instance",
            contract = "AuthContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    // Contract returns true if `msg_sender()` matches `wallet.address()`.
    let response = contract_instance
        .methods()
        .check_msg_sender(wallet.address())
        .call()
        .await?;

    assert!(response.value);
    Ok(())
}

#[tokio::test]
async fn test_large_return_data() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "TestContract",
            project = "e2e/sway/contracts/large_return_data"
        )),
        Deploy(
            name = "contract_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    let contract_methods = contract_instance.methods();
    let res = contract_methods.get_id().call().await?;

    assert_eq!(
        res.value.0,
        [
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255
        ]
    );

    // One word-sized string
    let res = contract_methods.get_small_string().call().await?;
    assert_eq!(res.value, "gggggggg");

    // Two word-sized string
    let res = contract_methods.get_large_string().call().await?;
    assert_eq!(res.value, "ggggggggg");

    // Large struct will be bigger than a `WORD`.
    let res = contract_methods.get_large_struct().call().await?;
    assert_eq!(res.value.foo, 12);
    assert_eq!(res.value.bar, 42);

    // Array will be returned in `ReturnData`.
    let res = contract_methods.get_large_array().call().await?;
    assert_eq!(res.value, [1, 2]);

    let res = contract_methods.get_contract_id().call().await?;

    // First `value` is from `CallResponse`.
    // Second `value` is from the `ContractId` type.
    assert_eq!(
        res.value,
        ContractId::from([
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255
        ])
    );
    Ok(())
}

#[tokio::test]
async fn can_handle_function_called_new() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "TestContract",
            project = "e2e/sway/contracts/contract_test"
        )),
        Deploy(
            name = "contract_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    let response = contract_instance.methods().new().call().await?.value;

    assert_eq!(response, 12345);
    Ok(())
}

#[tokio::test]
async fn test_contract_setup_macro_deploy_with_salt() -&gt; Result&lt;()&gt; {
    // ANCHOR: contract_setup_macro_multi
    setup_program_test!(
        Wallets("wallet"),
        Abigen(
            Contract(
                name = "LibContract",
                project = "e2e/sway/contracts/lib_contract"
            ),
            Contract(
                name = "LibContractCaller",
                project = "e2e/sway/contracts/lib_contract_caller"
            ),
        ),
        Deploy(
            name = "lib_contract_instance",
            contract = "LibContract",
            wallet = "wallet",
            random_salt = false,
        ),
        Deploy(
            name = "contract_caller_instance",
            contract = "LibContractCaller",
            wallet = "wallet",
        ),
        Deploy(
            name = "contract_caller_instance2",
            contract = "LibContractCaller",
            wallet = "wallet",
        ),
    );
    let lib_contract_id = lib_contract_instance.contract_id();

    let contract_caller_id = contract_caller_instance.contract_id();

    let contract_caller_id2 = contract_caller_instance2.contract_id();

    // Because we deploy with salt, we can deploy the same contract multiple times
    assert_ne!(contract_caller_id, contract_caller_id2);

    // The first contract can be called because they were deployed on the same provider
    let response = contract_caller_instance
        .methods()
        .increment_from_contract(lib_contract_id, 42)
        .with_contracts(&amp;[&amp;lib_contract_instance])
        .call()
        .await?;

    assert_eq!(43, response.value);

    let response = contract_caller_instance2
        .methods()
        .increment_from_contract(lib_contract_id, 42)
        .with_contracts(&amp;[&amp;lib_contract_instance])
        .call()
        .await?;

    assert_eq!(43, response.value);
    // ANCHOR_END: contract_setup_macro_multi

    Ok(())
}

#[tokio::test]
async fn test_wallet_getter() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "TestContract",
            project = "e2e/sway/contracts/contract_test"
        )),
        Deploy(
            name = "contract_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    assert_eq!(contract_instance.account().address(), wallet.address());
    //`contract_id()` is tested in
    // async fn test_contract_calling_contract() -&gt; Result&lt;()&gt; {
    Ok(())
}

#[tokio::test]
async fn test_connect_wallet() -&gt; Result&lt;()&gt; {
    // ANCHOR: contract_setup_macro_manual_wallet
    let config = WalletsConfig::new(Some(2), Some(1), Some(DEFAULT_COIN_AMOUNT));

    let mut wallets = launch_custom_provider_and_get_wallets(config, None, None).await?;
    let wallet = wallets.pop().unwrap();
    let wallet_2 = wallets.pop().unwrap();

    setup_program_test!(
        Abigen(Contract(
            name = "TestContract",
            project = "e2e/sway/contracts/contract_test"
        )),
        Deploy(
            name = "contract_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );
    // ANCHOR_END: contract_setup_macro_manual_wallet

    // pay for call with wallet
    let tx_policies = TxPolicies::default()
        .with_tip(100)
        .with_script_gas_limit(1_000_000);

    contract_instance
        .methods()
        .initialize_counter(42)
        .with_tx_policies(tx_policies)
        .call()
        .await?;

    // confirm that funds have been deducted
    let wallet_balance = wallet.get_asset_balance(&amp;Default::default()).await?;
    assert!(DEFAULT_COIN_AMOUNT &gt; wallet_balance);

    // pay for call with wallet_2
    contract_instance
        .with_account(wallet_2.clone())
        .methods()
        .initialize_counter(42)
        .with_tx_policies(tx_policies)
        .call()
        .await?;

    // confirm there are no changes to wallet, wallet_2 has been charged
    let wallet_balance_second_call = wallet.get_asset_balance(&amp;Default::default()).await?;
    let wallet_2_balance = wallet_2.get_asset_balance(&amp;Default::default()).await?;
    assert_eq!(wallet_balance_second_call, wallet_balance);
    assert!(DEFAULT_COIN_AMOUNT &gt; wallet_2_balance);

    Ok(())
}

async fn setup_output_variable_estimation_test() -&gt; Result&lt;(
    Vec&lt;WalletUnlocked&gt;,
    [Identity; 3],
    AssetId,
    Bech32ContractId,
)&gt; {
    let wallet_config = WalletsConfig::new(Some(3), None, None);
    let wallets = launch_custom_provider_and_get_wallets(wallet_config, None, None).await?;

    let contract_id = Contract::load_from(
        "sway/contracts/token_ops/out/release/token_ops.bin",
        LoadConfiguration::default(),
    )?
    .deploy_if_not_exists(&amp;wallets[0], TxPolicies::default())
    .await?;

    let mint_asset_id = contract_id.asset_id(&amp;Bits256::zeroed());
    let addresses = wallets
        .iter()
        .map(|wallet| wallet.address().into())
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .try_into()
        .unwrap();

    Ok((wallets, addresses, mint_asset_id, contract_id))
}

#[tokio::test]
async fn test_output_variable_estimation() -&gt; Result&lt;()&gt; {
    abigen!(Contract(
        name = "MyContract",
        abi = "e2e/sway/contracts/token_ops/out/release/token_ops-abi.json"
    ));

    let (wallets, addresses, mint_asset_id, contract_id) =
        setup_output_variable_estimation_test().await?;

    let contract_instance = MyContract::new(contract_id, wallets[0].clone());
    let contract_methods = contract_instance.methods();
    let amount = 1000;

    {
        // Should fail due to lack of output variables
        let response = contract_methods
            .mint_to_addresses(amount, addresses)
            .call()
            .await;

        assert!(matches!(
            response,
            Err(Error::Transaction(Reason::Reverted { .. }))
        ));
    }

    {
        // Should add 3 output variables automatically
        let _ = contract_methods
            .mint_to_addresses(amount, addresses)
            .with_variable_output_policy(VariableOutputPolicy::EstimateMinimum)
            .call()
            .await?;

        for wallet in wallets.iter() {
            let balance = wallet.get_asset_balance(&amp;mint_asset_id).await?;
            assert_eq!(balance, amount);
        }
    }

    Ok(())
}

#[tokio::test]
async fn test_output_variable_estimation_multicall() -&gt; Result&lt;()&gt; {
    abigen!(Contract(
        name = "MyContract",
        abi = "e2e/sway/contracts/token_ops/out/release/token_ops-abi.json"
    ));

    let (wallets, addresses, mint_asset_id, contract_id) =
        setup_output_variable_estimation_test().await?;

    let contract_instance = MyContract::new(contract_id.clone(), wallets[0].clone());
    let contract_methods = contract_instance.methods();
    const NUM_OF_CALLS: u64 = 3;
    let amount = 1000;
    let total_amount = amount * NUM_OF_CALLS;

    let mut multi_call_handler = CallHandler::new_multi_call(wallets[0].clone());
    for _ in 0..NUM_OF_CALLS {
        let call_handler = contract_methods.mint_to_addresses(amount, addresses);
        multi_call_handler = multi_call_handler.add_call(call_handler);
    }

    wallets[0]
        .force_transfer_to_contract(
            &amp;contract_id,
            total_amount,
            AssetId::zeroed(),
            TxPolicies::default(),
        )
        .await
        .unwrap();

    let base_layer_address = Bits256([1u8; 32]);
    let call_handler = contract_methods.send_message(base_layer_address, amount);
    multi_call_handler = multi_call_handler.add_call(call_handler);

    let _ = multi_call_handler
        .with_variable_output_policy(VariableOutputPolicy::EstimateMinimum)
        .call::&lt;((), (), ())&gt;()
        .await?;

    for wallet in wallets.iter() {
        let balance = wallet.get_asset_balance(&amp;mint_asset_id).await?;
        assert_eq!(balance, 3 * amount);
    }

    Ok(())
}

#[tokio::test]
async fn test_contract_instance_get_balances() -&gt; Result&lt;()&gt; {
    let mut wallet = WalletUnlocked::new_random(None);
    let (coins, asset_ids) = setup_multiple_assets_coins(wallet.address(), 2, 4, 8);

    let random_asset_id = &amp;asset_ids[1];
    let provider = setup_test_provider(coins.clone(), vec![], None, None).await?;
    wallet.set_provider(provider.clone());

    setup_program_test!(
        Abigen(Contract(
            name = "TestContract",
            project = "e2e/sway/contracts/contract_test"
        )),
        Deploy(
            name = "contract_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );
    let contract_id = contract_instance.contract_id();

    // Check the current balance of the contract with id 'contract_id'
    let contract_balances = contract_instance.get_balances().await?;
    assert!(contract_balances.is_empty());

    // Transfer an amount to the contract
    let amount = 8;
    wallet
        .force_transfer_to_contract(contract_id, amount, *random_asset_id, TxPolicies::default())
        .await?;

    // Check that the contract now has 1 coin
    let contract_balances = contract_instance.get_balances().await?;
    assert_eq!(contract_balances.len(), 1);

    let random_asset_balance = contract_balances.get(random_asset_id).unwrap();
    assert_eq!(*random_asset_balance, amount);

    Ok(())
}

#[tokio::test]
async fn contract_call_futures_implement_send() -&gt; Result&lt;()&gt; {
    use std::future::Future;

    fn tokio_spawn_imitation&lt;T&gt;(_: T)
    where
        T: Future + Send + 'static,
    {
    }

    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "TestContract",
            project = "e2e/sway/contracts/contract_test"
        )),
        Deploy(
            name = "contract_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    tokio_spawn_imitation(async move {
        contract_instance
            .methods()
            .initialize_counter(42)
            .call()
            .await
            .unwrap();
    });
    Ok(())
}

#[tokio::test]
async fn test_contract_set_estimation() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(
            Contract(
                name = "LibContract",
                project = "e2e/sway/contracts/lib_contract"
            ),
            Contract(
                name = "LibContractCaller",
                project = "e2e/sway/contracts/lib_contract_caller"
            ),
        ),
        Deploy(
            name = "lib_contract_instance",
            contract = "LibContract",
            wallet = "wallet",
            random_salt = false,
        ),
        Deploy(
            name = "contract_caller_instance",
            contract = "LibContractCaller",
            wallet = "wallet",
            random_salt = false,
        ),
    );
    let lib_contract_id = lib_contract_instance.contract_id();

    let res = lib_contract_instance.methods().increment(42).call().await?;
    assert_eq!(43, res.value);

    {
        // Should fail due to missing external contracts
        let res = contract_caller_instance
            .methods()
            .increment_from_contract(lib_contract_id, 42)
            .call()
            .await;

        assert!(matches!(
            res,
            Err(Error::Transaction(Reason::Reverted { .. }))
        ));
    }

    let res = contract_caller_instance
        .methods()
        .increment_from_contract(lib_contract_id, 42)
        .determine_missing_contracts(None)
        .await?
        .call()
        .await?;

    assert_eq!(43, res.value);
    Ok(())
}

#[tokio::test]
async fn test_output_variable_contract_id_estimation_multicall() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(
            Contract(
                name = "LibContract",
                project = "e2e/sway/contracts/lib_contract"
            ),
            Contract(
                name = "LibContractCaller",
                project = "e2e/sway/contracts/lib_contract_caller"
            ),
            Contract(
                name = "TestContract",
                project = "e2e/sway/contracts/contract_test"
            ),
        ),
        Deploy(
            name = "lib_contract_instance",
            contract = "LibContract",
            wallet = "wallet",
            random_salt = false,
        ),
        Deploy(
            name = "contract_caller_instance",
            contract = "LibContractCaller",
            wallet = "wallet",
            random_salt = false,
        ),
        Deploy(
            name = "contract_test_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    let lib_contract_id = lib_contract_instance.contract_id();

    let contract_methods = contract_caller_instance.methods();

    let mut multi_call_handler =
        CallHandler::new_multi_call(wallet.clone()).with_tx_policies(Default::default());

    for _ in 0..3 {
        let call_handler = contract_methods.increment_from_contract(lib_contract_id, 42);
        multi_call_handler = multi_call_handler.add_call(call_handler);
    }

    // add call that does not need ContractId
    let contract_methods = contract_test_instance.methods();
    let call_handler = contract_methods.get(5, 6);

    multi_call_handler = multi_call_handler.add_call(call_handler);

    let call_response = multi_call_handler
        .determine_missing_contracts(None)
        .await?
        .call::&lt;(u64, u64, u64, u64)&gt;()
        .await?;

    assert_eq!(call_response.value, (43, 43, 43, 11));

    Ok(())
}

#[tokio::test]
async fn test_contract_call_with_non_default_max_input() -&gt; Result&lt;()&gt; {
    use fuels::{
        tx::{ConsensusParameters, TxParameters},
        types::coin::Coin,
    };

    let mut consensus_parameters = ConsensusParameters::default();
    let tx_params = TxParameters::default()
        .with_max_inputs(123)
        .with_max_size(1_000_000);
    consensus_parameters.set_tx_params(tx_params);
    let contract_params = ContractParameters::default().with_contract_max_size(1_000_000);
    consensus_parameters.set_contract_params(contract_params);

    let mut wallet = WalletUnlocked::new_random(None);

    let coins: Vec&lt;Coin&gt; = setup_single_asset_coins(
        wallet.address(),
        Default::default(),
        DEFAULT_NUM_COINS,
        DEFAULT_COIN_AMOUNT,
    );
    let chain_config = ChainConfig {
        consensus_parameters: consensus_parameters.clone(),
        ..ChainConfig::default()
    };

    let provider = setup_test_provider(coins, vec![], None, Some(chain_config)).await?;
    wallet.set_provider(provider.clone());
    assert_eq!(consensus_parameters, provider.consensus_parameters().await?);

    setup_program_test!(
        Abigen(Contract(
            name = "TestContract",
            project = "e2e/sway/contracts/contract_test"
        )),
        Deploy(
            name = "contract_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    let response = contract_instance.methods().get(5, 6).call().await?;

    assert_eq!(response.value, 11);

    Ok(())
}

#[tokio::test]
async fn test_add_custom_assets() -&gt; Result&lt;()&gt; {
    let initial_amount = 100_000;
    let asset_base = AssetConfig {
        id: AssetId::zeroed(),
        num_coins: 1,
        coin_amount: initial_amount,
    };

    let asset_id_1 = AssetId::from([3u8; 32]);
    let asset_1 = AssetConfig {
        id: asset_id_1,
        num_coins: 1,
        coin_amount: initial_amount,
    };

    let asset_id_2 = AssetId::from([1u8; 32]);
    let asset_2 = AssetConfig {
        id: asset_id_2,
        num_coins: 1,
        coin_amount: initial_amount,
    };

    let assets = vec![asset_base, asset_1, asset_2];

    let num_wallets = 2;
    let wallet_config = WalletsConfig::new_multiple_assets(num_wallets, assets);
    let mut wallets = launch_custom_provider_and_get_wallets(wallet_config, None, None).await?;
    let wallet_1 = wallets.pop().unwrap();
    let wallet_2 = wallets.pop().unwrap();

    setup_program_test!(
        Abigen(Contract(
            name = "MyContract",
            project = "e2e/sway/contracts/contract_test"
        )),
        Deploy(
            name = "contract_instance",
            contract = "MyContract",
            wallet = "wallet_1",
            random_salt = false,
        ),
    );

    let amount_1 = 5000;
    let amount_2 = 3000;
    let response = contract_instance
        .methods()
        .get(5, 6)
        .add_custom_asset(asset_id_1, amount_1, Some(wallet_2.address().clone()))
        .add_custom_asset(asset_id_2, amount_2, Some(wallet_2.address().clone()))
        .call()
        .await?;

    assert_eq!(response.value, 11);

    let balance_asset_1 = wallet_1.get_asset_balance(&amp;asset_id_1).await?;
    let balance_asset_2 = wallet_1.get_asset_balance(&amp;asset_id_2).await?;
    assert_eq!(balance_asset_1, initial_amount - amount_1);
    assert_eq!(balance_asset_2, initial_amount - amount_2);

    let balance_asset_1 = wallet_2.get_asset_balance(&amp;asset_id_1).await?;
    let balance_asset_2 = wallet_2.get_asset_balance(&amp;asset_id_2).await?;
    assert_eq!(balance_asset_1, initial_amount + amount_1);
    assert_eq!(balance_asset_2, initial_amount + amount_2);

    Ok(())
}

#[tokio::test]
async fn contract_load_error_messages() {
    {
        let binary_path = "sway/contracts/contract_test/out/release/no_file_on_path.bin";
        let expected_error = format!("io: file \"{binary_path}\" does not exist");

        let error = Contract::load_from(binary_path, LoadConfiguration::default())
            .expect_err("should have failed");

        assert_eq!(error.to_string(), expected_error);
    }
    {
        let binary_path = "sway/contracts/contract_test/out/release/contract_test-abi.json";
        let expected_error = format!("expected \"{binary_path}\" to have '.bin' extension");

        let error = Contract::load_from(binary_path, LoadConfiguration::default())
            .expect_err("should have failed");

        assert_eq!(error.to_string(), expected_error);
    }
}

#[tokio::test]
async fn test_payable_annotation() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "TestContract",
            project = "e2e/sway/contracts/payable_annotation"
        )),
        Deploy(
            name = "contract_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    let contract_methods = contract_instance.methods();

    let response = contract_methods
        .payable()
        .call_params(
            CallParameters::default()
                .with_amount(100)
                .with_gas_forwarded(20_000),
        )?
        .call()
        .await?;

    assert_eq!(response.value, 42);

    // ANCHOR: non_payable_params
    let err = contract_methods
        .non_payable()
        .call_params(CallParameters::default().with_amount(100))
        .expect_err("should return error");

    assert!(matches!(err, Error::Other(s) if s.contains("assets forwarded to non-payable method")));
    // ANCHOR_END: non_payable_params

    let response = contract_methods
        .non_payable()
        .call_params(CallParameters::default().with_gas_forwarded(20_000))?
        .call()
        .await?;

    assert_eq!(response.value, 42);

    Ok(())
}

#[tokio::test]
async fn multi_call_from_calls_with_different_account_types() -&gt; Result&lt;()&gt; {
    use fuels::prelude::*;

    abigen!(Contract(
        name = "MyContract",
        abi = "e2e/sway/contracts/contract_test/out/release/contract_test-abi.json"
    ));

    let wallet = WalletUnlocked::new_random(None);
    let predicate = Predicate::from_code(vec![]);

    let contract_methods_wallet =
        MyContract::new(Bech32ContractId::default(), wallet.clone()).methods();
    let contract_methods_predicate =
        MyContract::new(Bech32ContractId::default(), predicate).methods();

    let call_handler_1 = contract_methods_wallet.initialize_counter(42);
    let call_handler_2 = contract_methods_predicate.get_array([42; 2]);

    let _multi_call_handler = CallHandler::new_multi_call(wallet)
        .add_call(call_handler_1)
        .add_call(call_handler_2);

    Ok(())
}

#[tokio::test]
async fn low_level_call() -&gt; Result&lt;()&gt; {
    use fuels::types::SizedAsciiString;

    setup_program_test!(
        Wallets("wallet"),
        Abigen(
            Contract(
                name = "MyCallerContract",
                project = "e2e/sway/contracts/low_level_caller"
            ),
            Contract(
                name = "MyTargetContract",
                project = "e2e/sway/contracts/contract_test"
            ),
        ),
        Deploy(
            name = "caller_contract_instance",
            contract = "MyCallerContract",
            wallet = "wallet",
            random_salt = false,
        ),
        Deploy(
            name = "target_contract_instance",
            contract = "MyTargetContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    let function_selector = encode_fn_selector("initialize_counter");
    let call_data = calldata!(42u64)?;

    caller_contract_instance
        .methods()
        .call_low_level_call(
            target_contract_instance.id(),
            Bytes(function_selector),
            Bytes(call_data),
        )
        .determine_missing_contracts(None)
        .await?
        .call()
        .await?;

    let response = target_contract_instance
        .methods()
        .get_counter()
        .call()
        .await?;
    assert_eq!(response.value, 42);

    let function_selector = encode_fn_selector("set_value_multiple_complex");
    let call_data = calldata!(
        MyStruct {
            a: true,
            b: [1, 2, 3],
        },
        SizedAsciiString::&lt;4&gt;::try_from("fuel")?
    )?;

    caller_contract_instance
        .methods()
        .call_low_level_call(
            target_contract_instance.id(),
            Bytes(function_selector),
            Bytes(call_data),
        )
        .determine_missing_contracts(None)
        .await?
        .call()
        .await?;

    let result_uint = target_contract_instance
        .methods()
        .get_counter()
        .call()
        .await
        .unwrap()
        .value;

    let result_bool = target_contract_instance
        .methods()
        .get_bool_value()
        .call()
        .await
        .unwrap()
        .value;

    let result_str = target_contract_instance
        .methods()
        .get_str_value()
        .call()
        .await
        .unwrap()
        .value;

    assert_eq!(result_uint, 42);
    assert!(result_bool);
    assert_eq!(result_str, "fuel");

    Ok(())
}

#[cfg(any(not(feature = "fuel-core-lib"), feature = "rocksdb"))]
#[test]
fn db_rocksdb() {
    use std::{fs, str::FromStr};

    use fuels::{
        accounts::wallet::WalletUnlocked,
        client::{PageDirection, PaginationRequest},
        crypto::SecretKey,
        prelude::{setup_test_provider, DbType, Error, ViewOnlyAccount, DEFAULT_COIN_AMOUNT},
    };

    let temp_dir = tempfile::tempdir().expect("failed to make tempdir");
    let temp_dir_name = temp_dir
        .path()
        .file_name()
        .expect("failed to get file name")
        .to_string_lossy()
        .to_string();
    let temp_database_path = temp_dir.path().join("db");

    tokio::runtime::Runtime::new()
        .expect("tokio runtime failed")
        .block_on(async {
            let _ = temp_dir;
            let wallet = WalletUnlocked::new_from_private_key(
                SecretKey::from_str(
                    "0x4433d156e8c53bf5b50af07aa95a29436f29a94e0ccc5d58df8e57bdc8583c32",
                )?,
                None,
            );

            const NUMBER_OF_ASSETS: u64 = 2;
            let node_config = NodeConfig {
                database_type: DbType::RocksDb(Some(temp_database_path.clone())),
                ..NodeConfig::default()
            };

            let chain_config = ChainConfig {
                chain_name: temp_dir_name.clone(),
                consensus_parameters: Default::default(),
                ..ChainConfig::local_testnet()
            };

            let (coins, _) = setup_multiple_assets_coins(
                wallet.address(),
                NUMBER_OF_ASSETS,
                DEFAULT_NUM_COINS,
                DEFAULT_COIN_AMOUNT,
            );

            let provider =
                setup_test_provider(coins.clone(), vec![], Some(node_config), Some(chain_config))
                    .await?;

            provider.produce_blocks(2, None).await?;

            Ok::&lt;(), Error&gt;(())
        })
        .unwrap();

    // The runtime needs to be terminated because the node can currently only be killed when the runtime itself shuts down.

    tokio::runtime::Runtime::new()
        .expect("tokio runtime failed")
        .block_on(async {
            let node_config = NodeConfig {
                database_type: DbType::RocksDb(Some(temp_database_path.clone())),
                ..NodeConfig::default()
            };

            let provider = setup_test_provider(vec![], vec![], Some(node_config), None).await?;
            // the same wallet that was used when rocksdb was built. When we connect it to the provider, we expect it to have the same amount of assets
            let mut wallet = WalletUnlocked::new_from_private_key(
                SecretKey::from_str(
                    "0x4433d156e8c53bf5b50af07aa95a29436f29a94e0ccc5d58df8e57bdc8583c32",
                )?,
                None,
            );

            wallet.set_provider(provider.clone());

            let blocks = provider
                .get_blocks(PaginationRequest {
                    cursor: None,
                    results: 10,
                    direction: PageDirection::Forward,
                })
                .await?
                .results;

            assert_eq!(blocks.len(), 3);
            assert_eq!(
                *wallet.get_balances().await?.iter().next().unwrap().1,
                DEFAULT_COIN_AMOUNT as u128
            );
            assert_eq!(
                *wallet.get_balances().await?.iter().next().unwrap().1,
                DEFAULT_COIN_AMOUNT as u128
            );
            assert_eq!(wallet.get_balances().await?.len(), 2);

            fs::remove_dir_all(
                temp_database_path
                    .parent()
                    .expect("db parent folder does not exist"),
            )?;

            Ok::&lt;(), Error&gt;(())
        })
        .unwrap();
}

#[tokio::test]
async fn can_configure_decoding_of_contract_return() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "MyContract",
            project = "e2e/sway/contracts/needs_custom_decoder"
        ),),
        Deploy(
            contract = "MyContract",
            name = "contract_instance",
            wallet = "wallet",
            random_salt = false,
        )
    );

    let methods = contract_instance.methods();
    {
        // Single call: Will not work if max_tokens not big enough
        methods.i_return_a_1k_el_array().with_decoder_config(DecoderConfig{max_tokens: 100, ..Default::default()}).call().await.expect_err(
             "should have failed because there are more tokens than what is supported by default",
         );
    }
    {
        // Single call: Works when limit is bumped
        let result = methods
            .i_return_a_1k_el_array()
            .with_decoder_config(DecoderConfig {
                max_tokens: 1001,
                ..Default::default()
            })
            .call()
            .await?
            .value;

        assert_eq!(result, [0; 1000]);
    }
    {
        // Multi call: Will not work if max_tokens not big enough
        CallHandler::new_multi_call(wallet.clone())
         .add_call(methods.i_return_a_1k_el_array())
         .with_decoder_config(DecoderConfig { max_tokens: 100, ..Default::default() })
         .call::&lt;([u8; 1000],)&gt;().await.expect_err(
             "should have failed because there are more tokens than what is supported by default",
         );
    }
    {
        // Multi call: Works when configured
        CallHandler::new_multi_call(wallet.clone())
            .add_call(methods.i_return_a_1k_el_array())
            .with_decoder_config(DecoderConfig {
                max_tokens: 1001,
                ..Default::default()
            })
            .call::&lt;([u8; 1000],)&gt;()
            .await
            .unwrap();
    }

    Ok(())
}

#[tokio::test]
async fn test_contract_submit_and_response() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "TestContract",
            project = "e2e/sway/contracts/contract_test"
        )),
        Deploy(
            name = "contract_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    let contract_methods = contract_instance.methods();

    let submitted_tx = contract_methods.get(1, 2).submit().await?;
    tokio::time::sleep(Duration::from_millis(500)).await;
    let value = submitted_tx.response().await?.value;

    assert_eq!(value, 3);

    let contract_methods = contract_instance.methods();
    let call_handler_1 = contract_methods.get_single(7);
    let call_handler_2 = contract_methods.get_single(42);

    let multi_call_handler = CallHandler::new_multi_call(wallet.clone())
        .add_call(call_handler_1)
        .add_call(call_handler_2);

    let handle = multi_call_handler.submit().await?;
    tokio::time::sleep(Duration::from_millis(500)).await;
    let (val_1, val_2): (u64, u64) = handle.response().await?.value;

    assert_eq!(val_1, 7);
    assert_eq!(val_2, 42);

    Ok(())
}

#[tokio::test]
async fn test_heap_type_multicall() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(
            Contract(
                name = "TestContract",
                project = "e2e/sway/contracts/contract_test"
            ),
            Contract(
                name = "VectorOutputContract",
                project = "e2e/sway/types/contracts/vector_output"
            )
        ),
        Deploy(
            name = "contract_instance",
            contract = "VectorOutputContract",
            wallet = "wallet",
            random_salt = false,
        ),
        Deploy(
            name = "contract_instance_2",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    {
        let call_handler_1 = contract_instance.methods().u8_in_vec(5);
        let call_handler_2 = contract_instance_2.methods().get_single(7);
        let call_handler_3 = contract_instance.methods().u8_in_vec(3);

        let multi_call_handler = CallHandler::new_multi_call(wallet.clone())
            .add_call(call_handler_1)
            .add_call(call_handler_2)
            .add_call(call_handler_3);

        let (val_1, val_2, val_3): (Vec&lt;u8&gt;, u64, Vec&lt;u8&gt;) = multi_call_handler.call().await?.value;

        assert_eq!(val_1, vec![0, 1, 2, 3, 4]);
        assert_eq!(val_2, 7);
        assert_eq!(val_3, vec![0, 1, 2]);
    }

    Ok(())
}

#[tokio::test]
async fn heap_types_correctly_offset_in_create_transactions_w_storage_slots() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Predicate(
            name = "MyPredicate",
            project = "e2e/sway/types/predicates/predicate_vector"
        ),),
    );

    let provider = wallet.try_provider()?.clone();
    let data = MyPredicateEncoder::default().encode_data(18, 24, vec![2, 4, 42])?;
    let predicate = Predicate::load_from(
        "sway/types/predicates/predicate_vector/out/release/predicate_vector.bin",
    )?
    .with_data(data)
    .with_provider(provider);

    wallet
        .transfer(
            predicate.address(),
            10_000,
            AssetId::zeroed(),
            TxPolicies::default(),
        )
        .await?;

    // if the contract is successfully deployed then the predicate was unlocked. This further means
    // the offsets were setup correctly since the predicate uses heap types in its arguments.
    // Storage slots were loaded automatically by default
    Contract::load_from(
        "sway/contracts/storage/out/release/storage.bin",
        LoadConfiguration::default(),
    )?
    .deploy_if_not_exists(&amp;predicate, TxPolicies::default())
    .await?;

    Ok(())
}

#[tokio::test]
async fn test_arguments_with_gas_forwarded() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(
            Contract(
                name = "TestContract",
                project = "e2e/sway/contracts/contract_test"
            ),
            Contract(
                name = "VectorOutputContract",
                project = "e2e/sway/types/contracts/vectors"
            )
        ),
        Deploy(
            name = "contract_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
        Deploy(
            name = "contract_instance_2",
            contract = "VectorOutputContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    let x = 128;
    let vec_input = vec![0, 1, 2];
    {
        let response = contract_instance
            .methods()
            .get_single(x)
            .call_params(CallParameters::default().with_gas_forwarded(4096))?
            .call()
            .await?;

        assert_eq!(response.value, x);
    }
    {
        contract_instance_2
            .methods()
            .u32_vec(vec_input.clone())
            .call_params(CallParameters::default().with_gas_forwarded(4096))?
            .call()
            .await?;
    }
    {
        let call_handler_1 = contract_instance.methods().get_single(x);
        let call_handler_2 = contract_instance_2.methods().u32_vec(vec_input);

        let multi_call_handler = CallHandler::new_multi_call(wallet.clone())
            .add_call(call_handler_1)
            .add_call(call_handler_2);

        let (value, _): (u64, ()) = multi_call_handler.call().await?.value;

        assert_eq!(value, x);
    }

    Ok(())
}

#[tokio::test]
async fn contract_custom_call_no_signatures_strategy() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "TestContract",
            project = "e2e/sway/contracts/contract_test"
        )),
        Deploy(
            name = "contract_instance",
            contract = "TestContract",
            wallet = "wallet",
            random_salt = false,
        ),
    );
    let provider = wallet.try_provider()?;

    let counter = 42;
    let call_handler = contract_instance.methods().initialize_counter(counter);

    let mut tb = call_handler.transaction_builder().await?;

    let base_asset_id = *provider.consensus_parameters().await?.base_asset_id();

    let amount = 10;
    let consensus_parameters = provider.consensus_parameters().await?;
    let new_base_inputs = wallet
        .get_asset_inputs_for_amount(base_asset_id, amount, None)
        .await?;
    tb.inputs_mut().extend(new_base_inputs);
    tb.outputs_mut()
        .push(Output::change(wallet.address().into(), 0, base_asset_id));

    // ANCHOR: tb_no_signatures_strategy
    let mut tx = tb
        .with_build_strategy(ScriptBuildStrategy::NoSignatures)
        .build(provider)
        .await?;
    // ANCHOR: tx_sign_with
    tx.sign_with(&amp;wallet, consensus_parameters.chain_id())
        .await?;
    // ANCHOR_END: tx_sign_with
    // ANCHOR_END: tb_no_signatures_strategy

    let tx_id = provider.send_transaction(tx).await?;
    tokio::time::sleep(Duration::from_millis(500)).await;

    let tx_status = provider.tx_status(&amp;tx_id).await?;

    let response = call_handler.get_response_from(tx_status)?;

    assert_eq!(counter, response.value);

    Ok(())
}

#[tokio::test]
async fn contract_encoder_config_is_applied() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Abigen(Contract(
            name = "TestContract",
            project = "e2e/sway/contracts/contract_test"
        )),
        Wallets("wallet")
    );
    let contract_id = Contract::load_from(
        "sway/contracts/contract_test/out/release/contract_test.bin",
        LoadConfiguration::default(),
    )?
    .deploy_if_not_exists(&amp;wallet, TxPolicies::default())
    .await?;

    let instance = TestContract::new(contract_id.clone(), wallet.clone());

    {
        let _encoding_ok = instance
            .methods()
            .get(0, 1)
            .call()
            .await
            .expect("should not fail as it uses the default encoder config");
    }
    {
        let encoder_config = EncoderConfig {
            max_tokens: 1,
            ..Default::default()
        };
        let instance_with_encoder_config = instance.with_encoder_config(encoder_config);

        // uses 2 tokens when 1 is the limit
        let encoding_error = instance_with_encoder_config
            .methods()
            .get(0, 1)
            .call()
            .await
            .expect_err("should error");

        assert!(encoding_error.to_string().contains(
            "cannot encode contract call arguments: codec: token limit `1` reached while encoding."
        ));

        let encoding_error = instance_with_encoder_config
            .methods()
            .get(0, 1)
            .simulate(Execution::Realistic)
            .await
            .expect_err("should error");

        assert!(encoding_error.to_string().contains(
            "cannot encode contract call arguments: codec: token limit `1` reached while encoding."
        ));
    }

    Ok(())
}

#[tokio::test]
async fn test_reentrant_calls() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "LibContractCaller",
            project = "e2e/sway/contracts/lib_contract_caller"
        ),),
        Deploy(
            name = "contract_caller_instance",
            contract = "LibContractCaller",
            wallet = "wallet",
            random_salt = false,
        ),
    );

    let contract_id = contract_caller_instance.contract_id();
    let response = contract_caller_instance
        .methods()
        .re_entrant(contract_id, true)
        .call()
        .await?;

    assert_eq!(42, response.value);

    Ok(())
}

#[tokio::test]
async fn msg_sender_gas_estimation_issue() {
    // Gas estimation requires an input of the base asset. If absent, a fake input is
    // added. However, if a non-base coin is present and the fake input introduces a
    // second owner, it causes the `msg_sender` sway fn to fail. This leads
    // to a premature failure in gas estimation, risking transaction failure due to
    // a low gas limit.
    let mut wallet = WalletUnlocked::new_random(None);

    let (coins, ids) =
        setup_multiple_assets_coins(wallet.address(), 2, DEFAULT_NUM_COINS, DEFAULT_COIN_AMOUNT);

    let provider = setup_test_provider(coins, vec![], None, None)
        .await
        .unwrap();
    wallet.set_provider(provider.clone());

    setup_program_test!(
        Abigen(Contract(
            name = "MyContract",
            project = "e2e/sway/contracts/msg_methods"
        )),
        Deploy(
            contract = "MyContract",
            name = "contract_instance",
            wallet = "wallet",
            random_salt = false,
        )
    );

    let asset_id = ids[0];

    // The fake coin won't be added if we add a base asset, so let's not do that
    assert!(
        asset_id
            != *provider
                .consensus_parameters()
                .await
                .unwrap()
                .base_asset_id()
    );
    let call_params = CallParameters::default()
        .with_amount(100)
        .with_asset_id(asset_id);

    contract_instance
        .methods()
        .message_sender()
        .call_params(call_params)
        .unwrap()
        .call()
        .await
        .unwrap();
}

#[tokio::test]
async fn variable_output_estimation_is_optimized() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "MyContract",
            project = "e2e/sway/contracts/var_outputs"
        )),
        Deploy(
            contract = "MyContract",
            name = "contract_instance",
            wallet = "wallet",
            random_salt = false,
        )
    );

    let contract_methods = contract_instance.methods();

    let coins = 252;
    let recipient = Identity::Address(wallet.address().into());
    let start = Instant::now();
    let _ = contract_methods
        .mint(coins, recipient)
        .with_variable_output_policy(VariableOutputPolicy::EstimateMinimum)
        .call()
        .await?;

    // debug builds are slower (20x for `fuel-core-lib`, 4x for a release-fuel-core-binary)
    // we won't validate in that case so we don't have to maintain two expectations
    if !cfg!(debug_assertions) {
        let elapsed = start.elapsed().as_secs();
        let limit = 2;
        if elapsed &gt; limit {
            panic!("Estimation took too long ({elapsed}). Limit is {limit}");
        }
    }

    Ok(())
}

async fn setup_node_with_high_price() -&gt; Result&lt;Vec&lt;WalletUnlocked&gt;&gt; {
    let wallet_config = WalletsConfig::new(None, None, None);
    let fee_parameters = FeeParameters::V1(FeeParametersV1 {
        gas_price_factor: 92000,
        gas_per_byte: 63,
    });
    let consensus_parameters = ConsensusParameters::V1(ConsensusParametersV1 {
        fee_params: fee_parameters,
        ..Default::default()
    });
    let node_config = Some(NodeConfig {
        starting_gas_price: 1100,
        ..NodeConfig::default()
    });
    let chain_config = ChainConfig {
        consensus_parameters,
        ..ChainConfig::default()
    };
    let wallets =
        launch_custom_provider_and_get_wallets(wallet_config, node_config, Some(chain_config))
            .await?;

    Ok(wallets)
}

#[tokio::test]
async fn simulations_can_be_made_without_coins() -&gt; Result&lt;()&gt; {
    abigen!(Contract(
        name = "MyContract",
        abi = "e2e/sway/contracts/contract_test/out/release/contract_test-abi.json"
    ));

    let wallets = setup_node_with_high_price().await?;
    let wallet = wallets.first().expect("has wallet");

    let contract_id = Contract::load_from(
        "sway/contracts/contract_test/out/release/contract_test.bin",
        LoadConfiguration::default(),
    )?
    .deploy_if_not_exists(wallet, TxPolicies::default())
    .await?;

    let provider = wallet.provider().cloned();
    let no_funds_wallet = WalletUnlocked::new_random(provider);

    let response = MyContract::new(contract_id, no_funds_wallet.clone())
        .methods()
        .get(5, 6)
        .simulate(Execution::StateReadOnly)
        .await?;

    assert_eq!(response.value, 11);

    Ok(())
}

#[tokio::test]
async fn simulations_can_be_made_without_coins_multicall() -&gt; Result&lt;()&gt; {
    abigen!(Contract(
        name = "MyContract",
        abi = "e2e/sway/contracts/contract_test/out/release/contract_test-abi.json"
    ));

    let wallets = setup_node_with_high_price().await?;
    let wallet = wallets.first().expect("has wallet");

    let contract_id = Contract::load_from(
        "sway/contracts/contract_test/out/release/contract_test.bin",
        LoadConfiguration::default(),
    )?
    .deploy_if_not_exists(wallet, TxPolicies::default())
    .await?;

    let provider = wallet.provider().cloned();
    let no_funds_wallet = WalletUnlocked::new_random(provider);
    let contract_instance = MyContract::new(contract_id, no_funds_wallet.clone());

    let contract_methods = contract_instance.methods();

    let call_handler_1 = contract_methods.get(1, 2);
    let call_handler_2 = contract_methods.get(3, 4);

    let mut multi_call_handler = CallHandler::new_multi_call(no_funds_wallet)
        .add_call(call_handler_1)
        .add_call(call_handler_2);

    let value: (u64, u64) = multi_call_handler
        .simulate(Execution::StateReadOnly)
        .await?
        .value;

    assert_eq!(value, (3, 7));

    Ok(())
}

#[tokio::test]
async fn contract_call_with_non_zero_base_asset_id_and_tip() -&gt; Result&lt;()&gt; {
    use fuels::{prelude::*, tx::ConsensusParameters};

    abigen!(Contract(
        name = "MyContract",
        abi = "e2e/sway/contracts/contract_test/out/release/contract_test-abi.json"
    ));

    let asset_id = AssetId::new([1; 32]);

    let mut consensus_parameters = ConsensusParameters::default();
    consensus_parameters.set_base_asset_id(asset_id);

    let config = ChainConfig {
        consensus_parameters,
        ..Default::default()
    };

    let asset_base = AssetConfig {
        id: asset_id,
        num_coins: 1,
        coin_amount: 10_000,
    };

    let wallet_config = WalletsConfig::new_multiple_assets(1, vec![asset_base]);
    let wallets = launch_custom_provider_and_get_wallets(wallet_config, None, Some(config)).await?;
    let wallet = wallets.first().expect("has wallet");

    let contract_id = Contract::load_from(
        "sway/contracts/contract_test/out/release/contract_test.bin",
        LoadConfiguration::default(),
    )?
    .deploy_if_not_exists(wallet, TxPolicies::default())
    .await?;

    let contract_instance = MyContract::new(contract_id, wallet.clone());

    let response = contract_instance
        .methods()
        .initialize_counter(42)
        .with_tx_policies(TxPolicies::default().with_tip(10))
        .call()
        .await?;

    assert_eq!(42, response.value);

    Ok(())
}

#[tokio::test]
async fn max_fee_estimation_respects_tolerance() -&gt; Result&lt;()&gt; {
    use fuels::prelude::*;

    let mut call_wallet = WalletUnlocked::new_random(None);

    let call_coins = setup_single_asset_coins(call_wallet.address(), AssetId::BASE, 1000, 1);

    let mut deploy_wallet = WalletUnlocked::new_random(None);
    let deploy_coins =
        setup_single_asset_coins(deploy_wallet.address(), AssetId::BASE, 1, 1_000_000);

    let provider =
        setup_test_provider([call_coins, deploy_coins].concat(), vec![], None, None).await?;

    call_wallet.set_provider(provider.clone());
    deploy_wallet.set_provider(provider.clone());

    setup_program_test!(
        Abigen(Contract(
            name = "MyContract",
            project = "e2e/sway/contracts/contract_test"
        )),
        Deploy(
            name = "contract_instance",
            wallet = "deploy_wallet",
            contract = "MyContract",
            random_salt = false,
        )
    );
    let contract_instance = contract_instance.with_account(call_wallet.clone());

    let max_fee_from_tx = |tolerance: f32| {
        let contract_instance = contract_instance.clone();
        let provider = provider.clone();
        async move {
            let builder = contract_instance
                .methods()
                .initialize_counter(42)
                .transaction_builder()
                .await
                .unwrap();

            assert_eq!(
                builder.max_fee_estimation_tolerance, DEFAULT_MAX_FEE_ESTIMATION_TOLERANCE,
                "Expected pre-set tolerance"
            );

            builder
                .with_max_fee_estimation_tolerance(tolerance)
                .build(&amp;provider)
                .await
                .unwrap()
                .max_fee()
                .unwrap()
        }
    };

    let max_fee_from_builder = |tolerance: f32| {
        let contract_instance = contract_instance.clone();
        let provider = provider.clone();
        async move {
            contract_instance
                .methods()
                .initialize_counter(42)
                .transaction_builder()
                .await
                .unwrap()
                .with_max_fee_estimation_tolerance(tolerance)
                .estimate_max_fee(&amp;provider)
                .await
                .unwrap()
        }
    };

    let base_amount_in_inputs = |tolerance: f32| {
        let contract_instance = contract_instance.clone();
        let call_wallet = &amp;call_wallet;
        async move {
            let mut tb = contract_instance
                .methods()
                .initialize_counter(42)
                .transaction_builder()
                .await
                .unwrap()
                .with_max_fee_estimation_tolerance(tolerance);

            call_wallet.adjust_for_fee(&amp;mut tb, 0).await.unwrap();
            tb.inputs
                .iter()
                .filter_map(|input: &amp;Input| match input {
                    Input::ResourceSigned { resource }
                        if resource.coin_asset_id().unwrap() == AssetId::BASE =&gt;
                    {
                        Some(resource.amount())
                    }
                    _ =&gt; None,
                })
                .sum::&lt;u64&gt;()
        }
    };

    let no_increase_max_fee = max_fee_from_tx(0.0).await;
    let increased_max_fee = max_fee_from_tx(2.00).await;

    assert_eq!(
        increased_max_fee as f64 / no_increase_max_fee as f64,
        1.00 + 2.00
    );

    let no_increase_max_fee = max_fee_from_builder(0.0).await;
    let increased_max_fee = max_fee_from_builder(2.00).await;
    assert_eq!(
        increased_max_fee as f64 / no_increase_max_fee as f64,
        1.00 + 2.00
    );

    let normal_base_asset = base_amount_in_inputs(0.0).await;
    let more_base_asset_due_to_bigger_tolerance = base_amount_in_inputs(5.00).await;
    assert!(more_base_asset_due_to_bigger_tolerance &gt; normal_base_asset);

    Ok(())
}

#[tokio::test]
async fn blob_contract_deployment() -&gt; Result&lt;()&gt; {
    abigen!(Contract(
        name = "MyContract",
        abi = "e2e/sway/contracts/huge_contract/out/release/huge_contract-abi.json"
    ));

    let contract_binary = "sway/contracts/huge_contract/out/release/huge_contract.bin";
    let contract_size = std::fs::metadata(contract_binary)
        .expect("contract file not found")
        .len();

    assert!(
         contract_size &gt; 150_000,
         "the testnet size limit was around 100kB, we want a contract bigger than that to reflect prod (current: {contract_size}B)"
     );

    let wallets =
        launch_custom_provider_and_get_wallets(WalletsConfig::new(Some(2), None, None), None, None)
            .await?;

    let provider = wallets[0].provider().unwrap().clone();

    let consensus_parameters = provider.consensus_parameters().await?;

    let contract_max_size = consensus_parameters.contract_params().contract_max_size();
    assert!(
         contract_size &gt; contract_max_size,
         "this test should ideally be run with a contract bigger than the max contract size ({contract_max_size}B) so that we know deployment couldn't have happened without blobs"
     );

    let contract = Contract::load_from(contract_binary, LoadConfiguration::default())?;

    let contract_id = contract
        .convert_to_loader(100_000)?
        .deploy_if_not_exists(&amp;wallets[0], TxPolicies::default())
        .await?;

    let contract_instance = MyContract::new(contract_id, wallets[0].clone());

    let response = contract_instance.methods().something().call().await?.value;

    assert_eq!(response, 1001);

    Ok(())
}

#[tokio::test]
async fn regular_contract_can_be_deployed() -&gt; Result&lt;()&gt; {
    // given
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "MyContract",
            project = "e2e/sway/contracts/contract_test"
        )),
    );

    let contract_binary = "sway/contracts/contract_test/out/release/contract_test.bin";

    // when
    let contract_id = Contract::load_from(contract_binary, LoadConfiguration::default())?
        .deploy_if_not_exists(&amp;wallet, TxPolicies::default())
        .await?;

    // then
    let contract_instance = MyContract::new(contract_id, wallet);

    let response = contract_instance
        .methods()
        .get_counter()
        .call()
        .await?
        .value;

    assert_eq!(response, 0);

    Ok(())
}

#[tokio::test]
async fn unuploaded_loader_can_be_deployed_directly() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "MyContract",
            project = "e2e/sway/contracts/huge_contract"
        )),
    );

    let contract_binary = "sway/contracts/huge_contract/out/release/huge_contract.bin";

    let contract_id = Contract::load_from(contract_binary, LoadConfiguration::default())?
        .convert_to_loader(1024)?
        .deploy_if_not_exists(&amp;wallet, TxPolicies::default())
        .await?;

    let contract_instance = MyContract::new(contract_id, wallet);

    let response = contract_instance.methods().something().call().await?.value;

    assert_eq!(response, 1001);

    Ok(())
}

#[tokio::test]
async fn unuploaded_loader_can_upload_blobs_separately_then_deploy() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "MyContract",
            project = "e2e/sway/contracts/huge_contract"
        )),
    );

    let contract_binary = "sway/contracts/huge_contract/out/release/huge_contract.bin";

    let contract = Contract::load_from(contract_binary, LoadConfiguration::default())?
        .convert_to_loader(1024)?
        .upload_blobs(&amp;wallet, TxPolicies::default())
        .await?;

    let blob_ids = contract.blob_ids();

    // if this were an example for the user we'd just call `deploy` on the contract above
    // this way we are testing that the blobs were really deployed above, otherwise the following
    // would fail
    let contract_id = Contract::loader_from_blob_ids(
        blob_ids.to_vec(),
        contract.salt(),
        contract.storage_slots().to_vec(),
    )?
    .deploy_if_not_exists(&amp;wallet, TxPolicies::default())
    .await?;

    let contract_instance = MyContract::new(contract_id, wallet);
    let response = contract_instance.methods().something().call().await?.value;
    assert_eq!(response, 1001);

    Ok(())
}

#[tokio::test]
async fn loader_blob_already_uploaded_not_an_issue() -&gt; Result&lt;()&gt; {
    setup_program_test!(
        Wallets("wallet"),
        Abigen(Contract(
            name = "MyContract",
            project = "e2e/sway/contracts/huge_contract"
        )),
    );

    let contract_binary = "sway/contracts/huge_contract/out/release/huge_contract.bin";
    let contract = Contract::load_from(contract_binary, LoadConfiguration::default())?
        .convert_to_loader(1024)?;

    // this will upload blobs
    contract
        .clone()
        .upload_blobs(&amp;wallet, TxPolicies::default())
        .await?;

    // this will try to upload the blobs but skip upon encountering an error
    let contract_id = contract
        .deploy_if_not_exists(&amp;wallet, TxPolicies::default())
        .await?;

    let contract_instance = MyContract::new(contract_id, wallet);
    let response = contract_instance.methods().something().call().await?.value;
    assert_eq!(response, 1001);

    Ok(())
}

#[tokio::test]
async fn loader_works_via_proxy() -&gt; Result&lt;()&gt; {
    let wallet = launch_provider_and_get_wallet().await?;

    abigen!(
        Contract(
            name = "MyContract",
            abi = "e2e/sway/contracts/huge_contract/out/release/huge_contract-abi.json"
        ),
        Contract(
            name = "MyProxy",
            abi = "e2e/sway/contracts/proxy/out/release/proxy-abi.json"
        )
    );

    let contract_binary = "sway/contracts/huge_contract/out/release/huge_contract.bin";

    let contract = Contract::load_from(contract_binary, LoadConfiguration::default())?;

    let contract_id = contract
        .convert_to_loader(100)?
        .deploy_if_not_exists(&amp;wallet, TxPolicies::default())
        .await?;

    let contract_binary = "sway/contracts/proxy/out/release/proxy.bin";

    let proxy_id = Contract::load_from(contract_binary, LoadConfiguration::default())?
        .deploy_if_not_exists(&amp;wallet, TxPolicies::default())
        .await?;

    let proxy = MyProxy::new(proxy_id, wallet.clone());
    proxy
        .methods()
        .set_target_contract(contract_id.clone())
        .call()
        .await?;

    let response = proxy
        .methods()
        .something()
        .with_contract_ids(&amp;[contract_id])
        .call()
        .await?
        .value;

    assert_eq!(response, 1001);

    Ok(())
}

#[tokio::test]
async fn loader_storage_works_via_proxy() -&gt; Result&lt;()&gt; {
    let wallet = launch_provider_and_get_wallet().await?;

    abigen!(
        Contract(
            name = "MyContract",
            abi = "e2e/sway/contracts/huge_contract/out/release/huge_contract-abi.json"
        ),
        Contract(
            name = "MyProxy",
            abi = "e2e/sway/contracts/proxy/out/release/proxy-abi.json"
        )
    );

    let contract_binary = "sway/contracts/huge_contract/out/release/huge_contract.bin";

    let contract = Contract::load_from(contract_binary, LoadConfiguration::default())?;
    let contract_storage_slots = contract.storage_slots().to_vec();

    let contract_id = contract
        .convert_to_loader(100)?
        .deploy_if_not_exists(&amp;wallet, TxPolicies::default())
        .await?;

    let contract_binary = "sway/contracts/proxy/out/release/proxy.bin";
    let proxy_contract = Contract::load_from(contract_binary, LoadConfiguration::default())?;

    let combined_storage_slots = [&amp;contract_storage_slots, proxy_contract.storage_slots()].concat();

    let proxy_id = proxy_contract
        .with_storage_slots(combined_storage_slots)
        .deploy_if_not_exists(&amp;wallet, TxPolicies::default())
        .await?;

    let proxy = MyProxy::new(proxy_id, wallet.clone());
    proxy
        .methods()
        .set_target_contract(contract_id.clone())
        .call()
        .await?;

    let response = proxy
        .methods()
        .read_some_u64()
        .with_contract_ids(&amp;[contract_id.clone()])
        .call()
        .await?
        .value;

    assert_eq!(response, 42);

    let _res = proxy
        .methods()
        .write_some_u64(36)
        .with_contract_ids(&amp;[contract_id.clone()])
        .call()
        .await?;

    let response = proxy
        .methods()
        .read_some_u64()
        .with_contract_ids(&amp;[contract_id])
        .call()
        .await?
        .value;

    assert_eq!(response, 36);

    Ok(())
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../fuels-rs/wallets/test-wallets.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../fuels-rs/abigen/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../fuels-rs/wallets/test-wallets.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../fuels-rs/abigen/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
