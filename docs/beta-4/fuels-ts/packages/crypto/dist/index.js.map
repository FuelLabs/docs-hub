{"version":3,"sources":["../src/index.ts","../src/shared/scrypt.ts","../src/shared/keccak256.ts","../src/node/aes-ctr.ts","../src/node/bufferFromString.ts","../src/node/randomBytes.ts","../src/node/stringFromBuffer.ts","../src/node/encryptJsonWalletData.ts","../src/node/index.ts"],"sourcesContent":["import cryptoApi from './node';\n\nexport * from './types';\n\nexport const {\n  bufferFromString,\n  decrypt,\n  encrypt,\n  keyFromPassword,\n  randomBytes,\n  stringFromBuffer,\n  scrypt,\n  keccak256,\n  decryptJsonWalletData,\n  encryptJsonWalletData,\n} = cryptoApi;\n","import { scryptSync as ethCryScrypt } from 'ethereum-cryptography/scrypt';\n\nimport type { IScryptParams } from '../types';\n\nexport const scrypt = (params: IScryptParams): Uint8Array => {\n  const { password, salt, n, p, r, dklen } = params;\n\n  const derivedKey = ethCryScrypt(password, salt, n, r, p, dklen);\n\n  return derivedKey;\n};\n","import { keccak256 as keccak } from 'ethereum-cryptography/keccak';\n\nexport const keccak256 = (data: Uint8Array): Uint8Array => keccak(data);\n","import { FuelError, ErrorCode } from '@fuel-ts/errors';\nimport crypto from 'crypto';\nimport { getBytesCopy, pbkdf2 } from 'ethers';\n\nimport type { CryptoApi, Keystore } from '../types';\n\nimport { bufferFromString } from './bufferFromString';\nimport { randomBytes } from './randomBytes';\nimport { stringFromBuffer } from './stringFromBuffer';\n\nconst ALGORITHM = 'aes-256-ctr';\n\n/**\n * Generate a pbkdf2 key from a password and random salt\n */\nexport const keyFromPassword: CryptoApi['keyFromPassword'] = (\n  password: string,\n  saltBuffer: Uint8Array\n): Uint8Array => {\n  const passBuffer = bufferFromString(String(password).normalize('NFKC'), 'utf-8');\n  const key = pbkdf2(passBuffer, saltBuffer, 100000, 32, 'sha256');\n\n  return getBytesCopy(key);\n};\n\n/**\n * Encrypts a data object that can be any serializable value using\n * a provided password.\n *\n * @returns Promise<Keystore> object\n */\nexport const encrypt: CryptoApi['encrypt'] = async <T>(\n  password: string,\n  data: T\n): Promise<Keystore> => {\n  const iv = randomBytes(16);\n  const salt = randomBytes(32);\n  const secret = keyFromPassword(password, salt);\n  const dataBuffer = Uint8Array.from(Buffer.from(JSON.stringify(data), 'utf-8'));\n\n  const cipher = await crypto.createCipheriv(ALGORITHM, secret, iv);\n  let cipherData = cipher.update(dataBuffer);\n  cipherData = Buffer.concat([cipherData, cipher.final()]);\n\n  return {\n    data: stringFromBuffer(cipherData),\n    iv: stringFromBuffer(iv),\n    salt: stringFromBuffer(salt),\n  };\n};\n\n/**\n * Given a password and a keystore object, decrypts the text and returns\n * the resulting value\n */\nexport const decrypt: CryptoApi['decrypt'] = async <T>(\n  password: string,\n  keystore: Keystore\n): Promise<T> => {\n  const iv = bufferFromString(keystore.iv);\n  const salt = bufferFromString(keystore.salt);\n  const secret = keyFromPassword(password, salt);\n  const encryptedText = bufferFromString(keystore.data);\n\n  const decipher = await crypto.createDecipheriv(ALGORITHM, secret, iv);\n  const decrypted = decipher.update(encryptedText);\n  const deBuff = Buffer.concat([decrypted, decipher.final()]);\n  const decryptedData = Buffer.from(deBuff).toString('utf-8');\n\n  try {\n    return JSON.parse(decryptedData);\n  } catch {\n    throw new FuelError(ErrorCode.INVALID_CREDENTIALS, 'Invalid credentials.');\n  }\n};\n","import type { CryptoApi, Encoding } from '../types';\n\nexport const bufferFromString: CryptoApi['bufferFromString'] = (\n  string: string,\n  encoding: Encoding = 'base64'\n): Uint8Array => Uint8Array.from(Buffer.from(string, encoding));\n","import crypto from 'crypto';\n\nimport type { CryptoApi } from '../types';\n\nexport const randomBytes: CryptoApi['randomBytes'] = (length: number): Uint8Array => {\n  const randomValues = Uint8Array.from(crypto.randomBytes(length));\n  return randomValues;\n};\n","import type { CryptoApi, Encoding } from '../types';\n\nexport const stringFromBuffer: CryptoApi['stringFromBuffer'] = (\n  buffer: Uint8Array,\n  encoding: Encoding = 'base64'\n): string => Buffer.from(buffer).toString(encoding);\n","import crypto from 'crypto';\n\nexport async function encryptJsonWalletData(data: Uint8Array, key: Uint8Array, iv: Uint8Array) {\n  const cipher = await crypto.createCipheriv('aes-128-ctr', key.subarray(0, 16), iv);\n\n  const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);\n\n  return new Uint8Array(encrypted);\n}\n\nexport async function decryptJsonWalletData(data: Uint8Array, key: Uint8Array, iv: Uint8Array) {\n  const decipher = crypto.createDecipheriv('aes-128-ctr', key.subarray(0, 16), iv);\n\n  const decrypted = await Buffer.concat([decipher.update(data), decipher.final()]);\n\n  return new Uint8Array(decrypted);\n}\n","import { scrypt, keccak256 } from '../shared';\nimport type { CryptoApi } from '../types';\n\nimport { decrypt, encrypt, keyFromPassword } from './aes-ctr';\nimport { bufferFromString } from './bufferFromString';\nimport { decryptJsonWalletData, encryptJsonWalletData } from './encryptJsonWalletData';\nimport { randomBytes } from './randomBytes';\nimport { stringFromBuffer } from './stringFromBuffer';\n\nconst api: CryptoApi = {\n  bufferFromString,\n  stringFromBuffer,\n  decrypt,\n  encrypt,\n  keyFromPassword,\n  randomBytes,\n  scrypt,\n  keccak256,\n  decryptJsonWalletData,\n  encryptJsonWalletData,\n};\n\nexport default api;\n"],"mappings":"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","names":["bufferFromString","decrypt","decryptJsonWalletData","encrypt","encryptJsonWalletData","keccak256","keyFromPassword","randomBytes","scrypt","stringFromBuffer","ethCryScrypt","keccak","import_crypto","crypto","crypto","import_crypto","crypto","bufferFromString","decrypt","encrypt","keyFromPassword","randomBytes","stringFromBuffer","scrypt","keccak256","decryptJsonWalletData","encryptJsonWalletData"]}