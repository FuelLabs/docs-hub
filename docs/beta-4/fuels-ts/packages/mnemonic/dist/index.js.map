{"version":3,"sources":["../src/index.ts","../src/mnemonic.ts","../src/utils.ts"],"sourcesContent":["export { default as Mnemonic, MNEMONIC_SIZES } from './mnemonic';\nexport type { MnemonicPhrase } from './utils';\n","import { randomBytes } from '@fuel-ts/crypto';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { english } from '@fuel-ts/wordlists';\nimport type { BytesLike } from 'ethers';\nimport {\n  concat,\n  hexlify,\n  dataSlice,\n  pbkdf2,\n  sha256,\n  computeHmac,\n  encodeBase58,\n  getBytesCopy,\n} from 'ethers';\n\nimport type { MnemonicPhrase } from './utils';\nimport {\n  entropyToMnemonicIndices,\n  getWords,\n  getPhrase,\n  mnemonicWordsToEntropy,\n  toUtf8Bytes,\n} from './utils';\n\n//\n// Constants\n//\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes('Bitcoin seed');\n// 4 byte: version bytes (mainnet: 0x0488B21E public, 0x0488ADE4 private; testnet: 0x043587CF public, 0x04358394 private)\nconst MainnetPRV = '0x0488ade4';\nconst TestnetPRV = '0x04358394';\nexport const MNEMONIC_SIZES = [12, 15, 18, 21, 24];\n\nfunction assertWordList(wordlist: Array<string>) {\n  if (wordlist.length !== 2048) {\n    throw new FuelError(\n      ErrorCode.INVALID_WORD_LIST,\n      `Expected word list length of 2048, but got ${wordlist.length}.`\n    );\n  }\n}\n\nfunction assertEntropy(entropy: BytesLike) {\n  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {\n    throw new FuelError(\n      ErrorCode.INVALID_ENTROPY,\n      `Entropy should be between 16 and 32 bytes and a multiple of 4, but got ${entropy.length} bytes.`\n    );\n  }\n}\n\nfunction assertMnemonic(words: Array<string>) {\n  if (!MNEMONIC_SIZES.includes(words.length)) {\n    const errorMsg = `Invalid mnemonic size. Expected one of [${MNEMONIC_SIZES.join(\n      ', '\n    )}] words, but got ${words.length}.`;\n\n    throw new FuelError(ErrorCode.INVALID_MNEMONIC, errorMsg);\n  }\n}\n\nclass Mnemonic {\n  wordlist: Array<string>;\n\n  /**\n   *\n   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.\n   * @returns Mnemonic instance\n   */\n  constructor(wordlist: Array<string> = english) {\n    this.wordlist = wordlist;\n\n    assertWordList(this.wordlist);\n  }\n\n  /**\n   *\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @returns Entropy hash\n   */\n  mnemonicToEntropy(phrase: MnemonicPhrase) {\n    return Mnemonic.mnemonicToEntropy(phrase, this.wordlist);\n  }\n\n  /**\n   *\n   * @param entropy - Entropy source to the mnemonic phrase.\n   * @returns Mnemonic phrase\n   */\n  entropyToMnemonic(entropy: BytesLike) {\n    return Mnemonic.entropyToMnemonic(entropy, this.wordlist);\n  }\n\n  /**\n   *\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.\n   * @returns Mnemonic phrase\n   */\n  static mnemonicToEntropy(phrase: MnemonicPhrase, wordlist: Array<string> = english): string {\n    const words = getWords(phrase);\n\n    assertMnemonic(words);\n\n    return hexlify(mnemonicWordsToEntropy(words, wordlist));\n  }\n\n  /**\n   * @param entropy - Entropy source to the mnemonic phrase.\n   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static entropyToMnemonic(entropy: BytesLike, wordlist: Array<string> = english): string {\n    const entropyBytes = getBytesCopy(entropy);\n\n    assertWordList(wordlist);\n    assertEntropy(entropyBytes);\n\n    return entropyToMnemonicIndices(entropyBytes)\n      .map((i) => wordlist[i])\n      .join(' ');\n  }\n\n  /**\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static mnemonicToSeed(phrase: MnemonicPhrase, passphrase: BytesLike = '') {\n    assertMnemonic(getWords(phrase));\n\n    const phraseBytes = toUtf8Bytes(getPhrase(phrase));\n    const salt = toUtf8Bytes(`mnemonic${passphrase}`);\n\n    return pbkdf2(phraseBytes, salt, 2048, 64, 'sha512');\n  }\n\n  /**\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static mnemonicToMasterKeys(phrase: MnemonicPhrase, passphrase: BytesLike = '') {\n    const seed = Mnemonic.mnemonicToSeed(phrase, passphrase);\n    return Mnemonic.masterKeysFromSeed(seed);\n  }\n\n  /**\n   * Validates if given mnemonic is  valid\n   * @param phrase - Mnemonic phrase composed by words from the provided wordlist\n   * @returns true if phrase is a valid mnemonic\n   */\n  static isMnemonicValid(phrase: string) {\n    const words = getWords(phrase);\n\n    let i: number = 0;\n\n    try {\n      assertMnemonic(words);\n    } catch {\n      return false;\n    }\n\n    while (i < words.length) {\n      if (Mnemonic.binarySearch(words[i]) === false) {\n        return false;\n      }\n      i += 1;\n    }\n\n    return true;\n  }\n\n  static binarySearch(target: string): boolean {\n    const words = english;\n    let left: number = 0;\n    let right: number = words.length - 1;\n\n    while (left <= right) {\n      const mid: number = Math.floor((left + right) / 2);\n\n      if (words[mid] === target) {\n        return true;\n      }\n      if (target < words[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * @param seed - BIP39 seed\n   * @param testnet - Inform if should use testnet or mainnet prefix, the default value is true (`mainnet`).\n   * @returns 64-byte array contains privateKey and chainCode as described on BIP39\n   */\n  static masterKeysFromSeed(seed: string): Uint8Array {\n    const seedArray = getBytesCopy(seed);\n\n    if (seedArray.length < 16 || seedArray.length > 64) {\n      throw new FuelError(\n        ErrorCode.INVALID_SEED,\n        `Seed length should be between 16 and 64 bytes, but received ${seedArray.length} bytes.`\n      );\n    }\n\n    return getBytesCopy(computeHmac('sha512', MasterSecret, seedArray));\n  }\n\n  /**\n   * Get the extendKey as defined on BIP-32 from the provided seed\n   *\n   * @param seed - BIP39 seed\n   * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).\n   * @returns BIP-32 extended private key\n   */\n  static seedToExtendedKey(seed: string, testnet: boolean = false): string {\n    const masterKey = Mnemonic.masterKeysFromSeed(seed);\n    const prefix = getBytesCopy(testnet ? TestnetPRV : MainnetPRV);\n    const depth = '0x00';\n    const fingerprint = '0x00000000';\n    const index = '0x00000000';\n    // last 32 bites from the key\n    const chainCode = masterKey.slice(32);\n    // first 32 bites from the key\n    const privateKey = masterKey.slice(0, 32);\n    const extendedKey = concat([\n      prefix,\n      depth,\n      fingerprint,\n      index,\n      chainCode,\n      concat(['0x00', privateKey]),\n    ]);\n    const checksum = dataSlice(sha256(sha256(extendedKey)), 0, 4);\n\n    return encodeBase58(concat([extendedKey, checksum]));\n  }\n\n  /**\n   *  Create a new mnemonic using a randomly generated number as entropy.\n   *  As defined in BIP39, the entropy must be a multiple of 32 bits, and its size must be between 128 and 256 bits.\n   *  Therefore, the possible values for `strength` are 128, 160, 192, 224, and 256.\n   *  If not provided, the default entropy length will be set to 256 bits.\n   *  The return is a list of words that encodes the generated entropy.\n   *\n   *\n   * @param size - Number of bytes used as an entropy\n   * @param extraEntropy - Optional extra entropy to increase randomness\n   * @returns A randomly generated mnemonic\n   */\n  static generate(size: number = 32, extraEntropy: BytesLike = '') {\n    const entropy = extraEntropy\n      ? sha256(concat([randomBytes(size), getBytesCopy(extraEntropy)]))\n      : randomBytes(size);\n    return Mnemonic.entropyToMnemonic(entropy);\n  }\n}\n\nexport default Mnemonic;\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { getBytesCopy, sha256 } from 'ethers';\nimport type { BytesLike } from 'ethers';\n\n/* Mnemonic phrase composed by words from the provided wordlist it can be a text or a array of words */\nexport type MnemonicPhrase = string | Array<string>;\n\nexport function toUtf8Bytes(stri: string): Uint8Array {\n  const str = stri.normalize('NFKD');\n\n  const result = [];\n  for (let i = 0; i < str.length; i += 1) {\n    const c = str.charCodeAt(i);\n\n    if (c < 0x80) {\n      result.push(c);\n    } else if (c < 0x800) {\n      result.push((c >> 6) | 0xc0);\n      result.push((c & 0x3f) | 0x80);\n    } else if ((c & 0xfc00) === 0xd800) {\n      i += 1;\n      const c2 = str.charCodeAt(i);\n\n      if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n        throw new FuelError(\n          ErrorCode.INVALID_INPUT_PARAMETERS,\n          'Invalid UTF-8 in the input string.'\n        );\n      }\n\n      // Surrogate Pair\n      const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n      result.push((pair >> 18) | 0xf0);\n      result.push(((pair >> 12) & 0x3f) | 0x80);\n      result.push(((pair >> 6) & 0x3f) | 0x80);\n      result.push((pair & 0x3f) | 0x80);\n    } else {\n      result.push((c >> 12) | 0xe0);\n      result.push(((c >> 6) & 0x3f) | 0x80);\n      result.push((c & 0x3f) | 0x80);\n    }\n  }\n\n  return Uint8Array.from(result);\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n  return (1 << bits) - 1;\n}\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n  return ((1 << bits) - 1) << (8 - bits);\n}\n\nexport function getWords(mnemonic: MnemonicPhrase): Array<string> {\n  if (!Array.isArray(mnemonic)) {\n    return mnemonic.split(/\\s+/);\n  }\n  return mnemonic;\n}\n\nexport function getPhrase(mnemonic: MnemonicPhrase): string {\n  if (Array.isArray(mnemonic)) {\n    return mnemonic.join(' ');\n  }\n  return mnemonic;\n}\n\nexport function entropyToMnemonicIndices(entropy: Uint8Array): Array<number> {\n  const indices: Array<number> = [0];\n\n  let remainingBits = 11;\n  for (let i = 0; i < entropy.length; i += 1) {\n    if (remainingBits > 8) {\n      indices[indices.length - 1] <<= 8;\n      indices[indices.length - 1] |= entropy[i];\n\n      remainingBits -= 8;\n      // This byte will complete an 11-bit index\n    } else {\n      indices[indices.length - 1] <<= remainingBits;\n      indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n      // Start the next word\n      indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n      remainingBits += 3;\n    }\n  }\n\n  // Compute the checksum bits\n  const checksumBits = entropy.length / 4;\n  const checksum = getBytesCopy(sha256(entropy))[0] & getUpperMask(checksumBits);\n\n  // Shift the checksum into the word indices\n  indices[indices.length - 1] <<= checksumBits;\n  indices[indices.length - 1] |= checksum >> (8 - checksumBits);\n\n  return indices;\n}\n\nexport function mnemonicWordsToEntropy(words: Array<string>, wordlist: Array<string>): BytesLike {\n  const size = Math.ceil((11 * words.length) / 8);\n  const entropy = getBytesCopy(new Uint8Array(size));\n\n  let offset = 0;\n  for (let i = 0; i < words.length; i += 1) {\n    const index = wordlist.indexOf(words[i].normalize('NFKD'));\n    if (index === -1) {\n      throw new FuelError(\n        ErrorCode.INVALID_MNEMONIC,\n        `Invalid mnemonic: the word '${words[i]}' is not found in the provided wordlist.`\n      );\n    }\n\n    for (let bit = 0; bit < 11; bit += 1) {\n      if (index & (1 << (10 - bit))) {\n        entropy[offset >> 3] |= 1 << (7 - (offset % 8));\n      }\n      offset += 1;\n    }\n  }\n  const entropyBits = (32 * words.length) / 3;\n  const checksumBits = words.length / 3;\n  const checksumMask = getUpperMask(checksumBits);\n  const checksum = getBytesCopy(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n    throw new FuelError(\n      ErrorCode.INVALID_CHECKSUM,\n      'Checksum validation failed for the provided mnemonic.'\n    );\n  }\n\n  return entropy.slice(0, entropyBits / 8);\n}\n"],"mappings":"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","names":["import_errors","import_ethers"]}