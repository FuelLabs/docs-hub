{"version":3,"sources":["../src/coin-quantity.ts","../src/provider.ts","../src/__generated__/operations.ts","../src/memory-cache.ts","../src/transaction-request/input.ts","../src/transaction-request/output.ts","../src/transaction-request/transaction-request.ts","../src/resource.ts","../src/utils/receipts.ts","../src/utils/block-explorer.ts","../src/utils/gas.ts","../src/utils/json.ts","../src/utils/sleep.ts","../src/utils/time.ts","../src/transaction-request/errors.ts","../src/transaction-request/witness.ts","../src/transaction-request/create-transaction-request.ts","../src/transaction-request/hash-transaction.ts","../src/transaction-request/storage-slot.ts","../src/transaction-request/script-transaction-request.ts","../src/transaction-request/scripts.ts","../src/transaction-request/utils.ts","../src/transaction-response/transaction-response.ts","../src/transaction-summary/assemble-transaction-summary.ts","../src/transaction-summary/calculate-transaction-fee.ts","../src/transaction-summary/date.ts","../src/transaction-summary/operations.ts","../src/transaction-summary/call.ts","../src/transaction-summary/input.ts","../src/transaction-summary/output.ts","../src/transaction-summary/types.ts","../src/transaction-summary/receipt.ts","../src/transaction-summary/status.ts","../src/transaction-response/getDecodedLogs.ts","../src/utils/merge-quantities.ts","../src/transaction-summary/get-transaction-summary.ts"],"sourcesContent":["import { BaseAssetId } from '@fuel-ts/address/configs';\nimport type { BigNumberish, BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport { hexlify } from 'ethers';\nimport type { BytesLike } from 'ethers';\n\nexport type CoinQuantityLike =\n  | [amount: BigNumberish, assetId?: BytesLike, max?: BigNumberish]\n  | { amount: BigNumberish; assetId?: BytesLike; max?: BigNumberish };\nexport type CoinQuantity = { amount: BN; assetId: string; max?: BN };\n\n/** @hidden */\nexport const coinQuantityfy = (coinQuantityLike: CoinQuantityLike): CoinQuantity => {\n  let assetId;\n  let amount;\n  let max;\n  if (Array.isArray(coinQuantityLike)) {\n    amount = coinQuantityLike[0];\n    assetId = coinQuantityLike[1] ?? BaseAssetId;\n    max = coinQuantityLike[2] ?? undefined;\n  } else {\n    amount = coinQuantityLike.amount;\n    assetId = coinQuantityLike.assetId ?? BaseAssetId;\n    max = coinQuantityLike.max ?? undefined;\n  }\n\n  return {\n    assetId: hexlify(assetId),\n    amount: bn(amount),\n    max: max ? bn(max) : undefined,\n  };\n};\n\nexport interface IAddAmountToAssetParams {\n  assetId: string;\n  amount: BN;\n  coinQuantities: CoinQuantity[];\n}\n\nexport const addAmountToAsset = (params: IAddAmountToAssetParams): CoinQuantity[] => {\n  const { amount, assetId } = params;\n\n  const coinQuantities = [...params.coinQuantities];\n\n  const assetIdx = coinQuantities.findIndex((coinQuantity) => coinQuantity.assetId === assetId);\n\n  if (assetIdx !== -1) {\n    coinQuantities[assetIdx].amount = coinQuantities[assetIdx].amount.add(amount);\n  } else {\n    coinQuantities.push({ assetId, amount });\n  }\n\n  return coinQuantities;\n};\n","import { Address } from '@fuel-ts/address';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { AbstractAddress } from '@fuel-ts/interfaces';\nimport type { BN } from '@fuel-ts/math';\nimport { bn, max } from '@fuel-ts/math';\nimport type { Transaction } from '@fuel-ts/transactions';\nimport {\n  InputType,\n  TransactionType,\n  InputMessageCoder,\n  TransactionCoder,\n} from '@fuel-ts/transactions';\nimport { checkFuelCoreVersionCompatibility } from '@fuel-ts/versions';\nimport type { BytesLike } from 'ethers';\nimport { getBytesCopy, hexlify, Network } from 'ethers';\nimport { GraphQLClient } from 'graphql-request';\nimport { clone } from 'ramda';\n\nimport { getSdk as getOperationsSdk } from './__generated__/operations';\nimport type {\n  GqlChainInfoFragmentFragment,\n  GqlGasCosts,\n  GqlGetBlocksQueryVariables,\n  GqlPeerInfo,\n} from './__generated__/operations';\nimport type { Coin } from './coin';\nimport type { CoinQuantity, CoinQuantityLike } from './coin-quantity';\nimport { coinQuantityfy } from './coin-quantity';\nimport { MemoryCache } from './memory-cache';\nimport type { Message, MessageCoin, MessageProof, MessageStatus } from './message';\nimport type { ExcludeResourcesOption, Resource } from './resource';\nimport type {\n  TransactionRequestLike,\n  TransactionRequest,\n  TransactionRequestInput,\n  CoinTransactionRequestInput,\n} from './transaction-request';\nimport { transactionRequestify, ScriptTransactionRequest } from './transaction-request';\nimport type { TransactionResultReceipt } from './transaction-response';\nimport { TransactionResponse } from './transaction-response';\nimport { processGqlReceipt } from './transaction-summary/receipt';\nimport {\n  calculatePriceWithFactor,\n  fromUnixToTai64,\n  getGasUsedFromReceipts,\n  getReceiptsWithMissingData,\n} from './utils';\nimport { mergeQuantities } from './utils/merge-quantities';\n\nconst MAX_RETRIES = 10;\n\nexport type CallResult = {\n  receipts: TransactionResultReceipt[];\n};\n\n/**\n * A Fuel block\n */\nexport type Block = {\n  id: string;\n  height: BN;\n  time: string;\n  transactionIds: string[];\n};\n\n/**\n * Deployed Contract bytecode and contract id\n */\nexport type ContractResult = {\n  id: string;\n  bytecode: string;\n};\n\ntype ConsensusParameters = {\n  contractMaxSize: BN;\n  maxInputs: BN;\n  maxOutputs: BN;\n  maxWitnesses: BN;\n  maxGasPerTx: BN;\n  maxScriptLength: BN;\n  maxScriptDataLength: BN;\n  maxStorageSlots: BN;\n  maxPredicateLength: BN;\n  maxPredicateDataLength: BN;\n  maxGasPerPredicate: BN;\n  gasPriceFactor: BN;\n  gasPerByte: BN;\n  maxMessageDataLength: BN;\n  chainId: BN;\n  gasCosts: GqlGasCosts;\n};\n\n/**\n * Chain information\n */\nexport type ChainInfo = {\n  name: string;\n  baseChainHeight: BN;\n  consensusParameters: ConsensusParameters;\n  gasCosts: GqlGasCosts;\n  latestBlock: {\n    id: string;\n    height: BN;\n    time: string;\n    transactions: Array<{ id: string }>;\n  };\n};\n\n/**\n * Node information\n */\nexport type NodeInfo = {\n  utxoValidation: boolean;\n  vmBacktrace: boolean;\n  minGasPrice: BN;\n  maxTx: BN;\n  maxDepth: BN;\n  nodeVersion: string;\n  peers: GqlPeerInfo[];\n};\n\nexport type NodeInfoAndConsensusParameters = {\n  minGasPrice: BN;\n  nodeVersion: string;\n  gasPerByte: BN;\n  gasPriceFactor: BN;\n  maxGasPerTx: BN;\n};\n\n// #region cost-estimation-1\nexport type TransactionCost = {\n  requiredQuantities: CoinQuantity[];\n  receipts: TransactionResultReceipt[];\n  minGasPrice: BN;\n  gasPrice: BN;\n  minGas: BN;\n  maxGas: BN;\n  gasUsed: BN;\n  minFee: BN;\n  maxFee: BN;\n  usedFee: BN;\n};\n// #endregion cost-estimation-1\n\nconst processGqlChain = (chain: GqlChainInfoFragmentFragment): ChainInfo => {\n  const { name, daHeight, consensusParameters, latestBlock } = chain;\n\n  const { contractParams, feeParams, predicateParams, scriptParams, txParams, gasCosts } =\n    consensusParameters;\n\n  return {\n    name,\n    baseChainHeight: bn(daHeight),\n    consensusParameters: {\n      contractMaxSize: bn(contractParams.contractMaxSize),\n      maxInputs: bn(txParams.maxInputs),\n      maxOutputs: bn(txParams.maxOutputs),\n      maxWitnesses: bn(txParams.maxWitnesses),\n      maxGasPerTx: bn(txParams.maxGasPerTx),\n      maxScriptLength: bn(scriptParams.maxScriptLength),\n      maxScriptDataLength: bn(scriptParams.maxScriptDataLength),\n      maxStorageSlots: bn(contractParams.maxStorageSlots),\n      maxPredicateLength: bn(predicateParams.maxPredicateLength),\n      maxPredicateDataLength: bn(predicateParams.maxPredicateDataLength),\n      maxGasPerPredicate: bn(predicateParams.maxGasPerPredicate),\n      gasPriceFactor: bn(feeParams.gasPriceFactor),\n      gasPerByte: bn(feeParams.gasPerByte),\n      maxMessageDataLength: bn(predicateParams.maxMessageDataLength),\n      chainId: bn(consensusParameters.chainId),\n      gasCosts,\n    },\n    gasCosts,\n    latestBlock: {\n      id: latestBlock.id,\n      height: bn(latestBlock.header.height),\n      time: latestBlock.header.time,\n      transactions: latestBlock.transactions.map((i) => ({\n        id: i.id,\n      })),\n    },\n  };\n};\n\n/**\n * @hidden\n *\n * Cursor pagination arguments\n *\n * https://relay.dev/graphql/connections.htm#sec-Arguments\n */\nexport type CursorPaginationArgs = {\n  /** Forward pagination limit */\n  first?: number | null;\n  /** Forward pagination cursor */\n  after?: string | null;\n  /** Backward pagination limit  */\n  last?: number | null;\n  /** Backward pagination cursor */\n  before?: string | null;\n};\n\nexport type FetchRequestOptions = {\n  method: 'POST';\n  headers: { [key: string]: string };\n  body: string;\n};\n\n/*\n * Provider initialization options\n */\nexport type ProviderOptions = {\n  fetch?: (url: string, options: FetchRequestOptions) => Promise<unknown>;\n  cacheUtxo?: number;\n};\n\n/**\n * UTXO Validation Param\n */\nexport type UTXOValidationParams = {\n  utxoValidation?: boolean;\n};\n\n/**\n * Transaction estimation Param\n */\nexport type EstimateTransactionParams = {\n  estimateTxDependencies?: boolean;\n};\n\nexport type EstimatePredicateParams = {\n  estimatePredicates?: boolean;\n};\n\nexport type TransactionCostParams = EstimateTransactionParams & EstimatePredicateParams;\n\n/**\n * Provider Call transaction params\n */\nexport type ProviderCallParams = UTXOValidationParams & EstimateTransactionParams;\n\n/**\n * Provider Send transaction params\n */\nexport type ProviderSendTxParams = EstimateTransactionParams;\n\n/**\n * URL - Consensus Params mapping.\n */\ntype ChainInfoCache = Record<string, ChainInfo>;\n\n/**\n * URL - Node Info mapping.\n */\ntype NodeInfoCache = Record<string, NodeInfo>;\n\n/**\n * A provider for connecting to a node\n */\nexport default class Provider {\n  operations: ReturnType<typeof getOperationsSdk>;\n  cache?: MemoryCache;\n\n  static clearChainAndNodeCaches() {\n    Provider.nodeInfoCache = {};\n    Provider.chainInfoCache = {};\n  }\n\n  private static chainInfoCache: ChainInfoCache = {};\n  private static nodeInfoCache: NodeInfoCache = {};\n\n  /**\n   * Constructor to initialize a Provider.\n   *\n   * @param url - GraphQL endpoint of the Fuel node\n   * @param chainInfo - Chain info of the Fuel node\n   * @param options - Additional options for the provider\n   * @hidden\n   */\n  protected constructor(\n    /** GraphQL endpoint of the Fuel node */\n    public url: string,\n    public options: ProviderOptions = {}\n  ) {\n    this.operations = this.createOperations(url, options);\n    this.cache = options.cacheUtxo ? new MemoryCache(options.cacheUtxo) : undefined;\n  }\n\n  /**\n   * Creates a new instance of the Provider class. This is the recommended way to initialize a Provider.\n   * @param url - GraphQL endpoint of the Fuel node\n   * @param options - Additional options for the provider\n   */\n  static async create(url: string, options: ProviderOptions = {}) {\n    const provider = new Provider(url, options);\n    await provider.fetchChainAndNodeInfo();\n    return provider;\n  }\n\n  /**\n   * Returns the cached chainInfo for the current URL.\n   */\n  getChain() {\n    const chain = Provider.chainInfoCache[this.url];\n    if (!chain) {\n      throw new FuelError(\n        ErrorCode.CHAIN_INFO_CACHE_EMPTY,\n        'Chain info cache is empty. Make sure you have called `Provider.create` to initialize the provider.'\n      );\n    }\n    return chain;\n  }\n\n  /**\n   * Returns the cached nodeInfo for the current URL.\n   */\n  getNode() {\n    const node = Provider.nodeInfoCache[this.url];\n    if (!node) {\n      throw new FuelError(\n        ErrorCode.NODE_INFO_CACHE_EMPTY,\n        'Node info cache is empty. Make sure you have called `Provider.create` to initialize the provider.'\n      );\n    }\n    return node;\n  }\n\n  /**\n   * Returns some helpful parameters related to gas fees.\n   */\n  getGasConfig() {\n    const { minGasPrice } = this.getNode();\n    const { maxGasPerTx, maxGasPerPredicate, gasPriceFactor, gasPerByte, gasCosts } =\n      this.getChain().consensusParameters;\n    return {\n      minGasPrice,\n      maxGasPerTx,\n      maxGasPerPredicate,\n      gasPriceFactor,\n      gasPerByte,\n      gasCosts,\n    };\n  }\n\n  /**\n   * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.\n   */\n  async connect(url: string, options?: ProviderOptions) {\n    this.url = url;\n    this.operations = this.createOperations(url, options ?? this.options);\n    await this.fetchChainAndNodeInfo();\n  }\n\n  /**\n   * Fetches both the chain and node information, saves it to the cache, and return it.\n   *\n   * @returns NodeInfo and Chain\n   */\n  async fetchChainAndNodeInfo() {\n    const chain = await this.fetchChain();\n    const nodeInfo = await this.fetchNode();\n\n    Provider.ensureClientVersionIsSupported(nodeInfo);\n\n    return {\n      chain,\n      nodeInfo,\n    };\n  }\n\n  private static ensureClientVersionIsSupported(nodeInfo: NodeInfo) {\n    const { isMajorSupported, isMinorSupported, supportedVersion } =\n      checkFuelCoreVersionCompatibility(nodeInfo.nodeVersion);\n\n    if (!isMajorSupported || !isMinorSupported) {\n      throw new FuelError(\n        FuelError.CODES.UNSUPPORTED_FUEL_CLIENT_VERSION,\n        `Fuel client version: ${nodeInfo.nodeVersion}, Supported version: ${supportedVersion}`\n      );\n    }\n  }\n\n  /**\n   * Create GraphQL client and set operations.\n   *\n   * @param url - The URL of the Fuel node\n   * @param options - Additional options for the provider\n   * @returns The operation SDK object\n   */\n  private createOperations(url: string, options: ProviderOptions = {}) {\n    this.url = url;\n    const gqlClient = new GraphQLClient(url, options.fetch ? { fetch: options.fetch } : undefined);\n    return getOperationsSdk(gqlClient);\n  }\n\n  /**\n   * Returns the version of the connected node.\n   *\n   * @returns A promise that resolves to the version string.\n   */\n  async getVersion(): Promise<string> {\n    const {\n      nodeInfo: { nodeVersion },\n    } = await this.operations.getVersion();\n    return nodeVersion;\n  }\n\n  /**\n   * @hidden\n   *\n   * Returns the network configuration of the connected Fuel node.\n   *\n   * @returns A promise that resolves to the network configuration object\n   */\n  async getNetwork(): Promise<Network> {\n    const {\n      name,\n      consensusParameters: { chainId },\n    } = await this.getChain();\n    const network = new Network(name, chainId.toNumber());\n    return Promise.resolve(network);\n  }\n\n  /**\n   * Returns the block number.\n   *\n   * @returns A promise that resolves to the block number\n   */\n  async getBlockNumber(): Promise<BN> {\n    const { chain } = await this.operations.getChain();\n    return bn(chain.latestBlock.header.height, 10);\n  }\n\n  /**\n   * Returns the chain information.\n   * @param url - The URL of the Fuel node\n   * @returns NodeInfo object\n   */\n  async fetchNode(): Promise<NodeInfo> {\n    const { nodeInfo } = await this.operations.getNodeInfo();\n\n    const processedNodeInfo: NodeInfo = {\n      maxDepth: bn(nodeInfo.maxDepth),\n      maxTx: bn(nodeInfo.maxTx),\n      minGasPrice: bn(nodeInfo.minGasPrice),\n      nodeVersion: nodeInfo.nodeVersion,\n      utxoValidation: nodeInfo.utxoValidation,\n      vmBacktrace: nodeInfo.vmBacktrace,\n      peers: nodeInfo.peers,\n    };\n\n    Provider.nodeInfoCache[this.url] = processedNodeInfo;\n\n    return processedNodeInfo;\n  }\n\n  /**\n   * Fetches the `chainInfo` for the given node URL.\n   * @param url - The URL of the Fuel node\n   * @returns ChainInfo object\n   */\n  async fetchChain(): Promise<ChainInfo> {\n    const { chain } = await this.operations.getChain();\n\n    const processedChain = processGqlChain(chain);\n\n    Provider.chainInfoCache[this.url] = processedChain;\n\n    return processedChain;\n  }\n\n  /**\n   * Returns the chain ID\n   * @returns A promise that resolves to the chain ID number\n   */\n  getChainId() {\n    const {\n      consensusParameters: { chainId },\n    } = this.getChain();\n    return chainId.toNumber();\n  }\n\n  /**\n   * @hidden\n   */\n  #cacheInputs(inputs: TransactionRequestInput[]): void {\n    if (!this.cache) {\n      return;\n    }\n\n    inputs.forEach((input) => {\n      if (input.type === InputType.Coin) {\n        this.cache?.set(input.id);\n      }\n    });\n  }\n\n  /**\n   * Submits a transaction to the chain to be executed.\n   *\n   * If the transaction is missing any dependencies,\n   * the transaction will be mutated and those dependencies will be added.\n   *\n   * @param transactionRequestLike - The transaction request object.\n   * @returns A promise that resolves to the transaction response object.\n   */\n  // #region Provider-sendTransaction\n  async sendTransaction(\n    transactionRequestLike: TransactionRequestLike,\n    { estimateTxDependencies = true }: ProviderSendTxParams = {}\n  ): Promise<TransactionResponse> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    this.#cacheInputs(transactionRequest.inputs);\n    if (estimateTxDependencies) {\n      await this.estimateTxDependencies(transactionRequest);\n    }\n    // #endregion Provider-sendTransaction\n\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const { gasUsed, minGasPrice } = await this.getTransactionCost(transactionRequest, [], {\n      estimateTxDependencies: false,\n      estimatePredicates: false,\n    });\n\n    if (bn(minGasPrice).gt(bn(transactionRequest.gasPrice))) {\n      throw new FuelError(\n        ErrorCode.GAS_PRICE_TOO_LOW,\n        `Gas price '${transactionRequest.gasPrice}' is lower than the required: '${minGasPrice}'.`\n      );\n    }\n\n    const isScriptTransaction = transactionRequest.type === TransactionType.Script;\n\n    if (isScriptTransaction && bn(gasUsed).gt(bn(transactionRequest.gasLimit))) {\n      throw new FuelError(\n        ErrorCode.GAS_LIMIT_TOO_LOW,\n        `Gas limit '${transactionRequest.gasLimit}' is lower than the required: '${gasUsed}'.`\n      );\n    }\n\n    const {\n      submit: { id: transactionId },\n    } = await this.operations.submit({ encodedTransaction });\n\n    const response = new TransactionResponse(transactionId, this);\n    return response;\n  }\n\n  /**\n   * Executes a transaction without actually submitting it to the chain.\n   *\n   * If the transaction is missing any dependencies,\n   * the transaction will be mutated and those dependencies will be added.\n   *\n   * @param transactionRequestLike - The transaction request object.\n   * @param utxoValidation - Additional provider call parameters.\n   * @returns A promise that resolves to the call result object.\n   */\n  async call(\n    transactionRequestLike: TransactionRequestLike,\n    { utxoValidation, estimateTxDependencies = true }: ProviderCallParams = {}\n  ): Promise<CallResult> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    if (estimateTxDependencies) {\n      await this.estimateTxDependencies(transactionRequest);\n    }\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const { dryRun: gqlReceipts } = await this.operations.dryRun({\n      encodedTransaction,\n      utxoValidation: utxoValidation || false,\n    });\n    const receipts = gqlReceipts.map(processGqlReceipt);\n    return {\n      receipts,\n    };\n  }\n\n  /**\n   * Verifies whether enough gas is available to complete transaction.\n   *\n   * @param transactionRequest - The transaction request object.\n   * @returns A promise that resolves to the estimated transaction request object.\n   */\n  async estimatePredicates(transactionRequest: TransactionRequest): Promise<TransactionRequest> {\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const response = await this.operations.estimatePredicates({\n      encodedTransaction,\n    });\n\n    const estimatedTransaction = transactionRequest;\n    const [decodedTransaction] = new TransactionCoder().decode(\n      getBytesCopy(response.estimatePredicates.rawPayload),\n      0\n    );\n\n    if (decodedTransaction.inputs) {\n      decodedTransaction.inputs.forEach((input, index) => {\n        if ('predicate' in input && input.predicateGasUsed.gt(0)) {\n          (<CoinTransactionRequestInput>estimatedTransaction.inputs[index]).predicateGasUsed =\n            input.predicateGasUsed;\n        }\n      });\n    }\n\n    return estimatedTransaction;\n  }\n\n  /**\n   * Will dryRun a transaction and check for missing dependencies.\n   *\n   * If there are missing variable outputs,\n   * `addVariableOutputs` is called on the transaction.\n   *\n   * @privateRemarks\n   * TODO: Investigate support for missing contract IDs\n   * TODO: Add support for missing output messages\n   *\n   * @param transactionRequest - The transaction request object.\n   * @returns A promise.\n   */\n  async estimateTxDependencies(transactionRequest: TransactionRequest): Promise<void> {\n    let missingOutputVariableCount = 0;\n    let missingOutputContractIdsCount = 0;\n    let tries = 0;\n\n    if (transactionRequest.type === TransactionType.Create) {\n      return;\n    }\n\n    let txRequest = transactionRequest;\n\n    if (txRequest.hasPredicateInput()) {\n      txRequest = (await this.estimatePredicates(txRequest)) as ScriptTransactionRequest;\n    }\n\n    do {\n      const { dryRun: gqlReceipts } = await this.operations.dryRun({\n        encodedTransaction: hexlify(txRequest.toTransactionBytes()),\n        utxoValidation: false,\n      });\n      const receipts = gqlReceipts.map(processGqlReceipt);\n      const { missingOutputVariables, missingOutputContractIds } =\n        getReceiptsWithMissingData(receipts);\n\n      missingOutputVariableCount = missingOutputVariables.length;\n      missingOutputContractIdsCount = missingOutputContractIds.length;\n\n      if (missingOutputVariableCount === 0 && missingOutputContractIdsCount === 0) {\n        return;\n      }\n\n      if (txRequest instanceof ScriptTransactionRequest) {\n        txRequest.addVariableOutputs(missingOutputVariableCount);\n\n        missingOutputContractIds.forEach(({ contractId }) =>\n          txRequest.addContractInputAndOutput(Address.fromString(contractId))\n        );\n      }\n\n      tries += 1;\n    } while (tries < MAX_RETRIES);\n  }\n\n  /**\n   * Executes a signed transaction without applying the states changes\n   * on the chain.\n   *\n   * If the transaction is missing any dependencies,\n   * the transaction will be mutated and those dependencies will be added\n   *\n   * @param transactionRequestLike - The transaction request object.\n   * @returns A promise that resolves to the call result object.\n   */\n  async simulate(\n    transactionRequestLike: TransactionRequestLike,\n    { estimateTxDependencies = true }: EstimateTransactionParams = {}\n  ): Promise<CallResult> {\n    const transactionRequest = transactionRequestify(transactionRequestLike);\n    if (estimateTxDependencies) {\n      await this.estimateTxDependencies(transactionRequest);\n    }\n    const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());\n    const { dryRun: gqlReceipts } = await this.operations.dryRun({\n      encodedTransaction,\n      utxoValidation: true,\n    });\n    const receipts = gqlReceipts.map(processGqlReceipt);\n    return {\n      receipts,\n    };\n  }\n\n  /**\n   * Returns a transaction cost to enable user\n   * to set gasLimit and also reserve balance amounts\n   * on the the transaction.\n   *\n   * @privateRemarks\n   * The tolerance is add on top of the gasUsed calculated\n   * from the node, this create a safe margin costs like\n   * change states on transfer that don't occur on the dryRun\n   * transaction. The default value is 0.2 or 20%\n   *\n   * @param transactionRequestLike - The transaction request object.\n   * @param tolerance - The tolerance to add on top of the gasUsed.\n   * @returns A promise that resolves to the transaction cost object.\n   */\n  async getTransactionCost(\n    transactionRequestLike: TransactionRequestLike,\n    forwardingQuantities: CoinQuantity[] = [],\n    { estimateTxDependencies = true, estimatePredicates = true }: TransactionCostParams = {}\n  ): Promise<TransactionCost> {\n    const transactionRequest = transactionRequestify(clone(transactionRequestLike));\n    const chainInfo = this.getChain();\n    const { gasPriceFactor, minGasPrice, maxGasPerTx } = this.getGasConfig();\n    const gasPrice = max(transactionRequest.gasPrice, minGasPrice);\n    const isScriptTransaction = transactionRequest.type === TransactionType.Script;\n\n    /**\n     * Estimate predicates gasUsed\n     */\n    if (transactionRequest.hasPredicateInput() && estimatePredicates) {\n      // Remove gasLimit to avoid gasLimit when estimating predicates\n      if (isScriptTransaction) {\n        transactionRequest.gasLimit = bn(0);\n      }\n      await this.estimatePredicates(transactionRequest);\n    }\n\n    /**\n     * Calculate minGas and maxGas based on the real transaction\n     */\n    const minGas = transactionRequest.calculateMinGas(chainInfo);\n    const maxGas = transactionRequest.calculateMaxGas(chainInfo, minGas);\n\n    /**\n     * Fund with fake UTXOs to avoid not enough funds error\n     */\n    // Getting coin quantities from amounts being transferred\n    const coinOutputsQuantities = transactionRequest.getCoinOutputsQuantities();\n    // Combining coin quantities from amounts being transferred and forwarding to contracts\n    const allQuantities = mergeQuantities(coinOutputsQuantities, forwardingQuantities);\n    // Funding transaction with fake utxos\n    transactionRequest.fundWithFakeUtxos(allQuantities);\n\n    /**\n     * Estimate gasUsed for script transactions\n     */\n\n    let gasUsed = minGas;\n    let receipts: TransactionResultReceipt[] = [];\n    // Transactions of type Create does not consume any gas so we can the dryRun\n    if (isScriptTransaction) {\n      /**\n       * Setting the gasPrice to 0 on a dryRun will result in no fees being charged.\n       * This simplifies the funding with fake utxos, since the coin quantities required\n       * will only be amounts being transferred (coin outputs) and amounts being forwarded\n       * to contract calls.\n       */\n      // Calculate the gasLimit again as we insert a fake UTXO and signer\n\n      transactionRequest.gasPrice = bn(0);\n      transactionRequest.gasLimit = bn(maxGasPerTx.sub(maxGas).toNumber() * 0.9);\n      // Executing dryRun with fake utxos to get gasUsed\n      const result = await this.call(transactionRequest, {\n        estimateTxDependencies,\n      });\n      receipts = result.receipts;\n      gasUsed = getGasUsedFromReceipts(receipts);\n    } else {\n      // For CreateTransaction the gasUsed is going to be the minGas\n      gasUsed = minGas;\n    }\n\n    const usedFee = calculatePriceWithFactor(\n      gasUsed,\n      gasPrice,\n      gasPriceFactor\n    ).normalizeZeroToOne();\n    const minFee = calculatePriceWithFactor(minGas, gasPrice, gasPriceFactor).normalizeZeroToOne();\n    const maxFee = calculatePriceWithFactor(maxGas, gasPrice, gasPriceFactor).normalizeZeroToOne();\n\n    return {\n      requiredQuantities: allQuantities,\n      receipts,\n      gasUsed,\n      minGasPrice,\n      gasPrice,\n      minGas,\n      maxGas,\n      usedFee,\n      minFee,\n      maxFee,\n    };\n  }\n\n  async getResourcesForTransaction(\n    owner: AbstractAddress,\n    transactionRequestLike: TransactionRequestLike,\n    forwardingQuantities: CoinQuantity[] = []\n  ) {\n    const transactionRequest = transactionRequestify(clone(transactionRequestLike));\n    const transactionCost = await this.getTransactionCost(transactionRequest, forwardingQuantities);\n\n    // Add the required resources to the transaction from the owner\n    transactionRequest.addResources(\n      await this.getResourcesToSpend(owner, transactionCost.requiredQuantities)\n    );\n    // Refetch transaction costs with the new resources\n    // TODO: we could find a way to avoid fetch estimatePredicates again, by returning the transaction or\n    // returning a specific gasUsed by the predicate.\n    // Also for the dryRun we could have the same issue as we are going to run twice the dryRun and the\n    // estimateTxDependencies as we don't have access to the transaction, maybe returning the transaction would\n    // be better.\n    const { requiredQuantities, ...txCost } = await this.getTransactionCost(\n      transactionRequest,\n      forwardingQuantities\n    );\n    const resources = await this.getResourcesToSpend(owner, requiredQuantities);\n\n    return {\n      resources,\n      requiredQuantities,\n      ...txCost,\n    };\n  }\n\n  /**\n   * Returns coins for the given owner.\n   */\n  async getCoins(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** The asset ID of coins to get */\n    assetId?: BytesLike,\n    /** Pagination arguments */\n    paginationArgs?: CursorPaginationArgs\n  ): Promise<Coin[]> {\n    const result = await this.operations.getCoins({\n      first: 10,\n      ...paginationArgs,\n      filter: { owner: owner.toB256(), assetId: assetId && hexlify(assetId) },\n    });\n\n    const coins = result.coins.edges.map((edge) => edge.node);\n\n    return coins.map((coin) => ({\n      id: coin.utxoId,\n      assetId: coin.assetId,\n      amount: bn(coin.amount),\n      owner: Address.fromAddressOrString(coin.owner),\n      maturity: bn(coin.maturity).toNumber(),\n      blockCreated: bn(coin.blockCreated),\n      txCreatedIdx: bn(coin.txCreatedIdx),\n    }));\n  }\n\n  /**\n   * Returns resources for the given owner satisfying the spend query.\n   *\n   * @param owner - The address to get resources for.\n   * @param quantities - The quantities to get.\n   * @param excludedIds - IDs of excluded resources from the selection.\n   * @returns A promise that resolves to the resources.\n   */\n  async getResourcesToSpend(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** The quantities to get */\n    quantities: CoinQuantityLike[],\n    /** IDs of excluded resources from the selection. */\n    excludedIds?: ExcludeResourcesOption\n  ): Promise<Resource[]> {\n    const excludeInput = {\n      messages: excludedIds?.messages?.map((id) => hexlify(id)) || [],\n      utxos: excludedIds?.utxos?.map((id) => hexlify(id)) || [],\n    };\n\n    if (this.cache) {\n      const uniqueUtxos = new Set(\n        excludeInput.utxos.concat(this.cache?.getActiveData().map((id) => hexlify(id)))\n      );\n      excludeInput.utxos = Array.from(uniqueUtxos);\n    }\n    const coinsQuery = {\n      owner: owner.toB256(),\n      queryPerAsset: quantities\n        .map(coinQuantityfy)\n        .map(({ assetId, amount, max: maxPerAsset }) => ({\n          assetId: hexlify(assetId),\n          amount: amount.toString(10),\n          max: maxPerAsset ? maxPerAsset.toString(10) : undefined,\n        })),\n      excludedIds: excludeInput,\n    };\n\n    const result = await this.operations.getCoinsToSpend(coinsQuery);\n\n    const coins = result.coinsToSpend\n      .flat()\n      .map((coin) => {\n        switch (coin.__typename) {\n          case 'MessageCoin':\n            return {\n              amount: bn(coin.amount),\n              assetId: coin.assetId,\n              daHeight: bn(coin.daHeight),\n              sender: Address.fromAddressOrString(coin.sender),\n              recipient: Address.fromAddressOrString(coin.recipient),\n              nonce: coin.nonce,\n            } as MessageCoin;\n          case 'Coin':\n            return {\n              id: coin.utxoId,\n              amount: bn(coin.amount),\n              assetId: coin.assetId,\n              owner: Address.fromAddressOrString(coin.owner),\n              maturity: bn(coin.maturity).toNumber(),\n              blockCreated: bn(coin.blockCreated),\n              txCreatedIdx: bn(coin.txCreatedIdx),\n            } as Coin;\n          default:\n            return null;\n        }\n      })\n      .filter((v) => !!v) as Array<Resource>;\n\n    return coins;\n  }\n\n  /**\n   * Returns block matching the given ID or height.\n   *\n   * @param idOrHeight - ID or height of the block.\n   * @returns A promise that resolves to the block.\n   */\n  async getBlock(\n    /** ID or height of the block */\n    idOrHeight: string | number | 'latest'\n  ): Promise<Block | null> {\n    let variables;\n    if (typeof idOrHeight === 'number') {\n      variables = { height: bn(idOrHeight).toString(10) };\n    } else if (idOrHeight === 'latest') {\n      variables = { height: (await this.getBlockNumber()).toString(10) };\n    } else if (idOrHeight.length === 66) {\n      variables = { blockId: idOrHeight };\n    } else {\n      variables = { blockId: bn(idOrHeight).toString(10) };\n    }\n\n    const { block } = await this.operations.getBlock(variables);\n\n    if (!block) {\n      return null;\n    }\n\n    return {\n      id: block.id,\n      height: bn(block.header.height),\n      time: block.header.time,\n      transactionIds: block.transactions.map((tx) => tx.id),\n    };\n  }\n\n  /**\n   * Returns all the blocks matching the given parameters.\n   *\n   * @param params - The parameters to query blocks.\n   * @returns A promise that resolves to the blocks.\n   */\n  async getBlocks(params: GqlGetBlocksQueryVariables): Promise<Block[]> {\n    const { blocks: fetchedData } = await this.operations.getBlocks(params);\n\n    const blocks: Block[] = fetchedData.edges.map(({ node: block }) => ({\n      id: block.id,\n      height: bn(block.header.height),\n      time: block.header.time,\n      transactionIds: block.transactions.map((tx) => tx.id),\n    }));\n\n    return blocks;\n  }\n\n  /**\n   * Returns block matching the given ID or type, including transaction data.\n   *\n   * @param idOrHeight - ID or height of the block.\n   * @returns A promise that resolves to the block.\n   */\n  async getBlockWithTransactions(\n    /** ID or height of the block */\n    idOrHeight: string | number | 'latest'\n  ): Promise<(Block & { transactions: Transaction[] }) | null> {\n    let variables;\n    if (typeof idOrHeight === 'number') {\n      variables = { blockHeight: bn(idOrHeight).toString(10) };\n    } else if (idOrHeight === 'latest') {\n      variables = { blockHeight: (await this.getBlockNumber()).toString() };\n    } else {\n      variables = { blockId: idOrHeight };\n    }\n\n    const { block } = await this.operations.getBlockWithTransactions(variables);\n\n    if (!block) {\n      return null;\n    }\n\n    return {\n      id: block.id,\n      height: bn(block.header.height, 10),\n      time: block.header.time,\n      transactionIds: block.transactions.map((tx) => tx.id),\n      transactions: block.transactions.map(\n        (tx) => new TransactionCoder().decode(getBytesCopy(tx.rawPayload), 0)?.[0]\n      ),\n    };\n  }\n\n  /**\n   * Get transaction with the given ID.\n   *\n   * @param transactionId - ID of the transaction.\n   * @returns A promise that resolves to the transaction.\n   */\n  async getTransaction<TTransactionType = void>(\n    transactionId: string\n  ): Promise<Transaction<TTransactionType> | null> {\n    const { transaction } = await this.operations.getTransaction({ transactionId });\n    if (!transaction) {\n      return null;\n    }\n    return new TransactionCoder().decode(\n      getBytesCopy(transaction.rawPayload),\n      0\n    )?.[0] as Transaction<TTransactionType>;\n  }\n\n  /**\n   * Get deployed contract with the given ID.\n   *\n   * @param contractId - ID of the contract.\n   * @returns A promise that resolves to the contract.\n   */\n  async getContract(contractId: string): Promise<ContractResult | null> {\n    const { contract } = await this.operations.getContract({ contractId });\n    if (!contract) {\n      return null;\n    }\n    return contract;\n  }\n\n  /**\n   * Returns the balance for the given contract for the given asset ID.\n   *\n   * @param contractId - The contract ID to get the balance for.\n   * @param assetId - The asset ID of coins to get.\n   * @returns A promise that resolves to the balance.\n   */\n  async getContractBalance(\n    /** The contract ID to get the balance for */\n    contractId: AbstractAddress,\n    /** The asset ID of coins to get */\n    assetId: BytesLike\n  ): Promise<BN> {\n    const { contractBalance } = await this.operations.getContractBalance({\n      contract: contractId.toB256(),\n      asset: hexlify(assetId),\n    });\n    return bn(contractBalance.amount, 10);\n  }\n\n  /**\n   * Returns the balance for the given owner for the given asset ID.\n   *\n   * @param owner - The address to get coins for.\n   * @param assetId - The asset ID of coins to get.\n   * @returns A promise that resolves to the balance.\n   */\n  async getBalance(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** The asset ID of coins to get */\n    assetId: BytesLike\n  ): Promise<BN> {\n    const { balance } = await this.operations.getBalance({\n      owner: owner.toB256(),\n      assetId: hexlify(assetId),\n    });\n    return bn(balance.amount, 10);\n  }\n\n  /**\n   * Returns balances for the given owner.\n   *\n   * @param owner - The address to get coins for.\n   * @param paginationArgs - Pagination arguments.\n   * @returns A promise that resolves to the balances.\n   */\n  async getBalances(\n    /** The address to get coins for */\n    owner: AbstractAddress,\n    /** Pagination arguments */\n    paginationArgs?: CursorPaginationArgs\n  ): Promise<CoinQuantity[]> {\n    const result = await this.operations.getBalances({\n      first: 10,\n      ...paginationArgs,\n      filter: { owner: owner.toB256() },\n    });\n\n    const balances = result.balances.edges.map((edge) => edge.node);\n\n    return balances.map((balance) => ({\n      assetId: balance.assetId,\n      amount: bn(balance.amount),\n    }));\n  }\n\n  /**\n   * Returns message for the given address.\n   *\n   * @param address - The address to get message from.\n   * @param paginationArgs - Pagination arguments.\n   * @returns A promise that resolves to the messages.\n   */\n  async getMessages(\n    /** The address to get message from */\n    address: AbstractAddress,\n    /** Pagination arguments */\n    paginationArgs?: CursorPaginationArgs\n  ): Promise<Message[]> {\n    const result = await this.operations.getMessages({\n      first: 10,\n      ...paginationArgs,\n      owner: address.toB256(),\n    });\n\n    const messages = result.messages.edges.map((edge) => edge.node);\n\n    return messages.map((message) => ({\n      messageId: InputMessageCoder.getMessageId({\n        sender: message.sender,\n        recipient: message.recipient,\n        nonce: message.nonce,\n        amount: bn(message.amount),\n        data: message.data,\n      }),\n      sender: Address.fromAddressOrString(message.sender),\n      recipient: Address.fromAddressOrString(message.recipient),\n      nonce: message.nonce,\n      amount: bn(message.amount),\n      data: InputMessageCoder.decodeData(message.data),\n      daHeight: bn(message.daHeight),\n    }));\n  }\n\n  /**\n   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.\n   *\n   * @param transactionId - The transaction to get message from.\n   * @param messageId - The message id from MessageOut receipt.\n   * @param commitBlockId - The commit block id.\n   * @param commitBlockHeight - The commit block height.\n   * @returns A promise that resolves to the message proof.\n   */\n  async getMessageProof(\n    /** The transaction to get message from */\n    transactionId: string,\n    nonce: string,\n    commitBlockId?: string,\n    commitBlockHeight?: BN\n  ): Promise<MessageProof | null> {\n    let inputObject: {\n      /** The transaction to get message from */\n      transactionId: string;\n      /** The message id from MessageOut receipt */\n      nonce: string;\n      commitBlockId?: string;\n      commitBlockHeight?: string;\n    } = {\n      transactionId,\n      nonce,\n    };\n\n    if (commitBlockId && commitBlockHeight) {\n      throw new FuelError(\n        ErrorCode.INVALID_INPUT_PARAMETERS,\n        'commitBlockId and commitBlockHeight cannot be used together'\n      );\n    }\n\n    if (commitBlockId) {\n      inputObject = {\n        ...inputObject,\n        commitBlockId,\n      };\n    }\n\n    if (commitBlockHeight) {\n      inputObject = {\n        ...inputObject,\n        // Conver BN into a number string required on the query\n        // This should problably be fixed on the fuel client side\n        commitBlockHeight: commitBlockHeight.toNumber().toString(),\n      };\n    }\n\n    const result = await this.operations.getMessageProof(inputObject);\n\n    if (!result.messageProof) {\n      return null;\n    }\n\n    const {\n      messageProof,\n      messageBlockHeader,\n      commitBlockHeader,\n      blockProof,\n      sender,\n      recipient,\n      amount,\n      data,\n    } = result.messageProof;\n\n    return {\n      messageProof: {\n        proofIndex: bn(messageProof.proofIndex),\n        proofSet: messageProof.proofSet,\n      },\n      blockProof: {\n        proofIndex: bn(blockProof.proofIndex),\n        proofSet: blockProof.proofSet,\n      },\n      messageBlockHeader: {\n        id: messageBlockHeader.id,\n        daHeight: bn(messageBlockHeader.daHeight),\n        transactionsCount: bn(messageBlockHeader.transactionsCount),\n        transactionsRoot: messageBlockHeader.transactionsRoot,\n        height: bn(messageBlockHeader.height),\n        prevRoot: messageBlockHeader.prevRoot,\n        time: messageBlockHeader.time,\n        applicationHash: messageBlockHeader.applicationHash,\n        messageReceiptRoot: messageBlockHeader.messageReceiptRoot,\n        messageReceiptCount: bn(messageBlockHeader.messageReceiptCount),\n      },\n      commitBlockHeader: {\n        id: commitBlockHeader.id,\n        daHeight: bn(commitBlockHeader.daHeight),\n        transactionsCount: bn(commitBlockHeader.transactionsCount),\n        transactionsRoot: commitBlockHeader.transactionsRoot,\n        height: bn(commitBlockHeader.height),\n        prevRoot: commitBlockHeader.prevRoot,\n        time: commitBlockHeader.time,\n        applicationHash: commitBlockHeader.applicationHash,\n        messageReceiptRoot: commitBlockHeader.messageReceiptRoot,\n        messageReceiptCount: bn(commitBlockHeader.messageReceiptCount),\n      },\n      sender: Address.fromAddressOrString(sender),\n      recipient: Address.fromAddressOrString(recipient),\n      nonce,\n      amount: bn(amount),\n      data,\n    };\n  }\n\n  /**\n   * Returns Message Proof for given transaction id and the message id from MessageOut receipt.\n   *\n   * @param nonce - The nonce of the message to get status from.\n   * @returns A promise that resolves to the message status\n   */\n  async getMessageStatus(\n    /** The nonce of the message to get status from */\n    nonce: string\n  ): Promise<MessageStatus> {\n    const result = await this.operations.getMessageStatus({ nonce });\n    return result.messageStatus;\n  }\n\n  /**\n   * Lets you produce blocks with custom timestamps and the block number of the last block produced.\n   *\n   * @param amount - The amount of blocks to produce\n   * @param startTime - The UNIX timestamp to set for the first produced block\n   * @returns A promise that resolves to the block number of the last produced block.\n   */\n  async produceBlocks(amount: number, startTime?: number) {\n    const { produceBlocks: latestBlockHeight } = await this.operations.produceBlocks({\n      blocksToProduce: bn(amount).toString(10),\n      startTimestamp: startTime ? fromUnixToTai64(startTime) : undefined,\n    });\n    return bn(latestBlockHeight);\n  }\n}\n","import type { GraphQLClient } from 'graphql-request';\nimport type * as Dom from 'graphql-request/dist/types.dom';\nimport gql from 'graphql-tag';\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  Address: string;\n  AssetId: string;\n  BlockId: string;\n  Bytes32: string;\n  ContractId: string;\n  HexString: string;\n  Nonce: string;\n  Salt: string;\n  Signature: any;\n  Tai64Timestamp: any;\n  TransactionId: string;\n  TxPointer: any;\n  U8: any;\n  U32: any;\n  U64: string;\n  UtxoId: string;\n};\n\nexport type GqlBalance = {\n  __typename: 'Balance';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  owner: Scalars['Address'];\n};\n\nexport type GqlBalanceConnection = {\n  __typename: 'BalanceConnection';\n  /** A list of edges. */\n  edges: Array<GqlBalanceEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlBalance>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlBalanceEdge = {\n  __typename: 'BalanceEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlBalance;\n};\n\nexport type GqlBalanceFilterInput = {\n  /** Filter coins based on the `owner` field */\n  owner: Scalars['Address'];\n};\n\nexport type GqlBlock = {\n  __typename: 'Block';\n  consensus: GqlConsensus;\n  header: GqlHeader;\n  id: Scalars['BlockId'];\n  transactions: Array<GqlTransaction>;\n};\n\nexport type GqlBlockConnection = {\n  __typename: 'BlockConnection';\n  /** A list of edges. */\n  edges: Array<GqlBlockEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlBlock>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlBlockEdge = {\n  __typename: 'BlockEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlBlock;\n};\n\nexport type GqlBreakpoint = {\n  contract: Scalars['ContractId'];\n  pc: Scalars['U64'];\n};\n\nexport type GqlChainInfo = {\n  __typename: 'ChainInfo';\n  consensusParameters: GqlConsensusParameters;\n  daHeight: Scalars['U64'];\n  gasCosts: GqlGasCosts;\n  latestBlock: GqlBlock;\n  name: Scalars['String'];\n};\n\nexport type GqlChangeOutput = {\n  __typename: 'ChangeOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\nexport type GqlCoin = {\n  __typename: 'Coin';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  /** TxPointer - the height of the block this coin was created in */\n  blockCreated: Scalars['U32'];\n  maturity: Scalars['U32'];\n  owner: Scalars['Address'];\n  /** TxPointer - the index of the transaction that created this coin */\n  txCreatedIdx: Scalars['U64'];\n  utxoId: Scalars['UtxoId'];\n};\n\nexport type GqlCoinConnection = {\n  __typename: 'CoinConnection';\n  /** A list of edges. */\n  edges: Array<GqlCoinEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlCoin>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlCoinEdge = {\n  __typename: 'CoinEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlCoin;\n};\n\nexport type GqlCoinFilterInput = {\n  /** Returns coins only with `asset_id`. */\n  assetId?: InputMaybe<Scalars['AssetId']>;\n  /** Returns coins owned by the `owner`. */\n  owner: Scalars['Address'];\n};\n\nexport type GqlCoinOutput = {\n  __typename: 'CoinOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\n/** The schema analog of the [`coins::CoinType`]. */\nexport type GqlCoinType = GqlCoin | GqlMessageCoin;\n\nexport type GqlConsensus = GqlGenesis | GqlPoAConsensus;\n\nexport type GqlConsensusParameters = {\n  __typename: 'ConsensusParameters';\n  baseAssetId: Scalars['AssetId'];\n  chainId: Scalars['U64'];\n  contractParams: GqlContractParameters;\n  feeParams: GqlFeeParameters;\n  gasCosts: GqlGasCosts;\n  predicateParams: GqlPredicateParameters;\n  scriptParams: GqlScriptParameters;\n  txParams: GqlTxParameters;\n};\n\nexport type GqlContract = {\n  __typename: 'Contract';\n  bytecode: Scalars['HexString'];\n  id: Scalars['ContractId'];\n  salt: Scalars['Salt'];\n};\n\nexport type GqlContractBalance = {\n  __typename: 'ContractBalance';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  contract: Scalars['ContractId'];\n};\n\nexport type GqlContractBalanceConnection = {\n  __typename: 'ContractBalanceConnection';\n  /** A list of edges. */\n  edges: Array<GqlContractBalanceEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlContractBalance>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlContractBalanceEdge = {\n  __typename: 'ContractBalanceEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlContractBalance;\n};\n\nexport type GqlContractBalanceFilterInput = {\n  /** Filter assets based on the `contractId` field */\n  contract: Scalars['ContractId'];\n};\n\nexport type GqlContractCreated = {\n  __typename: 'ContractCreated';\n  contract: GqlContract;\n  stateRoot: Scalars['Bytes32'];\n};\n\nexport type GqlContractOutput = {\n  __typename: 'ContractOutput';\n  balanceRoot: Scalars['Bytes32'];\n  inputIndex: Scalars['Int'];\n  stateRoot: Scalars['Bytes32'];\n};\n\nexport type GqlContractParameters = {\n  __typename: 'ContractParameters';\n  contractMaxSize: Scalars['U64'];\n  maxStorageSlots: Scalars['U64'];\n};\n\nexport type GqlDependentCost = GqlHeavyOperation | GqlLightOperation;\n\nexport type GqlExcludeInput = {\n  /** Messages to exclude from the selection. */\n  messages: Array<Scalars['Nonce']>;\n  /** Utxos to exclude from the selection. */\n  utxos: Array<Scalars['UtxoId']>;\n};\n\nexport type GqlFailureStatus = {\n  __typename: 'FailureStatus';\n  block: GqlBlock;\n  programState?: Maybe<GqlProgramState>;\n  reason: Scalars['String'];\n  receipts: Array<GqlReceipt>;\n  time: Scalars['Tai64Timestamp'];\n  transactionId: Scalars['TransactionId'];\n};\n\nexport type GqlFeeParameters = {\n  __typename: 'FeeParameters';\n  gasPerByte: Scalars['U64'];\n  gasPriceFactor: Scalars['U64'];\n};\n\nexport type GqlGasCosts = {\n  __typename: 'GasCosts';\n  add: Scalars['U64'];\n  addi: Scalars['U64'];\n  aloc: Scalars['U64'];\n  and: Scalars['U64'];\n  andi: Scalars['U64'];\n  bal: Scalars['U64'];\n  bhei: Scalars['U64'];\n  bhsh: Scalars['U64'];\n  burn: Scalars['U64'];\n  call: GqlDependentCost;\n  cb: Scalars['U64'];\n  ccp: GqlDependentCost;\n  cfei: Scalars['U64'];\n  cfsi: Scalars['U64'];\n  contractRoot: GqlDependentCost;\n  croo: Scalars['U64'];\n  csiz: GqlDependentCost;\n  div: Scalars['U64'];\n  divi: Scalars['U64'];\n  eck1: Scalars['U64'];\n  ecr1: Scalars['U64'];\n  ed19: Scalars['U64'];\n  eq: Scalars['U64'];\n  exp: Scalars['U64'];\n  expi: Scalars['U64'];\n  flag: Scalars['U64'];\n  gm: Scalars['U64'];\n  gt: Scalars['U64'];\n  gtf: Scalars['U64'];\n  ji: Scalars['U64'];\n  jmp: Scalars['U64'];\n  jmpb: Scalars['U64'];\n  jmpf: Scalars['U64'];\n  jne: Scalars['U64'];\n  jneb: Scalars['U64'];\n  jnef: Scalars['U64'];\n  jnei: Scalars['U64'];\n  jnzb: Scalars['U64'];\n  jnzf: Scalars['U64'];\n  jnzi: Scalars['U64'];\n  k256: GqlDependentCost;\n  lb: Scalars['U64'];\n  ldc: GqlDependentCost;\n  log: Scalars['U64'];\n  logd: GqlDependentCost;\n  lt: Scalars['U64'];\n  lw: Scalars['U64'];\n  mcl: GqlDependentCost;\n  mcli: GqlDependentCost;\n  mcp: GqlDependentCost;\n  mcpi: GqlDependentCost;\n  meq: GqlDependentCost;\n  mint: Scalars['U64'];\n  mldv: Scalars['U64'];\n  mlog: Scalars['U64'];\n  modOp: Scalars['U64'];\n  modi: Scalars['U64'];\n  moveOp: Scalars['U64'];\n  movi: Scalars['U64'];\n  mroo: Scalars['U64'];\n  mul: Scalars['U64'];\n  muli: Scalars['U64'];\n  newStoragePerByte: Scalars['U64'];\n  noop: Scalars['U64'];\n  not: Scalars['U64'];\n  or: Scalars['U64'];\n  ori: Scalars['U64'];\n  poph: Scalars['U64'];\n  popl: Scalars['U64'];\n  pshh: Scalars['U64'];\n  pshl: Scalars['U64'];\n  ret: Scalars['U64'];\n  retd: GqlDependentCost;\n  rvrt: Scalars['U64'];\n  s256: GqlDependentCost;\n  sb: Scalars['U64'];\n  scwq: GqlDependentCost;\n  sll: Scalars['U64'];\n  slli: Scalars['U64'];\n  smo: GqlDependentCost;\n  srl: Scalars['U64'];\n  srli: Scalars['U64'];\n  srw: Scalars['U64'];\n  srwq: GqlDependentCost;\n  stateRoot: GqlDependentCost;\n  sub: Scalars['U64'];\n  subi: Scalars['U64'];\n  sw: Scalars['U64'];\n  sww: Scalars['U64'];\n  swwq: GqlDependentCost;\n  time: Scalars['U64'];\n  tr: Scalars['U64'];\n  tro: Scalars['U64'];\n  vmInitialization: GqlDependentCost;\n  wdam: Scalars['U64'];\n  wdcm: Scalars['U64'];\n  wddv: Scalars['U64'];\n  wdmd: Scalars['U64'];\n  wdml: Scalars['U64'];\n  wdmm: Scalars['U64'];\n  wdop: Scalars['U64'];\n  wqam: Scalars['U64'];\n  wqcm: Scalars['U64'];\n  wqdv: Scalars['U64'];\n  wqmd: Scalars['U64'];\n  wqml: Scalars['U64'];\n  wqmm: Scalars['U64'];\n  wqop: Scalars['U64'];\n  xor: Scalars['U64'];\n  xori: Scalars['U64'];\n};\n\nexport type GqlGenesis = {\n  __typename: 'Genesis';\n  /**\n   * The chain configs define what consensus type to use, what settlement layer to use,\n   * rules of block validity, etc.\n   */\n  chainConfigHash: Scalars['Bytes32'];\n  /** The Binary Merkle Tree root of all genesis coins. */\n  coinsRoot: Scalars['Bytes32'];\n  /** The Binary Merkle Tree root of state, balances, contracts code hash of each contract. */\n  contractsRoot: Scalars['Bytes32'];\n  /** The Binary Merkle Tree root of all genesis messages. */\n  messagesRoot: Scalars['Bytes32'];\n};\n\nexport type GqlHeader = {\n  __typename: 'Header';\n  /** Hash of the application header. */\n  applicationHash: Scalars['Bytes32'];\n  /** The layer 1 height of messages and events to include since the last layer 1 block number. */\n  daHeight: Scalars['U64'];\n  /** Fuel block height. */\n  height: Scalars['U32'];\n  /** Hash of the header */\n  id: Scalars['BlockId'];\n  /** Number of message receipts in this block. */\n  messageReceiptCount: Scalars['U64'];\n  /** Merkle root of message receipts in this block. */\n  messageReceiptRoot: Scalars['Bytes32'];\n  /** Merkle root of all previous block header hashes. */\n  prevRoot: Scalars['Bytes32'];\n  /** The block producer time. */\n  time: Scalars['Tai64Timestamp'];\n  /** Number of transactions in this block. */\n  transactionsCount: Scalars['U64'];\n  /** Merkle root of transactions. */\n  transactionsRoot: Scalars['Bytes32'];\n};\n\nexport type GqlHeavyOperation = {\n  __typename: 'HeavyOperation';\n  base: Scalars['U64'];\n  gasPerUnit: Scalars['U64'];\n};\n\nexport type GqlInput = GqlInputCoin | GqlInputContract | GqlInputMessage;\n\nexport type GqlInputCoin = {\n  __typename: 'InputCoin';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  maturity: Scalars['U32'];\n  owner: Scalars['Address'];\n  predicate: Scalars['HexString'];\n  predicateData: Scalars['HexString'];\n  predicateGasUsed: Scalars['U64'];\n  txPointer: Scalars['TxPointer'];\n  utxoId: Scalars['UtxoId'];\n  witnessIndex: Scalars['Int'];\n};\n\nexport type GqlInputContract = {\n  __typename: 'InputContract';\n  balanceRoot: Scalars['Bytes32'];\n  contract: GqlContract;\n  stateRoot: Scalars['Bytes32'];\n  txPointer: Scalars['TxPointer'];\n  utxoId: Scalars['UtxoId'];\n};\n\nexport type GqlInputMessage = {\n  __typename: 'InputMessage';\n  amount: Scalars['U64'];\n  data: Scalars['HexString'];\n  nonce: Scalars['Nonce'];\n  predicate: Scalars['HexString'];\n  predicateData: Scalars['HexString'];\n  predicateGasUsed: Scalars['U64'];\n  recipient: Scalars['Address'];\n  sender: Scalars['Address'];\n  witnessIndex: Scalars['Int'];\n};\n\nexport type GqlLightOperation = {\n  __typename: 'LightOperation';\n  base: Scalars['U64'];\n  unitsPerGas: Scalars['U64'];\n};\n\nexport type GqlMerkleProof = {\n  __typename: 'MerkleProof';\n  proofIndex: Scalars['U64'];\n  proofSet: Array<Scalars['Bytes32']>;\n};\n\nexport type GqlMessage = {\n  __typename: 'Message';\n  amount: Scalars['U64'];\n  daHeight: Scalars['U64'];\n  data: Scalars['HexString'];\n  nonce: Scalars['Nonce'];\n  recipient: Scalars['Address'];\n  sender: Scalars['Address'];\n};\n\nexport type GqlMessageCoin = {\n  __typename: 'MessageCoin';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  daHeight: Scalars['U64'];\n  nonce: Scalars['Nonce'];\n  recipient: Scalars['Address'];\n  sender: Scalars['Address'];\n};\n\nexport type GqlMessageConnection = {\n  __typename: 'MessageConnection';\n  /** A list of edges. */\n  edges: Array<GqlMessageEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlMessage>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlMessageEdge = {\n  __typename: 'MessageEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlMessage;\n};\n\nexport type GqlMessageProof = {\n  __typename: 'MessageProof';\n  amount: Scalars['U64'];\n  blockProof: GqlMerkleProof;\n  commitBlockHeader: GqlHeader;\n  data: Scalars['HexString'];\n  messageBlockHeader: GqlHeader;\n  messageProof: GqlMerkleProof;\n  nonce: Scalars['Nonce'];\n  recipient: Scalars['Address'];\n  sender: Scalars['Address'];\n};\n\nexport enum GqlMessageState {\n  NotFound = 'NOT_FOUND',\n  Spent = 'SPENT',\n  Unspent = 'UNSPENT'\n}\n\nexport type GqlMessageStatus = {\n  __typename: 'MessageStatus';\n  state: GqlMessageState;\n};\n\nexport type GqlMutation = {\n  __typename: 'Mutation';\n  continueTx: GqlRunResult;\n  /** Execute a dry-run of the transaction using a fork of current state, no changes are committed. */\n  dryRun: Array<GqlReceipt>;\n  endSession: Scalars['Boolean'];\n  execute: Scalars['Boolean'];\n  /**\n   * Sequentially produces `blocks_to_produce` blocks. The first block starts with\n   * `start_timestamp`. If the block production in the [`crate::service::Config`] is\n   * `Trigger::Interval { block_time }`, produces blocks with `block_time ` intervals between\n   * them. The `start_timestamp` is the timestamp in seconds.\n   */\n  produceBlocks: Scalars['U32'];\n  reset: Scalars['Boolean'];\n  setBreakpoint: Scalars['Boolean'];\n  setSingleStepping: Scalars['Boolean'];\n  startSession: Scalars['ID'];\n  startTx: GqlRunResult;\n  /**\n   * Submits transaction to the `TxPool`.\n   *\n   * Returns submitted transaction if the transaction is included in the `TxPool` without problems.\n   */\n  submit: GqlTransaction;\n};\n\n\nexport type GqlMutationContinueTxArgs = {\n  id: Scalars['ID'];\n};\n\n\nexport type GqlMutationDryRunArgs = {\n  tx: Scalars['HexString'];\n  utxoValidation?: InputMaybe<Scalars['Boolean']>;\n};\n\n\nexport type GqlMutationEndSessionArgs = {\n  id: Scalars['ID'];\n};\n\n\nexport type GqlMutationExecuteArgs = {\n  id: Scalars['ID'];\n  op: Scalars['String'];\n};\n\n\nexport type GqlMutationProduceBlocksArgs = {\n  blocksToProduce: Scalars['U32'];\n  startTimestamp?: InputMaybe<Scalars['Tai64Timestamp']>;\n};\n\n\nexport type GqlMutationResetArgs = {\n  id: Scalars['ID'];\n};\n\n\nexport type GqlMutationSetBreakpointArgs = {\n  breakpoint: GqlBreakpoint;\n  id: Scalars['ID'];\n};\n\n\nexport type GqlMutationSetSingleSteppingArgs = {\n  enable: Scalars['Boolean'];\n  id: Scalars['ID'];\n};\n\n\nexport type GqlMutationStartTxArgs = {\n  id: Scalars['ID'];\n  txJson: Scalars['String'];\n};\n\n\nexport type GqlMutationSubmitArgs = {\n  tx: Scalars['HexString'];\n};\n\nexport type GqlNodeInfo = {\n  __typename: 'NodeInfo';\n  maxDepth: Scalars['U64'];\n  maxTx: Scalars['U64'];\n  minGasPrice: Scalars['U64'];\n  nodeVersion: Scalars['String'];\n  peers: Array<GqlPeerInfo>;\n  utxoValidation: Scalars['Boolean'];\n  vmBacktrace: Scalars['Boolean'];\n};\n\nexport type GqlOutput = GqlChangeOutput | GqlCoinOutput | GqlContractCreated | GqlContractOutput | GqlVariableOutput;\n\n/**\n * A separate `Breakpoint` type to be used as an output, as a single\n * type cannot act as both input and output type in async-graphql\n */\nexport type GqlOutputBreakpoint = {\n  __typename: 'OutputBreakpoint';\n  contract: Scalars['ContractId'];\n  pc: Scalars['U64'];\n};\n\n/** Information about pagination in a connection */\nexport type GqlPageInfo = {\n  __typename: 'PageInfo';\n  /** When paginating forwards, the cursor to continue. */\n  endCursor?: Maybe<Scalars['String']>;\n  /** When paginating forwards, are there more items? */\n  hasNextPage: Scalars['Boolean'];\n  /** When paginating backwards, are there more items? */\n  hasPreviousPage: Scalars['Boolean'];\n  /** When paginating backwards, the cursor to continue. */\n  startCursor?: Maybe<Scalars['String']>;\n};\n\nexport type GqlPeerInfo = {\n  __typename: 'PeerInfo';\n  /** The advertised multi-addrs that can be used to connect to this peer */\n  addresses: Array<Scalars['String']>;\n  /** The internal fuel p2p reputation of this peer */\n  appScore: Scalars['Float'];\n  /** The last reported height of the peer */\n  blockHeight?: Maybe<Scalars['U32']>;\n  /** The self-reported version of the client the peer is using */\n  clientVersion?: Maybe<Scalars['String']>;\n  /** The libp2p peer id */\n  id: Scalars['String'];\n  /** The last heartbeat from this peer in unix epoch time ms */\n  lastHeartbeatMs: Scalars['U64'];\n};\n\nexport type GqlPoAConsensus = {\n  __typename: 'PoAConsensus';\n  /** Gets the signature of the block produced by `PoA` consensus. */\n  signature: Scalars['Signature'];\n};\n\nexport type GqlPolicies = {\n  __typename: 'Policies';\n  gasPrice?: Maybe<Scalars['U64']>;\n  maturity?: Maybe<Scalars['U32']>;\n  maxFee?: Maybe<Scalars['U64']>;\n  witnessLimit?: Maybe<Scalars['U64']>;\n};\n\nexport type GqlPredicateParameters = {\n  __typename: 'PredicateParameters';\n  maxGasPerPredicate: Scalars['U64'];\n  maxMessageDataLength: Scalars['U64'];\n  maxPredicateDataLength: Scalars['U64'];\n  maxPredicateLength: Scalars['U64'];\n};\n\nexport type GqlProgramState = {\n  __typename: 'ProgramState';\n  data: Scalars['HexString'];\n  returnType: GqlReturnType;\n};\n\nexport type GqlQuery = {\n  __typename: 'Query';\n  balance: GqlBalance;\n  balances: GqlBalanceConnection;\n  block?: Maybe<GqlBlock>;\n  blocks: GqlBlockConnection;\n  chain: GqlChainInfo;\n  /** Gets the coin by `utxo_id`. */\n  coin?: Maybe<GqlCoin>;\n  /** Gets all unspent coins of some `owner` maybe filtered with by `asset_id` per page. */\n  coins: GqlCoinConnection;\n  /**\n   * For each `query_per_asset`, get some spendable coins(of asset specified by the query) owned by\n   * `owner` that add up at least the query amount. The returned coins can be spent.\n   * The number of coins is optimized to prevent dust accumulation.\n   *\n   * The query supports excluding and maximum the number of coins.\n   *\n   * Returns:\n   * The list of spendable coins per asset from the query. The length of the result is\n   * the same as the length of `query_per_asset`. The ordering of assets and `query_per_asset`\n   * is the same.\n   */\n  coinsToSpend: Array<Array<GqlCoinType>>;\n  contract?: Maybe<GqlContract>;\n  contractBalance: GqlContractBalance;\n  contractBalances: GqlContractBalanceConnection;\n  /** Estimate the predicate gas for the provided transaction */\n  estimatePredicates: GqlTransaction;\n  /** Returns true when the GraphQL API is serving requests. */\n  health: Scalars['Boolean'];\n  memory: Scalars['String'];\n  messageProof?: Maybe<GqlMessageProof>;\n  messageStatus: GqlMessageStatus;\n  messages: GqlMessageConnection;\n  nodeInfo: GqlNodeInfo;\n  register: Scalars['U64'];\n  transaction?: Maybe<GqlTransaction>;\n  transactions: GqlTransactionConnection;\n  transactionsByOwner: GqlTransactionConnection;\n};\n\n\nexport type GqlQueryBalanceArgs = {\n  assetId: Scalars['AssetId'];\n  owner: Scalars['Address'];\n};\n\n\nexport type GqlQueryBalancesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlBalanceFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type GqlQueryBlockArgs = {\n  height?: InputMaybe<Scalars['U32']>;\n  id?: InputMaybe<Scalars['BlockId']>;\n};\n\n\nexport type GqlQueryBlocksArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type GqlQueryCoinArgs = {\n  utxoId: Scalars['UtxoId'];\n};\n\n\nexport type GqlQueryCoinsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlCoinFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type GqlQueryCoinsToSpendArgs = {\n  excludedIds?: InputMaybe<GqlExcludeInput>;\n  owner: Scalars['Address'];\n  queryPerAsset: Array<GqlSpendQueryElementInput>;\n};\n\n\nexport type GqlQueryContractArgs = {\n  id: Scalars['ContractId'];\n};\n\n\nexport type GqlQueryContractBalanceArgs = {\n  asset: Scalars['AssetId'];\n  contract: Scalars['ContractId'];\n};\n\n\nexport type GqlQueryContractBalancesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filter: GqlContractBalanceFilterInput;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type GqlQueryEstimatePredicatesArgs = {\n  tx: Scalars['HexString'];\n};\n\n\nexport type GqlQueryMemoryArgs = {\n  id: Scalars['ID'];\n  size: Scalars['U32'];\n  start: Scalars['U32'];\n};\n\n\nexport type GqlQueryMessageProofArgs = {\n  commitBlockHeight?: InputMaybe<Scalars['U32']>;\n  commitBlockId?: InputMaybe<Scalars['BlockId']>;\n  nonce: Scalars['Nonce'];\n  transactionId: Scalars['TransactionId'];\n};\n\n\nexport type GqlQueryMessageStatusArgs = {\n  nonce: Scalars['Nonce'];\n};\n\n\nexport type GqlQueryMessagesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  owner?: InputMaybe<Scalars['Address']>;\n};\n\n\nexport type GqlQueryRegisterArgs = {\n  id: Scalars['ID'];\n  register: Scalars['U32'];\n};\n\n\nexport type GqlQueryTransactionArgs = {\n  id: Scalars['TransactionId'];\n};\n\n\nexport type GqlQueryTransactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type GqlQueryTransactionsByOwnerArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  owner: Scalars['Address'];\n};\n\nexport type GqlReceipt = {\n  __typename: 'Receipt';\n  amount?: Maybe<Scalars['U64']>;\n  assetId?: Maybe<Scalars['AssetId']>;\n  contract?: Maybe<GqlContract>;\n  contractId?: Maybe<Scalars['ContractId']>;\n  data?: Maybe<Scalars['HexString']>;\n  digest?: Maybe<Scalars['Bytes32']>;\n  gas?: Maybe<Scalars['U64']>;\n  gasUsed?: Maybe<Scalars['U64']>;\n  is?: Maybe<Scalars['U64']>;\n  len?: Maybe<Scalars['U64']>;\n  nonce?: Maybe<Scalars['Nonce']>;\n  param1?: Maybe<Scalars['U64']>;\n  param2?: Maybe<Scalars['U64']>;\n  pc?: Maybe<Scalars['U64']>;\n  ptr?: Maybe<Scalars['U64']>;\n  ra?: Maybe<Scalars['U64']>;\n  rb?: Maybe<Scalars['U64']>;\n  rc?: Maybe<Scalars['U64']>;\n  rd?: Maybe<Scalars['U64']>;\n  reason?: Maybe<Scalars['U64']>;\n  receiptType: GqlReceiptType;\n  recipient?: Maybe<Scalars['Address']>;\n  result?: Maybe<Scalars['U64']>;\n  sender?: Maybe<Scalars['Address']>;\n  subId?: Maybe<Scalars['Bytes32']>;\n  to?: Maybe<GqlContract>;\n  toAddress?: Maybe<Scalars['Address']>;\n  val?: Maybe<Scalars['U64']>;\n};\n\nexport enum GqlReceiptType {\n  Burn = 'BURN',\n  Call = 'CALL',\n  Log = 'LOG',\n  LogData = 'LOG_DATA',\n  MessageOut = 'MESSAGE_OUT',\n  Mint = 'MINT',\n  Panic = 'PANIC',\n  Return = 'RETURN',\n  ReturnData = 'RETURN_DATA',\n  Revert = 'REVERT',\n  ScriptResult = 'SCRIPT_RESULT',\n  Transfer = 'TRANSFER',\n  TransferOut = 'TRANSFER_OUT'\n}\n\nexport enum GqlReturnType {\n  Return = 'RETURN',\n  ReturnData = 'RETURN_DATA',\n  Revert = 'REVERT'\n}\n\nexport type GqlRunResult = {\n  __typename: 'RunResult';\n  breakpoint?: Maybe<GqlOutputBreakpoint>;\n  jsonReceipts: Array<Scalars['String']>;\n  state: GqlRunState;\n};\n\nexport enum GqlRunState {\n  /** Stopped on a breakpoint */\n  Breakpoint = 'BREAKPOINT',\n  /** All breakpoints have been processed, and the program has terminated */\n  Completed = 'COMPLETED'\n}\n\nexport type GqlScriptParameters = {\n  __typename: 'ScriptParameters';\n  maxScriptDataLength: Scalars['U64'];\n  maxScriptLength: Scalars['U64'];\n};\n\nexport type GqlSpendQueryElementInput = {\n  /** Target amount for the query. */\n  amount: Scalars['U64'];\n  /** Identifier of the asset to spend. */\n  assetId: Scalars['AssetId'];\n  /** The maximum number of currencies for selection. */\n  max?: InputMaybe<Scalars['U32']>;\n};\n\nexport type GqlSqueezedOutStatus = {\n  __typename: 'SqueezedOutStatus';\n  reason: Scalars['String'];\n};\n\nexport type GqlSubmittedStatus = {\n  __typename: 'SubmittedStatus';\n  time: Scalars['Tai64Timestamp'];\n};\n\nexport type GqlSubscription = {\n  __typename: 'Subscription';\n  /**\n   * Returns a stream of status updates for the given transaction id.\n   * If the current status is [`TransactionStatus::Success`], [`TransactionStatus::SqueezedOut`]\n   * or [`TransactionStatus::Failed`] the stream will return that and end immediately.\n   * If the current status is [`TransactionStatus::Submitted`] this will be returned\n   * and the stream will wait for a future update.\n   *\n   * This stream will wait forever so it's advised to use within a timeout.\n   *\n   * It is possible for the stream to miss an update if it is polled slower\n   * then the updates arrive. In such a case the stream will close without\n   * a status. If this occurs the stream can simply be restarted to return\n   * the latest status.\n   */\n  statusChange: GqlTransactionStatus;\n  /** Submits transaction to the `TxPool` and await either confirmation or failure. */\n  submitAndAwait: GqlTransactionStatus;\n};\n\n\nexport type GqlSubscriptionStatusChangeArgs = {\n  id: Scalars['TransactionId'];\n};\n\n\nexport type GqlSubscriptionSubmitAndAwaitArgs = {\n  tx: Scalars['HexString'];\n};\n\nexport type GqlSuccessStatus = {\n  __typename: 'SuccessStatus';\n  block: GqlBlock;\n  programState?: Maybe<GqlProgramState>;\n  receipts: Array<GqlReceipt>;\n  time: Scalars['Tai64Timestamp'];\n  transactionId: Scalars['TransactionId'];\n};\n\nexport type GqlTransaction = {\n  __typename: 'Transaction';\n  bytecodeLength?: Maybe<Scalars['U64']>;\n  bytecodeWitnessIndex?: Maybe<Scalars['Int']>;\n  gasPrice?: Maybe<Scalars['U64']>;\n  id: Scalars['TransactionId'];\n  inputAssetIds?: Maybe<Array<Scalars['AssetId']>>;\n  inputContract?: Maybe<GqlInputContract>;\n  inputContracts?: Maybe<Array<GqlContract>>;\n  inputs?: Maybe<Array<GqlInput>>;\n  isCreate: Scalars['Boolean'];\n  isMint: Scalars['Boolean'];\n  isScript: Scalars['Boolean'];\n  maturity?: Maybe<Scalars['U32']>;\n  mintAmount?: Maybe<Scalars['U64']>;\n  mintAssetId?: Maybe<Scalars['AssetId']>;\n  outputContract?: Maybe<GqlContractOutput>;\n  outputs: Array<GqlOutput>;\n  policies?: Maybe<GqlPolicies>;\n  /** Return the transaction bytes using canonical encoding */\n  rawPayload: Scalars['HexString'];\n  receipts?: Maybe<Array<GqlReceipt>>;\n  receiptsRoot?: Maybe<Scalars['Bytes32']>;\n  salt?: Maybe<Scalars['Salt']>;\n  script?: Maybe<Scalars['HexString']>;\n  scriptData?: Maybe<Scalars['HexString']>;\n  scriptGasLimit?: Maybe<Scalars['U64']>;\n  status?: Maybe<GqlTransactionStatus>;\n  storageSlots?: Maybe<Array<Scalars['HexString']>>;\n  txPointer?: Maybe<Scalars['TxPointer']>;\n  witnesses?: Maybe<Array<Scalars['HexString']>>;\n};\n\nexport type GqlTransactionConnection = {\n  __typename: 'TransactionConnection';\n  /** A list of edges. */\n  edges: Array<GqlTransactionEdge>;\n  /** A list of nodes. */\n  nodes: Array<GqlTransaction>;\n  /** Information to aid in pagination. */\n  pageInfo: GqlPageInfo;\n};\n\n/** An edge in a connection. */\nexport type GqlTransactionEdge = {\n  __typename: 'TransactionEdge';\n  /** A cursor for use in pagination */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge */\n  node: GqlTransaction;\n};\n\nexport type GqlTransactionStatus = GqlFailureStatus | GqlSqueezedOutStatus | GqlSubmittedStatus | GqlSuccessStatus;\n\nexport type GqlTxParameters = {\n  __typename: 'TxParameters';\n  maxGasPerTx: Scalars['U64'];\n  maxInputs: Scalars['U8'];\n  maxOutputs: Scalars['U8'];\n  maxSize: Scalars['U64'];\n  maxWitnesses: Scalars['U32'];\n};\n\nexport type GqlVariableOutput = {\n  __typename: 'VariableOutput';\n  amount: Scalars['U64'];\n  assetId: Scalars['AssetId'];\n  to: Scalars['Address'];\n};\n\nexport type GqlTransactionFragmentFragment = { __typename: 'Transaction', id: string, rawPayload: string, gasPrice?: string | null, receipts?: Array<{ __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null }> | null, status?: { __typename: 'FailureStatus', time: any, reason: string, type: 'FailureStatus', block: { __typename: 'Block', id: string } } | { __typename: 'SqueezedOutStatus', type: 'SqueezedOutStatus' } | { __typename: 'SubmittedStatus', time: any, type: 'SubmittedStatus' } | { __typename: 'SuccessStatus', time: any, type: 'SuccessStatus', block: { __typename: 'Block', id: string }, programState?: { __typename: 'ProgramState', returnType: GqlReturnType, data: string } | null } | null };\n\nexport type GqlReceiptFragmentFragment = { __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null };\n\nexport type GqlBlockFragmentFragment = { __typename: 'Block', id: string, header: { __typename: 'Header', height: any, time: any }, transactions: Array<{ __typename: 'Transaction', id: string }> };\n\nexport type GqlCoinFragmentFragment = { __typename: 'Coin', utxoId: string, owner: string, amount: string, assetId: string, maturity: any, blockCreated: any, txCreatedIdx: string };\n\nexport type GqlMessageCoinFragmentFragment = { __typename: 'MessageCoin', sender: string, recipient: string, nonce: string, amount: string, assetId: string, daHeight: string };\n\nexport type GqlMessageFragmentFragment = { __typename: 'Message', amount: string, sender: string, recipient: string, data: string, nonce: string, daHeight: string };\n\nexport type GqlMessageProofFragmentFragment = { __typename: 'MessageProof', sender: string, recipient: string, nonce: string, amount: string, data: string, messageProof: { __typename: 'MerkleProof', proofSet: Array<string>, proofIndex: string }, blockProof: { __typename: 'MerkleProof', proofSet: Array<string>, proofIndex: string }, messageBlockHeader: { __typename: 'Header', id: string, daHeight: string, transactionsCount: string, transactionsRoot: string, height: any, prevRoot: string, time: any, applicationHash: string, messageReceiptRoot: string, messageReceiptCount: string }, commitBlockHeader: { __typename: 'Header', id: string, daHeight: string, transactionsCount: string, transactionsRoot: string, height: any, prevRoot: string, time: any, applicationHash: string, messageReceiptRoot: string, messageReceiptCount: string } };\n\nexport type GqlBalanceFragmentFragment = { __typename: 'Balance', owner: string, amount: string, assetId: string };\n\nexport type GqlTxParametersFragmentFragment = { __typename: 'TxParameters', maxInputs: any, maxOutputs: any, maxWitnesses: any, maxGasPerTx: string, maxSize: string };\n\nexport type GqlPredicateParametersFragmentFragment = { __typename: 'PredicateParameters', maxPredicateLength: string, maxPredicateDataLength: string, maxGasPerPredicate: string, maxMessageDataLength: string };\n\nexport type GqlScriptParametersFragmentFragment = { __typename: 'ScriptParameters', maxScriptLength: string, maxScriptDataLength: string };\n\nexport type GqlContractParametersFragmentFragment = { __typename: 'ContractParameters', contractMaxSize: string, maxStorageSlots: string };\n\nexport type GqlFeeParametersFragmentFragment = { __typename: 'FeeParameters', gasPriceFactor: string, gasPerByte: string };\n\ntype GqlDependentCostFragment_HeavyOperation_Fragment = { __typename: 'HeavyOperation', base: string, gasPerUnit: string };\n\ntype GqlDependentCostFragment_LightOperation_Fragment = { __typename: 'LightOperation', base: string, unitsPerGas: string };\n\nexport type GqlDependentCostFragmentFragment = GqlDependentCostFragment_HeavyOperation_Fragment | GqlDependentCostFragment_LightOperation_Fragment;\n\nexport type GqlGasCostsFragmentFragment = { __typename: 'GasCosts', add: string, addi: string, aloc: string, and: string, andi: string, bal: string, bhei: string, bhsh: string, burn: string, cb: string, cfei: string, cfsi: string, croo: string, div: string, divi: string, ecr1: string, eck1: string, ed19: string, eq: string, exp: string, expi: string, flag: string, gm: string, gt: string, gtf: string, ji: string, jmp: string, jne: string, jnei: string, jnzi: string, jmpf: string, jmpb: string, jnzf: string, jnzb: string, jnef: string, jneb: string, lb: string, log: string, lt: string, lw: string, mint: string, mlog: string, modOp: string, modi: string, moveOp: string, movi: string, mroo: string, mul: string, muli: string, mldv: string, noop: string, not: string, or: string, ori: string, poph: string, popl: string, pshh: string, pshl: string, ret: string, rvrt: string, sb: string, sll: string, slli: string, srl: string, srli: string, srw: string, sub: string, subi: string, sw: string, sww: string, time: string, tr: string, tro: string, wdcm: string, wqcm: string, wdop: string, wqop: string, wdml: string, wqml: string, wddv: string, wqdv: string, wdmd: string, wqmd: string, wdam: string, wqam: string, wdmm: string, wqmm: string, xor: string, xori: string, newStoragePerByte: string, call: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, ccp: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, csiz: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, k256: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, ldc: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, logd: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, mcl: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, mcli: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, mcp: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, mcpi: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, meq: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, retd: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, s256: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, scwq: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, smo: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, srwq: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, swwq: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, contractRoot: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, stateRoot: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, vmInitialization: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string } };\n\nexport type GqlConsensusParametersFragmentFragment = { __typename: 'ConsensusParameters', baseAssetId: string, chainId: string, txParams: { __typename: 'TxParameters', maxInputs: any, maxOutputs: any, maxWitnesses: any, maxGasPerTx: string, maxSize: string }, predicateParams: { __typename: 'PredicateParameters', maxPredicateLength: string, maxPredicateDataLength: string, maxGasPerPredicate: string, maxMessageDataLength: string }, scriptParams: { __typename: 'ScriptParameters', maxScriptLength: string, maxScriptDataLength: string }, contractParams: { __typename: 'ContractParameters', contractMaxSize: string, maxStorageSlots: string }, feeParams: { __typename: 'FeeParameters', gasPriceFactor: string, gasPerByte: string }, gasCosts: { __typename: 'GasCosts', add: string, addi: string, aloc: string, and: string, andi: string, bal: string, bhei: string, bhsh: string, burn: string, cb: string, cfei: string, cfsi: string, croo: string, div: string, divi: string, ecr1: string, eck1: string, ed19: string, eq: string, exp: string, expi: string, flag: string, gm: string, gt: string, gtf: string, ji: string, jmp: string, jne: string, jnei: string, jnzi: string, jmpf: string, jmpb: string, jnzf: string, jnzb: string, jnef: string, jneb: string, lb: string, log: string, lt: string, lw: string, mint: string, mlog: string, modOp: string, modi: string, moveOp: string, movi: string, mroo: string, mul: string, muli: string, mldv: string, noop: string, not: string, or: string, ori: string, poph: string, popl: string, pshh: string, pshl: string, ret: string, rvrt: string, sb: string, sll: string, slli: string, srl: string, srli: string, srw: string, sub: string, subi: string, sw: string, sww: string, time: string, tr: string, tro: string, wdcm: string, wqcm: string, wdop: string, wqop: string, wdml: string, wqml: string, wddv: string, wqdv: string, wdmd: string, wqmd: string, wdam: string, wqam: string, wdmm: string, wqmm: string, xor: string, xori: string, newStoragePerByte: string, call: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, ccp: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, csiz: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, k256: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, ldc: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, logd: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, mcl: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, mcli: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, mcp: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, mcpi: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, meq: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, retd: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, s256: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, scwq: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, smo: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, srwq: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, swwq: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, contractRoot: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, stateRoot: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, vmInitialization: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string } } };\n\nexport type GqlChainInfoFragmentFragment = { __typename: 'ChainInfo', name: string, daHeight: string, latestBlock: { __typename: 'Block', id: string, header: { __typename: 'Header', height: any, time: any }, transactions: Array<{ __typename: 'Transaction', id: string }> }, consensusParameters: { __typename: 'ConsensusParameters', baseAssetId: string, chainId: string, txParams: { __typename: 'TxParameters', maxInputs: any, maxOutputs: any, maxWitnesses: any, maxGasPerTx: string, maxSize: string }, predicateParams: { __typename: 'PredicateParameters', maxPredicateLength: string, maxPredicateDataLength: string, maxGasPerPredicate: string, maxMessageDataLength: string }, scriptParams: { __typename: 'ScriptParameters', maxScriptLength: string, maxScriptDataLength: string }, contractParams: { __typename: 'ContractParameters', contractMaxSize: string, maxStorageSlots: string }, feeParams: { __typename: 'FeeParameters', gasPriceFactor: string, gasPerByte: string }, gasCosts: { __typename: 'GasCosts', add: string, addi: string, aloc: string, and: string, andi: string, bal: string, bhei: string, bhsh: string, burn: string, cb: string, cfei: string, cfsi: string, croo: string, div: string, divi: string, ecr1: string, eck1: string, ed19: string, eq: string, exp: string, expi: string, flag: string, gm: string, gt: string, gtf: string, ji: string, jmp: string, jne: string, jnei: string, jnzi: string, jmpf: string, jmpb: string, jnzf: string, jnzb: string, jnef: string, jneb: string, lb: string, log: string, lt: string, lw: string, mint: string, mlog: string, modOp: string, modi: string, moveOp: string, movi: string, mroo: string, mul: string, muli: string, mldv: string, noop: string, not: string, or: string, ori: string, poph: string, popl: string, pshh: string, pshl: string, ret: string, rvrt: string, sb: string, sll: string, slli: string, srl: string, srli: string, srw: string, sub: string, subi: string, sw: string, sww: string, time: string, tr: string, tro: string, wdcm: string, wqcm: string, wdop: string, wqop: string, wdml: string, wqml: string, wddv: string, wqdv: string, wdmd: string, wqmd: string, wdam: string, wqam: string, wdmm: string, wqmm: string, xor: string, xori: string, newStoragePerByte: string, call: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, ccp: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, csiz: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, k256: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, ldc: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, logd: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, mcl: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, mcli: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, mcp: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, mcpi: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, meq: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, retd: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, s256: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, scwq: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, smo: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, srwq: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, swwq: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, contractRoot: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, stateRoot: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, vmInitialization: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string } } } };\n\nexport type GqlContractBalanceFragmentFragment = { __typename: 'ContractBalance', contract: string, amount: string, assetId: string };\n\nexport type GqlPageInfoFragmentFragment = { __typename: 'PageInfo', hasPreviousPage: boolean, hasNextPage: boolean, startCursor?: string | null, endCursor?: string | null };\n\nexport type GqlGetVersionQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type GqlGetVersionQuery = { __typename: 'Query', nodeInfo: { __typename: 'NodeInfo', nodeVersion: string } };\n\nexport type GqlNodeInfoFragmentFragment = { __typename: 'NodeInfo', utxoValidation: boolean, vmBacktrace: boolean, minGasPrice: string, maxTx: string, maxDepth: string, nodeVersion: string, peers: Array<{ __typename: 'PeerInfo', id: string, addresses: Array<string>, clientVersion?: string | null, blockHeight?: any | null, lastHeartbeatMs: string, appScore: number }> };\n\nexport type GqlGetNodeInfoQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type GqlGetNodeInfoQuery = { __typename: 'Query', nodeInfo: { __typename: 'NodeInfo', utxoValidation: boolean, vmBacktrace: boolean, minGasPrice: string, maxTx: string, maxDepth: string, nodeVersion: string, peers: Array<{ __typename: 'PeerInfo', id: string, addresses: Array<string>, clientVersion?: string | null, blockHeight?: any | null, lastHeartbeatMs: string, appScore: number }> } };\n\nexport type GqlGetChainQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type GqlGetChainQuery = { __typename: 'Query', chain: { __typename: 'ChainInfo', name: string, daHeight: string, latestBlock: { __typename: 'Block', id: string, header: { __typename: 'Header', height: any, time: any }, transactions: Array<{ __typename: 'Transaction', id: string }> }, consensusParameters: { __typename: 'ConsensusParameters', baseAssetId: string, chainId: string, txParams: { __typename: 'TxParameters', maxInputs: any, maxOutputs: any, maxWitnesses: any, maxGasPerTx: string, maxSize: string }, predicateParams: { __typename: 'PredicateParameters', maxPredicateLength: string, maxPredicateDataLength: string, maxGasPerPredicate: string, maxMessageDataLength: string }, scriptParams: { __typename: 'ScriptParameters', maxScriptLength: string, maxScriptDataLength: string }, contractParams: { __typename: 'ContractParameters', contractMaxSize: string, maxStorageSlots: string }, feeParams: { __typename: 'FeeParameters', gasPriceFactor: string, gasPerByte: string }, gasCosts: { __typename: 'GasCosts', add: string, addi: string, aloc: string, and: string, andi: string, bal: string, bhei: string, bhsh: string, burn: string, cb: string, cfei: string, cfsi: string, croo: string, div: string, divi: string, ecr1: string, eck1: string, ed19: string, eq: string, exp: string, expi: string, flag: string, gm: string, gt: string, gtf: string, ji: string, jmp: string, jne: string, jnei: string, jnzi: string, jmpf: string, jmpb: string, jnzf: string, jnzb: string, jnef: string, jneb: string, lb: string, log: string, lt: string, lw: string, mint: string, mlog: string, modOp: string, modi: string, moveOp: string, movi: string, mroo: string, mul: string, muli: string, mldv: string, noop: string, not: string, or: string, ori: string, poph: string, popl: string, pshh: string, pshl: string, ret: string, rvrt: string, sb: string, sll: string, slli: string, srl: string, srli: string, srw: string, sub: string, subi: string, sw: string, sww: string, time: string, tr: string, tro: string, wdcm: string, wqcm: string, wdop: string, wqop: string, wdml: string, wqml: string, wddv: string, wqdv: string, wdmd: string, wqmd: string, wdam: string, wqam: string, wdmm: string, wqmm: string, xor: string, xori: string, newStoragePerByte: string, call: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, ccp: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, csiz: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, k256: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, ldc: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, logd: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, mcl: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, mcli: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, mcp: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, mcpi: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, meq: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, retd: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, s256: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, scwq: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, smo: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, srwq: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, swwq: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, contractRoot: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, stateRoot: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string }, vmInitialization: { __typename: 'HeavyOperation', base: string, gasPerUnit: string } | { __typename: 'LightOperation', base: string, unitsPerGas: string } } } } };\n\nexport type GqlGetTransactionQueryVariables = Exact<{\n  transactionId: Scalars['TransactionId'];\n}>;\n\n\nexport type GqlGetTransactionQuery = { __typename: 'Query', transaction?: { __typename: 'Transaction', id: string, rawPayload: string, gasPrice?: string | null, receipts?: Array<{ __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null }> | null, status?: { __typename: 'FailureStatus', time: any, reason: string, type: 'FailureStatus', block: { __typename: 'Block', id: string } } | { __typename: 'SqueezedOutStatus', type: 'SqueezedOutStatus' } | { __typename: 'SubmittedStatus', time: any, type: 'SubmittedStatus' } | { __typename: 'SuccessStatus', time: any, type: 'SuccessStatus', block: { __typename: 'Block', id: string }, programState?: { __typename: 'ProgramState', returnType: GqlReturnType, data: string } | null } | null } | null };\n\nexport type GqlGetTransactionWithReceiptsQueryVariables = Exact<{\n  transactionId: Scalars['TransactionId'];\n}>;\n\n\nexport type GqlGetTransactionWithReceiptsQuery = { __typename: 'Query', transaction?: { __typename: 'Transaction', id: string, rawPayload: string, gasPrice?: string | null, receipts?: Array<{ __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null }> | null, status?: { __typename: 'FailureStatus', time: any, reason: string, type: 'FailureStatus', block: { __typename: 'Block', id: string } } | { __typename: 'SqueezedOutStatus', type: 'SqueezedOutStatus' } | { __typename: 'SubmittedStatus', time: any, type: 'SubmittedStatus' } | { __typename: 'SuccessStatus', time: any, type: 'SuccessStatus', block: { __typename: 'Block', id: string }, programState?: { __typename: 'ProgramState', returnType: GqlReturnType, data: string } | null } | null } | null };\n\nexport type GqlGetTransactionsQueryVariables = Exact<{\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\n\nexport type GqlGetTransactionsQuery = { __typename: 'Query', transactions: { __typename: 'TransactionConnection', edges: Array<{ __typename: 'TransactionEdge', node: { __typename: 'Transaction', id: string, rawPayload: string, gasPrice?: string | null, receipts?: Array<{ __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null }> | null, status?: { __typename: 'FailureStatus', time: any, reason: string, type: 'FailureStatus', block: { __typename: 'Block', id: string } } | { __typename: 'SqueezedOutStatus', type: 'SqueezedOutStatus' } | { __typename: 'SubmittedStatus', time: any, type: 'SubmittedStatus' } | { __typename: 'SuccessStatus', time: any, type: 'SuccessStatus', block: { __typename: 'Block', id: string }, programState?: { __typename: 'ProgramState', returnType: GqlReturnType, data: string } | null } | null } }> } };\n\nexport type GqlGetTransactionsByOwnerQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\n\nexport type GqlGetTransactionsByOwnerQuery = { __typename: 'Query', transactionsByOwner: { __typename: 'TransactionConnection', pageInfo: { __typename: 'PageInfo', hasPreviousPage: boolean, hasNextPage: boolean, startCursor?: string | null, endCursor?: string | null }, edges: Array<{ __typename: 'TransactionEdge', node: { __typename: 'Transaction', id: string, rawPayload: string, gasPrice?: string | null, receipts?: Array<{ __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null }> | null, status?: { __typename: 'FailureStatus', time: any, reason: string, type: 'FailureStatus', block: { __typename: 'Block', id: string } } | { __typename: 'SqueezedOutStatus', type: 'SqueezedOutStatus' } | { __typename: 'SubmittedStatus', time: any, type: 'SubmittedStatus' } | { __typename: 'SuccessStatus', time: any, type: 'SuccessStatus', block: { __typename: 'Block', id: string }, programState?: { __typename: 'ProgramState', returnType: GqlReturnType, data: string } | null } | null } }> } };\n\nexport type GqlEstimatePredicatesQueryVariables = Exact<{\n  encodedTransaction: Scalars['HexString'];\n}>;\n\n\nexport type GqlEstimatePredicatesQuery = { __typename: 'Query', estimatePredicates: { __typename: 'Transaction', id: string, rawPayload: string, gasPrice?: string | null, receipts?: Array<{ __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null }> | null, status?: { __typename: 'FailureStatus', time: any, reason: string, type: 'FailureStatus', block: { __typename: 'Block', id: string } } | { __typename: 'SqueezedOutStatus', type: 'SqueezedOutStatus' } | { __typename: 'SubmittedStatus', time: any, type: 'SubmittedStatus' } | { __typename: 'SuccessStatus', time: any, type: 'SuccessStatus', block: { __typename: 'Block', id: string }, programState?: { __typename: 'ProgramState', returnType: GqlReturnType, data: string } | null } | null } };\n\nexport type GqlGetBlockQueryVariables = Exact<{\n  blockId?: InputMaybe<Scalars['BlockId']>;\n  height?: InputMaybe<Scalars['U32']>;\n}>;\n\n\nexport type GqlGetBlockQuery = { __typename: 'Query', block?: { __typename: 'Block', id: string, header: { __typename: 'Header', height: any, time: any }, transactions: Array<{ __typename: 'Transaction', id: string }> } | null };\n\nexport type GqlGetBlockWithTransactionsQueryVariables = Exact<{\n  blockId?: InputMaybe<Scalars['BlockId']>;\n  blockHeight?: InputMaybe<Scalars['U32']>;\n}>;\n\n\nexport type GqlGetBlockWithTransactionsQuery = { __typename: 'Query', block?: { __typename: 'Block', id: string, transactions: Array<{ __typename: 'Transaction', id: string, rawPayload: string, gasPrice?: string | null, receipts?: Array<{ __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null }> | null, status?: { __typename: 'FailureStatus', time: any, reason: string, type: 'FailureStatus', block: { __typename: 'Block', id: string } } | { __typename: 'SqueezedOutStatus', type: 'SqueezedOutStatus' } | { __typename: 'SubmittedStatus', time: any, type: 'SubmittedStatus' } | { __typename: 'SuccessStatus', time: any, type: 'SuccessStatus', block: { __typename: 'Block', id: string }, programState?: { __typename: 'ProgramState', returnType: GqlReturnType, data: string } | null } | null }>, header: { __typename: 'Header', height: any, time: any } } | null };\n\nexport type GqlGetBlocksQueryVariables = Exact<{\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\n\nexport type GqlGetBlocksQuery = { __typename: 'Query', blocks: { __typename: 'BlockConnection', edges: Array<{ __typename: 'BlockEdge', node: { __typename: 'Block', id: string, header: { __typename: 'Header', height: any, time: any }, transactions: Array<{ __typename: 'Transaction', id: string }> } }> } };\n\nexport type GqlGetCoinQueryVariables = Exact<{\n  coinId: Scalars['UtxoId'];\n}>;\n\n\nexport type GqlGetCoinQuery = { __typename: 'Query', coin?: { __typename: 'Coin', utxoId: string, owner: string, amount: string, assetId: string, maturity: any, blockCreated: any, txCreatedIdx: string } | null };\n\nexport type GqlGetCoinsQueryVariables = Exact<{\n  filter: GqlCoinFilterInput;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\n\nexport type GqlGetCoinsQuery = { __typename: 'Query', coins: { __typename: 'CoinConnection', edges: Array<{ __typename: 'CoinEdge', node: { __typename: 'Coin', utxoId: string, owner: string, amount: string, assetId: string, maturity: any, blockCreated: any, txCreatedIdx: string } }> } };\n\nexport type GqlGetCoinsToSpendQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  queryPerAsset: Array<GqlSpendQueryElementInput> | GqlSpendQueryElementInput;\n  excludedIds?: InputMaybe<GqlExcludeInput>;\n}>;\n\n\nexport type GqlGetCoinsToSpendQuery = { __typename: 'Query', coinsToSpend: Array<Array<{ __typename: 'Coin', utxoId: string, owner: string, amount: string, assetId: string, maturity: any, blockCreated: any, txCreatedIdx: string } | { __typename: 'MessageCoin', sender: string, recipient: string, nonce: string, amount: string, assetId: string, daHeight: string }>> };\n\nexport type GqlGetContractQueryVariables = Exact<{\n  contractId: Scalars['ContractId'];\n}>;\n\n\nexport type GqlGetContractQuery = { __typename: 'Query', contract?: { __typename: 'Contract', bytecode: string, id: string } | null };\n\nexport type GqlGetContractBalanceQueryVariables = Exact<{\n  contract: Scalars['ContractId'];\n  asset: Scalars['AssetId'];\n}>;\n\n\nexport type GqlGetContractBalanceQuery = { __typename: 'Query', contractBalance: { __typename: 'ContractBalance', contract: string, amount: string, assetId: string } };\n\nexport type GqlGetBalanceQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  assetId: Scalars['AssetId'];\n}>;\n\n\nexport type GqlGetBalanceQuery = { __typename: 'Query', balance: { __typename: 'Balance', owner: string, amount: string, assetId: string } };\n\nexport type GqlGetBalancesQueryVariables = Exact<{\n  filter: GqlBalanceFilterInput;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\n\nexport type GqlGetBalancesQuery = { __typename: 'Query', balances: { __typename: 'BalanceConnection', edges: Array<{ __typename: 'BalanceEdge', node: { __typename: 'Balance', owner: string, amount: string, assetId: string } }> } };\n\nexport type GqlGetMessagesQueryVariables = Exact<{\n  owner: Scalars['Address'];\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n}>;\n\n\nexport type GqlGetMessagesQuery = { __typename: 'Query', messages: { __typename: 'MessageConnection', edges: Array<{ __typename: 'MessageEdge', node: { __typename: 'Message', amount: string, sender: string, recipient: string, data: string, nonce: string, daHeight: string } }> } };\n\nexport type GqlGetMessageProofQueryVariables = Exact<{\n  transactionId: Scalars['TransactionId'];\n  nonce: Scalars['Nonce'];\n  commitBlockId?: InputMaybe<Scalars['BlockId']>;\n  commitBlockHeight?: InputMaybe<Scalars['U32']>;\n}>;\n\n\nexport type GqlGetMessageProofQuery = { __typename: 'Query', messageProof?: { __typename: 'MessageProof', sender: string, recipient: string, nonce: string, amount: string, data: string, messageProof: { __typename: 'MerkleProof', proofSet: Array<string>, proofIndex: string }, blockProof: { __typename: 'MerkleProof', proofSet: Array<string>, proofIndex: string }, messageBlockHeader: { __typename: 'Header', id: string, daHeight: string, transactionsCount: string, transactionsRoot: string, height: any, prevRoot: string, time: any, applicationHash: string, messageReceiptRoot: string, messageReceiptCount: string }, commitBlockHeader: { __typename: 'Header', id: string, daHeight: string, transactionsCount: string, transactionsRoot: string, height: any, prevRoot: string, time: any, applicationHash: string, messageReceiptRoot: string, messageReceiptCount: string } } | null };\n\nexport type GqlGetMessageStatusQueryVariables = Exact<{\n  nonce: Scalars['Nonce'];\n}>;\n\n\nexport type GqlGetMessageStatusQuery = { __typename: 'Query', messageStatus: { __typename: 'MessageStatus', state: GqlMessageState } };\n\nexport type GqlDryRunMutationVariables = Exact<{\n  encodedTransaction: Scalars['HexString'];\n  utxoValidation?: InputMaybe<Scalars['Boolean']>;\n}>;\n\n\nexport type GqlDryRunMutation = { __typename: 'Mutation', dryRun: Array<{ __typename: 'Receipt', pc?: string | null, is?: string | null, toAddress?: string | null, amount?: string | null, assetId?: string | null, gas?: string | null, param1?: string | null, param2?: string | null, val?: string | null, ptr?: string | null, digest?: string | null, reason?: string | null, ra?: string | null, rb?: string | null, rc?: string | null, rd?: string | null, len?: string | null, receiptType: GqlReceiptType, result?: string | null, gasUsed?: string | null, data?: string | null, sender?: string | null, recipient?: string | null, nonce?: string | null, contractId?: string | null, subId?: string | null, contract?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null, to?: { __typename: 'Contract', id: string, bytecode: string, salt: string } | null }> };\n\nexport type GqlSubmitMutationVariables = Exact<{\n  encodedTransaction: Scalars['HexString'];\n}>;\n\n\nexport type GqlSubmitMutation = { __typename: 'Mutation', submit: { __typename: 'Transaction', id: string } };\n\nexport type GqlProduceBlocksMutationVariables = Exact<{\n  startTimestamp?: InputMaybe<Scalars['Tai64Timestamp']>;\n  blocksToProduce: Scalars['U32'];\n}>;\n\n\nexport type GqlProduceBlocksMutation = { __typename: 'Mutation', produceBlocks: any };\n\nexport const ReceiptFragmentFragmentDoc = gql`\n    fragment receiptFragment on Receipt {\n  contract {\n    id\n    bytecode\n    salt\n  }\n  pc\n  is\n  to {\n    id\n    bytecode\n    salt\n  }\n  toAddress\n  amount\n  assetId\n  gas\n  param1\n  param2\n  val\n  ptr\n  digest\n  reason\n  ra\n  rb\n  rc\n  rd\n  len\n  receiptType\n  result\n  gasUsed\n  data\n  sender\n  recipient\n  nonce\n  contractId\n  subId\n}\n    `;\nexport const TransactionFragmentFragmentDoc = gql`\n    fragment transactionFragment on Transaction {\n  id\n  rawPayload\n  gasPrice\n  receipts {\n    ...receiptFragment\n  }\n  status {\n    type: __typename\n    ... on SubmittedStatus {\n      time\n    }\n    ... on SuccessStatus {\n      block {\n        id\n      }\n      time\n      programState {\n        returnType\n        data\n      }\n    }\n    ... on FailureStatus {\n      block {\n        id\n      }\n      time\n      reason\n    }\n  }\n}\n    ${ReceiptFragmentFragmentDoc}`;\nexport const CoinFragmentFragmentDoc = gql`\n    fragment coinFragment on Coin {\n  __typename\n  utxoId\n  owner\n  amount\n  assetId\n  maturity\n  blockCreated\n  txCreatedIdx\n}\n    `;\nexport const MessageCoinFragmentFragmentDoc = gql`\n    fragment messageCoinFragment on MessageCoin {\n  __typename\n  sender\n  recipient\n  nonce\n  amount\n  assetId\n  daHeight\n}\n    `;\nexport const MessageFragmentFragmentDoc = gql`\n    fragment messageFragment on Message {\n  amount\n  sender\n  recipient\n  data\n  nonce\n  daHeight\n}\n    `;\nexport const MessageProofFragmentFragmentDoc = gql`\n    fragment messageProofFragment on MessageProof {\n  messageProof {\n    proofSet\n    proofIndex\n  }\n  blockProof {\n    proofSet\n    proofIndex\n  }\n  messageBlockHeader {\n    id\n    daHeight\n    transactionsCount\n    transactionsRoot\n    height\n    prevRoot\n    time\n    applicationHash\n    messageReceiptRoot\n    messageReceiptCount\n  }\n  commitBlockHeader {\n    id\n    daHeight\n    transactionsCount\n    transactionsRoot\n    height\n    prevRoot\n    time\n    applicationHash\n    messageReceiptRoot\n    messageReceiptCount\n  }\n  sender\n  recipient\n  nonce\n  amount\n  data\n}\n    `;\nexport const BalanceFragmentFragmentDoc = gql`\n    fragment balanceFragment on Balance {\n  owner\n  amount\n  assetId\n}\n    `;\nexport const BlockFragmentFragmentDoc = gql`\n    fragment blockFragment on Block {\n  id\n  header {\n    height\n    time\n  }\n  transactions {\n    id\n  }\n}\n    `;\nexport const TxParametersFragmentFragmentDoc = gql`\n    fragment TxParametersFragment on TxParameters {\n  maxInputs\n  maxOutputs\n  maxWitnesses\n  maxGasPerTx\n  maxSize\n}\n    `;\nexport const PredicateParametersFragmentFragmentDoc = gql`\n    fragment PredicateParametersFragment on PredicateParameters {\n  maxPredicateLength\n  maxPredicateDataLength\n  maxGasPerPredicate\n  maxMessageDataLength\n}\n    `;\nexport const ScriptParametersFragmentFragmentDoc = gql`\n    fragment ScriptParametersFragment on ScriptParameters {\n  maxScriptLength\n  maxScriptDataLength\n}\n    `;\nexport const ContractParametersFragmentFragmentDoc = gql`\n    fragment ContractParametersFragment on ContractParameters {\n  contractMaxSize\n  maxStorageSlots\n}\n    `;\nexport const FeeParametersFragmentFragmentDoc = gql`\n    fragment FeeParametersFragment on FeeParameters {\n  gasPriceFactor\n  gasPerByte\n}\n    `;\nexport const DependentCostFragmentFragmentDoc = gql`\n    fragment DependentCostFragment on DependentCost {\n  __typename\n  ... on LightOperation {\n    base\n    unitsPerGas\n  }\n  ... on HeavyOperation {\n    base\n    gasPerUnit\n  }\n}\n    `;\nexport const GasCostsFragmentFragmentDoc = gql`\n    fragment GasCostsFragment on GasCosts {\n  add\n  addi\n  aloc\n  and\n  andi\n  bal\n  bhei\n  bhsh\n  burn\n  cb\n  cfei\n  cfsi\n  croo\n  div\n  divi\n  ecr1\n  eck1\n  ed19\n  eq\n  exp\n  expi\n  flag\n  gm\n  gt\n  gtf\n  ji\n  jmp\n  jne\n  jnei\n  jnzi\n  jmpf\n  jmpb\n  jnzf\n  jnzb\n  jnef\n  jneb\n  lb\n  log\n  lt\n  lw\n  mint\n  mlog\n  modOp\n  modi\n  moveOp\n  movi\n  mroo\n  mul\n  muli\n  mldv\n  noop\n  not\n  or\n  ori\n  poph\n  popl\n  pshh\n  pshl\n  ret\n  rvrt\n  sb\n  sll\n  slli\n  srl\n  srli\n  srw\n  sub\n  subi\n  sw\n  sww\n  time\n  tr\n  tro\n  wdcm\n  wqcm\n  wdop\n  wqop\n  wdml\n  wqml\n  wddv\n  wqdv\n  wdmd\n  wqmd\n  wdam\n  wqam\n  wdmm\n  wqmm\n  xor\n  xori\n  call {\n    ...DependentCostFragment\n  }\n  ccp {\n    ...DependentCostFragment\n  }\n  csiz {\n    ...DependentCostFragment\n  }\n  k256 {\n    ...DependentCostFragment\n  }\n  ldc {\n    ...DependentCostFragment\n  }\n  logd {\n    ...DependentCostFragment\n  }\n  mcl {\n    ...DependentCostFragment\n  }\n  mcli {\n    ...DependentCostFragment\n  }\n  mcp {\n    ...DependentCostFragment\n  }\n  mcpi {\n    ...DependentCostFragment\n  }\n  meq {\n    ...DependentCostFragment\n  }\n  retd {\n    ...DependentCostFragment\n  }\n  s256 {\n    ...DependentCostFragment\n  }\n  scwq {\n    ...DependentCostFragment\n  }\n  smo {\n    ...DependentCostFragment\n  }\n  srwq {\n    ...DependentCostFragment\n  }\n  swwq {\n    ...DependentCostFragment\n  }\n  contractRoot {\n    ...DependentCostFragment\n  }\n  stateRoot {\n    ...DependentCostFragment\n  }\n  vmInitialization {\n    ...DependentCostFragment\n  }\n  newStoragePerByte\n}\n    ${DependentCostFragmentFragmentDoc}`;\nexport const ConsensusParametersFragmentFragmentDoc = gql`\n    fragment consensusParametersFragment on ConsensusParameters {\n  txParams {\n    ...TxParametersFragment\n  }\n  predicateParams {\n    ...PredicateParametersFragment\n  }\n  scriptParams {\n    ...ScriptParametersFragment\n  }\n  contractParams {\n    ...ContractParametersFragment\n  }\n  feeParams {\n    ...FeeParametersFragment\n  }\n  gasCosts {\n    ...GasCostsFragment\n  }\n  baseAssetId\n  chainId\n}\n    ${TxParametersFragmentFragmentDoc}\n${PredicateParametersFragmentFragmentDoc}\n${ScriptParametersFragmentFragmentDoc}\n${ContractParametersFragmentFragmentDoc}\n${FeeParametersFragmentFragmentDoc}\n${GasCostsFragmentFragmentDoc}`;\nexport const ChainInfoFragmentFragmentDoc = gql`\n    fragment chainInfoFragment on ChainInfo {\n  name\n  latestBlock {\n    ...blockFragment\n  }\n  daHeight\n  consensusParameters {\n    ...consensusParametersFragment\n  }\n}\n    ${BlockFragmentFragmentDoc}\n${ConsensusParametersFragmentFragmentDoc}`;\nexport const ContractBalanceFragmentFragmentDoc = gql`\n    fragment contractBalanceFragment on ContractBalance {\n  contract\n  amount\n  assetId\n}\n    `;\nexport const PageInfoFragmentFragmentDoc = gql`\n    fragment pageInfoFragment on PageInfo {\n  hasPreviousPage\n  hasNextPage\n  startCursor\n  endCursor\n}\n    `;\nexport const NodeInfoFragmentFragmentDoc = gql`\n    fragment nodeInfoFragment on NodeInfo {\n  utxoValidation\n  vmBacktrace\n  minGasPrice\n  maxTx\n  maxDepth\n  nodeVersion\n  peers {\n    id\n    addresses\n    clientVersion\n    blockHeight\n    lastHeartbeatMs\n    appScore\n  }\n}\n    `;\nexport const GetVersionDocument = gql`\n    query getVersion {\n  nodeInfo {\n    nodeVersion\n  }\n}\n    `;\nexport const GetNodeInfoDocument = gql`\n    query getNodeInfo {\n  nodeInfo {\n    ...nodeInfoFragment\n  }\n}\n    ${NodeInfoFragmentFragmentDoc}`;\nexport const GetChainDocument = gql`\n    query getChain {\n  chain {\n    ...chainInfoFragment\n  }\n}\n    ${ChainInfoFragmentFragmentDoc}`;\nexport const GetTransactionDocument = gql`\n    query getTransaction($transactionId: TransactionId!) {\n  transaction(id: $transactionId) {\n    ...transactionFragment\n  }\n}\n    ${TransactionFragmentFragmentDoc}`;\nexport const GetTransactionWithReceiptsDocument = gql`\n    query getTransactionWithReceipts($transactionId: TransactionId!) {\n  transaction(id: $transactionId) {\n    ...transactionFragment\n    receipts {\n      ...receiptFragment\n    }\n  }\n}\n    ${TransactionFragmentFragmentDoc}\n${ReceiptFragmentFragmentDoc}`;\nexport const GetTransactionsDocument = gql`\n    query getTransactions($after: String, $before: String, $first: Int, $last: Int) {\n  transactions(after: $after, before: $before, first: $first, last: $last) {\n    edges {\n      node {\n        ...transactionFragment\n      }\n    }\n  }\n}\n    ${TransactionFragmentFragmentDoc}`;\nexport const GetTransactionsByOwnerDocument = gql`\n    query getTransactionsByOwner($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {\n  transactionsByOwner(\n    owner: $owner\n    after: $after\n    before: $before\n    first: $first\n    last: $last\n  ) {\n    pageInfo {\n      ...pageInfoFragment\n    }\n    edges {\n      node {\n        ...transactionFragment\n      }\n    }\n  }\n}\n    ${PageInfoFragmentFragmentDoc}\n${TransactionFragmentFragmentDoc}`;\nexport const EstimatePredicatesDocument = gql`\n    query estimatePredicates($encodedTransaction: HexString!) {\n  estimatePredicates(tx: $encodedTransaction) {\n    ...transactionFragment\n  }\n}\n    ${TransactionFragmentFragmentDoc}`;\nexport const GetBlockDocument = gql`\n    query getBlock($blockId: BlockId, $height: U32) {\n  block(id: $blockId, height: $height) {\n    ...blockFragment\n  }\n}\n    ${BlockFragmentFragmentDoc}`;\nexport const GetBlockWithTransactionsDocument = gql`\n    query getBlockWithTransactions($blockId: BlockId, $blockHeight: U32) {\n  block(id: $blockId, height: $blockHeight) {\n    ...blockFragment\n    transactions {\n      ...transactionFragment\n    }\n  }\n}\n    ${BlockFragmentFragmentDoc}\n${TransactionFragmentFragmentDoc}`;\nexport const GetBlocksDocument = gql`\n    query getBlocks($after: String, $before: String, $first: Int, $last: Int) {\n  blocks(after: $after, before: $before, first: $first, last: $last) {\n    edges {\n      node {\n        ...blockFragment\n      }\n    }\n  }\n}\n    ${BlockFragmentFragmentDoc}`;\nexport const GetCoinDocument = gql`\n    query getCoin($coinId: UtxoId!) {\n  coin(utxoId: $coinId) {\n    ...coinFragment\n  }\n}\n    ${CoinFragmentFragmentDoc}`;\nexport const GetCoinsDocument = gql`\n    query getCoins($filter: CoinFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {\n  coins(\n    filter: $filter\n    after: $after\n    before: $before\n    first: $first\n    last: $last\n  ) {\n    edges {\n      node {\n        ...coinFragment\n      }\n    }\n  }\n}\n    ${CoinFragmentFragmentDoc}`;\nexport const GetCoinsToSpendDocument = gql`\n    query getCoinsToSpend($owner: Address!, $queryPerAsset: [SpendQueryElementInput!]!, $excludedIds: ExcludeInput) {\n  coinsToSpend(\n    owner: $owner\n    queryPerAsset: $queryPerAsset\n    excludedIds: $excludedIds\n  ) {\n    ...coinFragment\n    ...messageCoinFragment\n  }\n}\n    ${CoinFragmentFragmentDoc}\n${MessageCoinFragmentFragmentDoc}`;\nexport const GetContractDocument = gql`\n    query getContract($contractId: ContractId!) {\n  contract(id: $contractId) {\n    bytecode\n    id\n  }\n}\n    `;\nexport const GetContractBalanceDocument = gql`\n    query getContractBalance($contract: ContractId!, $asset: AssetId!) {\n  contractBalance(contract: $contract, asset: $asset) {\n    ...contractBalanceFragment\n  }\n}\n    ${ContractBalanceFragmentFragmentDoc}`;\nexport const GetBalanceDocument = gql`\n    query getBalance($owner: Address!, $assetId: AssetId!) {\n  balance(owner: $owner, assetId: $assetId) {\n    ...balanceFragment\n  }\n}\n    ${BalanceFragmentFragmentDoc}`;\nexport const GetBalancesDocument = gql`\n    query getBalances($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {\n  balances(\n    filter: $filter\n    after: $after\n    before: $before\n    first: $first\n    last: $last\n  ) {\n    edges {\n      node {\n        ...balanceFragment\n      }\n    }\n  }\n}\n    ${BalanceFragmentFragmentDoc}`;\nexport const GetMessagesDocument = gql`\n    query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {\n  messages(\n    owner: $owner\n    after: $after\n    before: $before\n    first: $first\n    last: $last\n  ) {\n    edges {\n      node {\n        ...messageFragment\n      }\n    }\n  }\n}\n    ${MessageFragmentFragmentDoc}`;\nexport const GetMessageProofDocument = gql`\n    query getMessageProof($transactionId: TransactionId!, $nonce: Nonce!, $commitBlockId: BlockId, $commitBlockHeight: U32) {\n  messageProof(\n    transactionId: $transactionId\n    nonce: $nonce\n    commitBlockId: $commitBlockId\n    commitBlockHeight: $commitBlockHeight\n  ) {\n    ...messageProofFragment\n  }\n}\n    ${MessageProofFragmentFragmentDoc}`;\nexport const GetMessageStatusDocument = gql`\n    query getMessageStatus($nonce: Nonce!) {\n  messageStatus(nonce: $nonce) {\n    state\n  }\n}\n    `;\nexport const DryRunDocument = gql`\n    mutation dryRun($encodedTransaction: HexString!, $utxoValidation: Boolean) {\n  dryRun(tx: $encodedTransaction, utxoValidation: $utxoValidation) {\n    ...receiptFragment\n  }\n}\n    ${ReceiptFragmentFragmentDoc}`;\nexport const SubmitDocument = gql`\n    mutation submit($encodedTransaction: HexString!) {\n  submit(tx: $encodedTransaction) {\n    id\n  }\n}\n    `;\nexport const ProduceBlocksDocument = gql`\n    mutation produceBlocks($startTimestamp: Tai64Timestamp, $blocksToProduce: U32!) {\n  produceBlocks(\n    blocksToProduce: $blocksToProduce\n    startTimestamp: $startTimestamp\n  )\n}\n    `;\n\nexport type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string, operationType?: string) => Promise<T>;\n\n\nconst defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType) => action();\n\nexport function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {\n  return {\n    getVersion(variables?: GqlGetVersionQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetVersionQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetVersionQuery>(GetVersionDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getVersion', 'query');\n    },\n    getNodeInfo(variables?: GqlGetNodeInfoQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetNodeInfoQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetNodeInfoQuery>(GetNodeInfoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getNodeInfo', 'query');\n    },\n    getChain(variables?: GqlGetChainQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetChainQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetChainQuery>(GetChainDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getChain', 'query');\n    },\n    getTransaction(variables: GqlGetTransactionQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetTransactionQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetTransactionQuery>(GetTransactionDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getTransaction', 'query');\n    },\n    getTransactionWithReceipts(variables: GqlGetTransactionWithReceiptsQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetTransactionWithReceiptsQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetTransactionWithReceiptsQuery>(GetTransactionWithReceiptsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getTransactionWithReceipts', 'query');\n    },\n    getTransactions(variables?: GqlGetTransactionsQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetTransactionsQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetTransactionsQuery>(GetTransactionsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getTransactions', 'query');\n    },\n    getTransactionsByOwner(variables: GqlGetTransactionsByOwnerQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetTransactionsByOwnerQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetTransactionsByOwnerQuery>(GetTransactionsByOwnerDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getTransactionsByOwner', 'query');\n    },\n    estimatePredicates(variables: GqlEstimatePredicatesQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlEstimatePredicatesQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlEstimatePredicatesQuery>(EstimatePredicatesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'estimatePredicates', 'query');\n    },\n    getBlock(variables?: GqlGetBlockQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetBlockQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetBlockQuery>(GetBlockDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getBlock', 'query');\n    },\n    getBlockWithTransactions(variables?: GqlGetBlockWithTransactionsQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetBlockWithTransactionsQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetBlockWithTransactionsQuery>(GetBlockWithTransactionsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getBlockWithTransactions', 'query');\n    },\n    getBlocks(variables?: GqlGetBlocksQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetBlocksQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetBlocksQuery>(GetBlocksDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getBlocks', 'query');\n    },\n    getCoin(variables: GqlGetCoinQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetCoinQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetCoinQuery>(GetCoinDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCoin', 'query');\n    },\n    getCoins(variables: GqlGetCoinsQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetCoinsQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetCoinsQuery>(GetCoinsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCoins', 'query');\n    },\n    getCoinsToSpend(variables: GqlGetCoinsToSpendQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetCoinsToSpendQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetCoinsToSpendQuery>(GetCoinsToSpendDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCoinsToSpend', 'query');\n    },\n    getContract(variables: GqlGetContractQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetContractQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetContractQuery>(GetContractDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getContract', 'query');\n    },\n    getContractBalance(variables: GqlGetContractBalanceQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetContractBalanceQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetContractBalanceQuery>(GetContractBalanceDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getContractBalance', 'query');\n    },\n    getBalance(variables: GqlGetBalanceQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetBalanceQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetBalanceQuery>(GetBalanceDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getBalance', 'query');\n    },\n    getBalances(variables: GqlGetBalancesQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetBalancesQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetBalancesQuery>(GetBalancesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getBalances', 'query');\n    },\n    getMessages(variables: GqlGetMessagesQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetMessagesQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetMessagesQuery>(GetMessagesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getMessages', 'query');\n    },\n    getMessageProof(variables: GqlGetMessageProofQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetMessageProofQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetMessageProofQuery>(GetMessageProofDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getMessageProof', 'query');\n    },\n    getMessageStatus(variables: GqlGetMessageStatusQueryVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlGetMessageStatusQuery> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlGetMessageStatusQuery>(GetMessageStatusDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getMessageStatus', 'query');\n    },\n    dryRun(variables: GqlDryRunMutationVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlDryRunMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlDryRunMutation>(DryRunDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'dryRun', 'mutation');\n    },\n    submit(variables: GqlSubmitMutationVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlSubmitMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlSubmitMutation>(SubmitDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'submit', 'mutation');\n    },\n    produceBlocks(variables: GqlProduceBlocksMutationVariables, requestHeaders?: Dom.RequestInit[\"headers\"]): Promise<GqlProduceBlocksMutation> {\n      return withWrapper((wrappedRequestHeaders) => client.request<GqlProduceBlocksMutation>(ProduceBlocksDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'produceBlocks', 'mutation');\n    }\n  };\n}\nexport type Sdk = ReturnType<typeof getSdk>;","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { hexlify } from 'ethers';\nimport type { BytesLike } from 'ethers';\n\ntype Cache = {\n  [key: string]: {\n    expires: number;\n    value: BytesLike;\n  };\n};\nconst cache: Cache = {}; // it's a cache hash ~~> cash?\n\nconst DEFAULT_TTL_IN_MS = 30 * 1000; // 30seconds\n\nexport class MemoryCache {\n  ttl: number;\n  constructor(ttlInMs: number = DEFAULT_TTL_IN_MS) {\n    this.ttl = ttlInMs;\n\n    if (typeof ttlInMs !== 'number' || this.ttl <= 0) {\n      throw new FuelError(\n        ErrorCode.INVALID_TTL,\n        `Invalid TTL: ${this.ttl}. Use a value greater than zero.`\n      );\n    }\n  }\n\n  get(value: BytesLike, isAutoExpiring = true): BytesLike | undefined {\n    const key = hexlify(value);\n    if (cache[key]) {\n      if (!isAutoExpiring || cache[key].expires > Date.now()) {\n        return cache[key].value;\n      }\n\n      this.del(value);\n    }\n\n    return undefined;\n  }\n\n  set(value: BytesLike): number {\n    const expiresAt = Date.now() + this.ttl;\n    const key = hexlify(value);\n    cache[key] = {\n      expires: expiresAt,\n      value,\n    };\n\n    return expiresAt;\n  }\n\n  getAllData(): BytesLike[] {\n    return Object.keys(cache).reduce((list, key) => {\n      const data = this.get(key, false);\n      if (data) {\n        list.push(data);\n      }\n\n      return list;\n    }, [] as BytesLike[]);\n  }\n\n  getActiveData(): BytesLike[] {\n    return Object.keys(cache).reduce((list, key) => {\n      const data = this.get(key);\n      if (data) {\n        list.push(data);\n      }\n\n      return list;\n    }, [] as BytesLike[]);\n  }\n\n  del(value: BytesLike) {\n    const key = hexlify(value);\n    delete cache[key];\n  }\n}\n","import { ZeroBytes32 } from '@fuel-ts/address/configs';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BigNumberish } from '@fuel-ts/math';\nimport { bn, toNumber } from '@fuel-ts/math';\nimport type { Input } from '@fuel-ts/transactions';\nimport { InputType } from '@fuel-ts/transactions';\nimport { getBytesCopy, hexlify } from 'ethers';\nimport type { BytesLike } from 'ethers';\n\nexport type CoinTransactionRequestInput = {\n  type: InputType.Coin;\n\n  /** UTXO ID */\n  id: BytesLike;\n\n  /** Owning address or script hash */\n  owner: BytesLike;\n\n  /** Amount of coins */\n  amount: BigNumberish;\n\n  /** Asset ID of the coins */\n  assetId: BytesLike;\n\n  /** Points to the TX whose output is being spent. (TxPointer) */\n  txPointer: BytesLike;\n\n  /** Index of witness that authorizes spending the coin */\n  witnessIndex: number;\n\n  /** UTXO being spent must have been created at least this many blocks ago */\n  maturity?: number;\n\n  /** Gas used by predicate */\n  predicateGasUsed?: BigNumberish;\n\n  /** Predicate bytecode */\n  predicate?: BytesLike;\n\n  /** Predicate input data (parameters) */\n  predicateData?: BytesLike;\n};\n\nexport type MessageTransactionRequestInput = {\n  type: InputType.Message;\n\n  /** Address of sender */\n  sender: BytesLike;\n\n  /** Address of recipient */\n  recipient: BytesLike;\n\n  /** Amount of coins */\n  amount: BigNumberish;\n\n  /** Index of witness that authorizes the message */\n  witnessIndex: number;\n\n  /** Unique nonce of message */\n  nonce: BytesLike;\n\n  /** Gas used by predicate */\n  predicateGasUsed?: BigNumberish;\n\n  /** Predicate bytecode */\n  predicate?: BytesLike;\n\n  /** Predicate input data (parameters) */\n  predicateData?: BytesLike;\n\n  /** data of message */\n  data?: BytesLike;\n};\n\nexport type ContractTransactionRequestInput = {\n  type: InputType.Contract;\n\n  /** Points to the TX whose output is being spent. (TxPointer) */\n  txPointer: BytesLike;\n\n  /** Contract ID */\n  contractId: BytesLike;\n};\nexport type TransactionRequestInput =\n  | CoinTransactionRequestInput\n  | ContractTransactionRequestInput\n  | MessageTransactionRequestInput;\n\n/** @hidden */\nexport const inputify = (value: TransactionRequestInput): Input => {\n  const { type } = value;\n\n  switch (value.type) {\n    case InputType.Coin: {\n      const predicate = getBytesCopy(value.predicate ?? '0x');\n      const predicateData = getBytesCopy(value.predicateData ?? '0x');\n      return {\n        type: InputType.Coin,\n        txID: hexlify(getBytesCopy(value.id).slice(0, 32)),\n        outputIndex: getBytesCopy(value.id)[32],\n        owner: hexlify(value.owner),\n        amount: bn(value.amount),\n        assetId: hexlify(value.assetId),\n        txPointer: {\n          blockHeight: toNumber(getBytesCopy(value.txPointer).slice(0, 8)),\n          txIndex: toNumber(getBytesCopy(value.txPointer).slice(8, 16)),\n        },\n        witnessIndex: value.witnessIndex,\n        maturity: value.maturity ?? 0,\n        predicateGasUsed: bn(value.predicateGasUsed),\n        predicateLength: predicate.length,\n        predicateDataLength: predicateData.length,\n        predicate: hexlify(predicate),\n        predicateData: hexlify(predicateData),\n      };\n    }\n    case InputType.Contract: {\n      return {\n        type: InputType.Contract,\n        txID: ZeroBytes32,\n        outputIndex: 0,\n        balanceRoot: ZeroBytes32,\n        stateRoot: ZeroBytes32,\n        txPointer: {\n          blockHeight: toNumber(getBytesCopy(value.txPointer).slice(0, 8)),\n          txIndex: toNumber(getBytesCopy(value.txPointer).slice(8, 16)),\n        },\n        contractID: hexlify(value.contractId),\n      };\n    }\n    case InputType.Message: {\n      const predicate = getBytesCopy(value.predicate ?? '0x');\n      const predicateData = getBytesCopy(value.predicateData ?? '0x');\n      const data = getBytesCopy(value.data ?? '0x');\n      return {\n        type: InputType.Message,\n        sender: hexlify(value.sender),\n        recipient: hexlify(value.recipient),\n        amount: bn(value.amount),\n        nonce: hexlify(value.nonce),\n        witnessIndex: value.witnessIndex,\n        predicateGasUsed: bn(value.predicateGasUsed),\n        predicateLength: predicate.length,\n        predicateDataLength: predicateData.length,\n        predicate: hexlify(predicate),\n        predicateData: hexlify(predicateData),\n        data: hexlify(data),\n        dataLength: data.length,\n      };\n    }\n    default: {\n      throw new FuelError(\n        ErrorCode.INVALID_TRANSACTION_INPUT,\n        `Invalid transaction input type: ${type}.`\n      );\n    }\n  }\n};\n","import { ZeroBytes32 } from '@fuel-ts/address/configs';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BigNumberish } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type { Output } from '@fuel-ts/transactions';\nimport { OutputType } from '@fuel-ts/transactions';\nimport { hexlify } from 'ethers';\nimport type { BytesLike } from 'ethers';\n\nexport type CoinTransactionRequestOutput = {\n  type: OutputType.Coin;\n  /** Receiving address or script hash */\n  to: BytesLike;\n  /** Amount of coins to send */\n  amount: BigNumberish;\n  /** Asset ID of coins */\n  assetId: BytesLike;\n};\nexport type ContractTransactionRequestOutput = {\n  type: OutputType.Contract;\n  /** Index of input contract */\n  inputIndex: number;\n};\nexport type ChangeTransactionRequestOutput = {\n  type: OutputType.Change;\n  /** Receiving address or script hash */\n  to: BytesLike;\n  /** Asset ID of coins */\n  assetId: BytesLike;\n};\nexport type VariableTransactionRequestOutput = {\n  type: OutputType.Variable;\n};\nexport type ContractCreatedTransactionRequestOutput = {\n  type: OutputType.ContractCreated;\n  /** Contract ID */\n  contractId: BytesLike;\n  /** State Root */\n  stateRoot: BytesLike;\n};\nexport type TransactionRequestOutput =\n  | CoinTransactionRequestOutput\n  | ContractTransactionRequestOutput\n  | ChangeTransactionRequestOutput\n  | VariableTransactionRequestOutput\n  | ContractCreatedTransactionRequestOutput;\n\n/** @hidden */\nexport const outputify = (value: TransactionRequestOutput): Output => {\n  const { type } = value;\n\n  switch (type) {\n    case OutputType.Coin: {\n      return {\n        type: OutputType.Coin,\n        to: hexlify(value.to),\n        amount: bn(value.amount),\n        assetId: hexlify(value.assetId),\n      };\n    }\n    case OutputType.Contract: {\n      return {\n        type: OutputType.Contract,\n        inputIndex: value.inputIndex,\n        balanceRoot: ZeroBytes32,\n        stateRoot: ZeroBytes32,\n      };\n    }\n    case OutputType.Change: {\n      return {\n        type: OutputType.Change,\n        to: hexlify(value.to),\n        amount: bn(0),\n        assetId: hexlify(value.assetId),\n      };\n    }\n    case OutputType.Variable: {\n      return {\n        type: OutputType.Variable,\n        to: ZeroBytes32,\n        amount: bn(0),\n        assetId: ZeroBytes32,\n      };\n    }\n    case OutputType.ContractCreated: {\n      return {\n        type: OutputType.ContractCreated,\n        contractId: hexlify(value.contractId),\n        stateRoot: hexlify(value.stateRoot),\n      };\n    }\n    default: {\n      throw new FuelError(\n        ErrorCode.INVALID_TRANSACTION_INPUT,\n        `Invalid transaction output type: ${type}.`\n      );\n    }\n  }\n};\n","import { Address, addressify, getRandomB256 } from '@fuel-ts/address';\nimport { BaseAssetId, ZeroBytes32 } from '@fuel-ts/address/configs';\nimport type { AddressLike, AbstractAddress, AbstractPredicate } from '@fuel-ts/interfaces';\nimport type { BN, BigNumberish } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type { TransactionScript, Policy, TransactionCreate } from '@fuel-ts/transactions';\nimport {\n  PolicyType,\n  TransactionCoder,\n  InputType,\n  OutputType,\n  TransactionType,\n} from '@fuel-ts/transactions';\nimport type { BytesLike } from 'ethers';\nimport { concat, getBytesCopy, hexlify } from 'ethers';\n\nimport type { GqlGasCosts } from '../__generated__/operations';\nimport type { Coin } from '../coin';\nimport type { CoinQuantity, CoinQuantityLike } from '../coin-quantity';\nimport { coinQuantityfy } from '../coin-quantity';\nimport type { MessageCoin } from '../message';\nimport type { ChainInfo } from '../provider';\nimport type { Resource } from '../resource';\nimport { isCoin } from '../resource';\nimport { normalizeJSON } from '../utils';\nimport { getMaxGas, getMinGas } from '../utils/gas';\n\nimport type { CoinTransactionRequestOutput } from '.';\nimport { NoWitnessAtIndexError } from './errors';\nimport type {\n  TransactionRequestInput,\n  CoinTransactionRequestInput,\n  MessageTransactionRequestInput,\n} from './input';\nimport { inputify } from './input';\nimport type { TransactionRequestOutput, ChangeTransactionRequestOutput } from './output';\nimport { outputify } from './output';\nimport type { TransactionRequestWitness } from './witness';\nimport { witnessify } from './witness';\n\nexport {\n  /**\n   * @hidden\n   */\n  TransactionType,\n};\n\n/**\n * @hidden\n *\n * Interface defining a like structure for a base transaction request.\n */\nexport interface BaseTransactionRequestLike {\n  /** Gas price for transaction */\n  gasPrice?: BigNumberish;\n  /** Block until which tx cannot be included */\n  maturity?: number;\n  /** The maximum fee payable by this transaction using BASE_ASSET. */\n  maxFee?: BigNumberish;\n  /** The maximum amount of witness data allowed for the transaction */\n  witnessLimit?: BigNumberish;\n  /** List of inputs */\n  inputs?: TransactionRequestInput[];\n  /** List of outputs */\n  outputs?: TransactionRequestOutput[];\n  /** List of witnesses */\n  witnesses?: TransactionRequestWitness[];\n}\n\ntype ToBaseTransactionResponse = Pick<\n  TransactionScript,\n  | 'inputs'\n  | 'inputsCount'\n  | 'outputs'\n  | 'outputsCount'\n  | 'witnesses'\n  | 'witnessesCount'\n  | 'policies'\n  | 'policyTypes'\n>;\n\n/**\n * Abstract class to define the functionalities of a transaction request transaction request.\n */\nexport abstract class BaseTransactionRequest implements BaseTransactionRequestLike {\n  /** Type of the transaction */\n  abstract type: TransactionType;\n  /** Gas price for transaction */\n  gasPrice: BN;\n  /** Block until which tx cannot be included */\n  maturity: number;\n  /** The maximum fee payable by this transaction using BASE_ASSET. */\n  maxFee?: BN;\n  /** The maximum amount of witness data allowed for the transaction */\n  witnessLimit?: BN | undefined;\n  /** List of inputs */\n  inputs: TransactionRequestInput[] = [];\n  /** List of outputs */\n  outputs: TransactionRequestOutput[] = [];\n  /** List of witnesses */\n  witnesses: TransactionRequestWitness[] = [];\n\n  /**\n   * Constructor for initializing a base transaction request.\n   *\n   * @param baseTransactionRequest - Optional object containing properties to initialize the transaction request.\n   */\n  constructor({\n    gasPrice,\n    maturity,\n    maxFee,\n    witnessLimit,\n    inputs,\n    outputs,\n    witnesses,\n  }: BaseTransactionRequestLike = {}) {\n    this.gasPrice = bn(gasPrice);\n    this.maturity = maturity ?? 0;\n    this.witnessLimit = witnessLimit ? bn(witnessLimit) : undefined;\n    this.maxFee = maxFee ? bn(maxFee) : undefined;\n    this.inputs = inputs ?? [];\n    this.outputs = outputs ?? [];\n    this.witnesses = witnesses ?? [];\n  }\n\n  static getPolicyMeta(req: BaseTransactionRequest) {\n    let policyTypes = 0;\n    const policies: Policy[] = [];\n\n    if (req.gasPrice) {\n      policyTypes += PolicyType.GasPrice;\n      policies.push({ data: req.gasPrice, type: PolicyType.GasPrice });\n    }\n    if (req.witnessLimit) {\n      policyTypes += PolicyType.WitnessLimit;\n      policies.push({ data: req.witnessLimit, type: PolicyType.WitnessLimit });\n    }\n    if (req.maturity > 0) {\n      policyTypes += PolicyType.Maturity;\n      policies.push({ data: req.maturity, type: PolicyType.Maturity });\n    }\n    if (req.maxFee) {\n      policyTypes += PolicyType.MaxFee;\n      policies.push({ data: req.maxFee, type: PolicyType.MaxFee });\n    }\n\n    return {\n      policyTypes,\n      policies,\n    };\n  }\n\n  /**\n   * Method to obtain the base transaction details.\n   *\n   * @returns The base transaction details.\n   */\n\n  protected getBaseTransaction(): ToBaseTransactionResponse {\n    const inputs = this.inputs?.map(inputify) ?? [];\n    const outputs = this.outputs?.map(outputify) ?? [];\n    const witnesses = this.witnesses?.map(witnessify) ?? [];\n\n    const { policyTypes, policies } = BaseTransactionRequest.getPolicyMeta(this);\n\n    return {\n      policyTypes,\n      inputs,\n      outputs,\n      policies,\n      witnesses,\n      inputsCount: inputs.length,\n      outputsCount: outputs.length,\n      witnessesCount: witnesses.length,\n    };\n  }\n\n  abstract toTransaction(): TransactionCreate | TransactionScript;\n\n  /**\n   * Converts the transaction request to a byte array.\n   *\n   * @returns The transaction bytes.\n   */\n  toTransactionBytes(): Uint8Array {\n    return new TransactionCoder().encode(this.toTransaction());\n  }\n\n  /**\n   * @hidden\n   *\n   * Pushes an input to the list without any side effects and returns the index\n   */\n  protected pushInput(input: TransactionRequestInput): number {\n    this.inputs.push(input);\n    return this.inputs.length - 1;\n  }\n\n  /**\n   * @hidden\n   *\n   * Pushes an output to the list without any side effects and returns the index\n   */\n  protected pushOutput(output: TransactionRequestOutput): number {\n    this.outputs.push(output);\n    return this.outputs.length - 1;\n  }\n\n  /**\n   * @hidden\n   *\n   * Creates an empty witness without any side effects and returns the index\n   */\n  protected createWitness() {\n    // Push a dummy witness with same byte size as a real witness signature\n    this.witnesses.push(concat([ZeroBytes32, ZeroBytes32]));\n    return this.witnesses.length - 1;\n  }\n\n  /**\n   * Updates the witness for a given owner and signature.\n   *\n   * @param address - The address to get the coin input witness index for.\n   * @param signature - The signature to update the witness with.\n   */\n  updateWitnessByOwner(address: AbstractAddress, signature: BytesLike) {\n    const witnessIndex = this.getCoinInputWitnessIndexByOwner(address);\n    if (typeof witnessIndex === 'number') {\n      this.updateWitness(witnessIndex, signature);\n    }\n  }\n\n  /**\n   * Updates an existing witness without any side effects.\n   *\n   * @param index - The index of the witness to update.\n   * @param witness - The new witness.\n   * @throws If the witness does not exist.\n   */\n  updateWitness(index: number, witness: TransactionRequestWitness) {\n    if (!this.witnesses[index]) {\n      throw new NoWitnessAtIndexError(index);\n    }\n    this.witnesses[index] = witness;\n  }\n\n  /**\n   * Gets the coin inputs for a transaction.\n   *\n   * @returns The coin inputs.\n   */\n  getCoinInputs(): CoinTransactionRequestInput[] {\n    return this.inputs.filter(\n      (input): input is CoinTransactionRequestInput => input.type === InputType.Coin\n    );\n  }\n\n  /**\n   * Gets the coin outputs for a transaction.\n   *\n   * @returns The coin outputs.\n   */\n  getCoinOutputs(): CoinTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is CoinTransactionRequestOutput => output.type === OutputType.Coin\n    );\n  }\n\n  /**\n   * Gets the change outputs for a transaction.\n   *\n   * @returns The change outputs.\n   */\n  getChangeOutputs(): ChangeTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ChangeTransactionRequestOutput => output.type === OutputType.Change\n    );\n  }\n\n  /**\n   * @hidden\n   *\n   * Returns the witnessIndex of the found CoinInput.\n   */\n  getCoinInputWitnessIndexByOwner(owner: AddressLike): number | undefined {\n    const ownerAddress = addressify(owner);\n\n    const found = this.inputs.find((input) => {\n      switch (input.type) {\n        case InputType.Coin:\n          return hexlify((<CoinTransactionRequestInput>input).owner) === ownerAddress.toB256();\n        case InputType.Message:\n          return (\n            hexlify((<MessageTransactionRequestInput>input).recipient) === ownerAddress.toB256()\n          );\n        default:\n          return false;\n      }\n    });\n\n    return (<CoinTransactionRequestInput>found)?.witnessIndex;\n  }\n\n  /**\n   * Adds a single coin input to the transaction and a change output for the related\n   * assetId, if one it was not added yet.\n   *\n   * @param coin - Coin resource.\n   * @param predicate - Predicate bytes.\n   * @param predicateData - Predicate data bytes.\n   */\n  addCoinInput(coin: Coin, predicate?: AbstractPredicate) {\n    const { assetId, owner, amount } = coin;\n\n    let witnessIndex;\n\n    if (predicate) {\n      witnessIndex = 0;\n    } else {\n      witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);\n\n      // Insert a dummy witness if no witness exists\n      if (typeof witnessIndex !== 'number') {\n        witnessIndex = this.createWitness();\n      }\n    }\n\n    const input: CoinTransactionRequestInput = {\n      ...coin,\n      type: InputType.Coin,\n      owner: owner.toB256(),\n      amount,\n      assetId,\n      txPointer: '0x00000000000000000000000000000000',\n      witnessIndex,\n      predicate: predicate?.bytes,\n      predicateData: predicate?.predicateData,\n    };\n\n    // Insert the Input\n    this.pushInput(input);\n\n    // Insert a ChangeOutput if it does not exist\n    this.addChangeOutput(owner, assetId);\n  }\n\n  /**\n   * Adds a single message input to the transaction and a change output for the\n   * baseAssetId, if one it was not added yet.\n   *\n   * @param message - Message resource.\n   * @param predicate - Predicate bytes.\n   * @param predicateData - Predicate data bytes.\n   */\n  addMessageInput(message: MessageCoin, predicate?: AbstractPredicate) {\n    const { recipient, sender, amount } = message;\n\n    const assetId = BaseAssetId;\n\n    let witnessIndex;\n\n    if (predicate) {\n      witnessIndex = 0;\n    } else {\n      witnessIndex = this.getCoinInputWitnessIndexByOwner(recipient);\n\n      // Insert a dummy witness if no witness exists\n      if (typeof witnessIndex !== 'number') {\n        witnessIndex = this.createWitness();\n      }\n    }\n\n    const input: MessageTransactionRequestInput = {\n      ...message,\n      type: InputType.Message,\n      sender: sender.toB256(),\n      recipient: recipient.toB256(),\n      amount,\n      witnessIndex,\n      predicate: predicate?.bytes,\n      predicateData: predicate?.predicateData,\n    };\n\n    // Insert the Input\n    this.pushInput(input);\n\n    // Insert a ChangeOutput if it does not exist\n    this.addChangeOutput(recipient, assetId);\n  }\n\n  /**\n   * Adds a single resource to the transaction by adding a coin/message input and a\n   * change output for the related assetId, if one it was not added yet.\n   *\n   * @param resource - The resource to add.\n   * @returns This transaction.\n   */\n  addResource(resource: Resource) {\n    if (isCoin(resource)) {\n      this.addCoinInput(resource);\n    } else {\n      this.addMessageInput(resource);\n    }\n\n    return this;\n  }\n\n  /**\n   * Adds multiple resources to the transaction by adding coin/message inputs and change\n   * outputs from the related assetIds.\n   *\n   * @param resources - The resources to add.\n   * @returns This transaction.\n   */\n  addResources(resources: ReadonlyArray<Resource>) {\n    resources.forEach((resource) => this.addResource(resource));\n\n    return this;\n  }\n\n  /**\n   * Adds multiple resources to the transaction by adding coin/message inputs and change\n   * outputs from the related assetIds.\n   *\n   * @param resources - The resources to add.\n   * @returns This transaction.\n   */\n  addPredicateResource(resource: Resource, predicate: AbstractPredicate) {\n    if (isCoin(resource)) {\n      this.addCoinInput(resource, predicate);\n    } else {\n      this.addMessageInput(resource, predicate);\n    }\n\n    return this;\n  }\n\n  /**\n   * Adds multiple predicate coin/message inputs to the transaction and change outputs\n   * from the related assetIds.\n   *\n   * @param resources - The resources to add.\n   * @returns This transaction.\n   */\n  addPredicateResources(resources: Resource[], predicate: AbstractPredicate) {\n    resources.forEach((resource) => this.addPredicateResource(resource, predicate));\n\n    return this;\n  }\n\n  /**\n   * Adds a coin output to the transaction.\n   *\n   * @param to - Address of the owner.\n   * @param amount - Amount of coin.\n   * @param assetId - Asset ID of coin.\n   */\n  addCoinOutput(to: AddressLike, amount: BigNumberish, assetId: BytesLike = BaseAssetId) {\n    this.pushOutput({\n      type: OutputType.Coin,\n      to: addressify(to).toB256(),\n      amount,\n      assetId,\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds multiple coin outputs to the transaction.\n   *\n   * @param to - Address of the destination.\n   * @param quantities - Quantities of coins.\n   */\n  addCoinOutputs(to: AddressLike, quantities: CoinQuantityLike[]) {\n    quantities.map(coinQuantityfy).forEach((quantity) => {\n      this.pushOutput({\n        type: OutputType.Coin,\n        to: addressify(to).toB256(),\n        amount: quantity.amount,\n        assetId: quantity.assetId,\n      });\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds a change output to the transaction.\n   *\n   * @param to - Address of the owner.\n   * @param assetId - Asset ID of coin.\n   */\n  addChangeOutput(to: AddressLike, assetId: BytesLike = BaseAssetId) {\n    // Find the ChangeOutput for the AssetId of the Resource\n    const changeOutput = this.getChangeOutputs().find(\n      (output) => hexlify(output.assetId) === assetId\n    );\n\n    // Insert a ChangeOutput if it does not exist\n    if (!changeOutput) {\n      this.pushOutput({\n        type: OutputType.Change,\n        to: addressify(to).toB256(),\n        assetId,\n      });\n    }\n  }\n\n  /**\n   * @hidden\n   */\n  byteSize() {\n    return this.toTransactionBytes().length;\n  }\n\n  /**\n   * @hidden\n   */\n  metadataGas(_gasCosts: GqlGasCosts): BN {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @hidden\n   */\n  calculateMinGas(chainInfo: ChainInfo): BN {\n    const { gasCosts, consensusParameters } = chainInfo;\n    const { gasPerByte } = consensusParameters;\n    return getMinGas({\n      gasPerByte,\n      gasCosts,\n      inputs: this.inputs,\n      txBytesSize: this.byteSize(),\n      metadataGas: this.metadataGas(gasCosts),\n    });\n  }\n\n  calculateMaxGas(chainInfo: ChainInfo, minGas: BN): BN {\n    const { consensusParameters } = chainInfo;\n    const { gasPerByte } = consensusParameters;\n\n    const witnessesLength = this.toTransaction().witnesses.reduce(\n      (acc, wit) => acc + wit.dataLength,\n      0\n    );\n    return getMaxGas({\n      gasPerByte,\n      minGas,\n      witnessesLength,\n      witnessLimit: this.witnessLimit,\n    });\n  }\n\n  /**\n   * Funds the transaction with fake UTXOs for each assetId and amount in the\n   * quantities array.\n   *\n   * @param quantities - CoinQuantity Array.\n   */\n  fundWithFakeUtxos(quantities: CoinQuantity[]) {\n    const hasBaseAssetId = quantities.some(({ assetId }) => assetId === BaseAssetId);\n\n    if (!hasBaseAssetId) {\n      quantities.push({ assetId: BaseAssetId, amount: bn(1) });\n    }\n\n    const owner = getRandomB256();\n\n    const witnessToRemove = this.inputs.reduce(\n      (acc, input) => {\n        if (input.type === InputType.Coin || input.type === InputType.Message) {\n          if (!acc[input.witnessIndex]) {\n            acc[input.witnessIndex] = true;\n          }\n        }\n\n        return acc;\n      },\n      {} as Record<number, boolean>\n    );\n\n    this.witnesses = this.witnesses.filter((_, idx) => !witnessToRemove[idx]);\n    this.inputs = this.inputs.filter((input) => input.type === InputType.Contract);\n    this.outputs = this.outputs.filter((output) => output.type !== OutputType.Change);\n\n    const fakeResources = quantities.map(({ assetId, amount }, idx) => ({\n      id: `${ZeroBytes32}0${idx}`,\n      amount,\n      assetId,\n      owner: Address.fromB256(owner),\n      maturity: 0,\n      blockCreated: bn(1),\n      txCreatedIdx: bn(1),\n    }));\n\n    this.addResources(fakeResources);\n  }\n\n  /**\n   * Retrieves an array of CoinQuantity for each coin output present in the transaction.\n   * a transaction.\n   *\n   * @returns  CoinQuantity array.\n   */\n  getCoinOutputsQuantities(): CoinQuantity[] {\n    const coinsQuantities = this.getCoinOutputs().map(({ amount, assetId }) => ({\n      amount: bn(amount),\n      assetId: assetId.toString(),\n    }));\n\n    return coinsQuantities;\n  }\n\n  /**\n   * Gets the Transaction Request by hashing the transaction.\n   *\n   * @param chainId - The chain ID.\n   *\n   * @returns - A hash of the transaction, which is the transaction ID.\n   */\n  abstract getTransactionId(chainId: number): string;\n\n  /**\n   * Return the minimum amount in native coins required to create\n   * a transaction.\n   *\n   * @returns The transaction as a JSON object.\n   */\n  toJSON() {\n    return normalizeJSON(this);\n  }\n\n  /**\n   * @hidden\n   *\n   * Determines whether the transaction has a predicate input.\n   *\n   * @returns Whether the transaction has a predicate input.\n   */\n  hasPredicateInput(): boolean {\n    return Boolean(\n      this.inputs.find(\n        (input) => 'predicate' in input && input.predicate && input.predicate !== getBytesCopy('0x')\n      )\n    );\n  }\n}\n","import type { BytesLike } from 'ethers';\n\nimport type { Coin } from './coin';\nimport type { MessageCoin } from './message';\n\nexport type RawCoin = {\n  utxoId: string;\n  owner: string;\n  amount: string;\n  assetId: string;\n  maturity: string;\n  blockCreated: string;\n  txCreatedIdx: string;\n};\n\nexport type RawMessage = {\n  amount: string;\n  sender: string;\n  assetId: string;\n  recipient: string;\n  data: string;\n  nonce: string;\n  daHeight: string;\n};\n\nexport type RawResource = RawCoin | RawMessage;\nexport type Resource = Coin | MessageCoin;\n\n/** @hidden */\nexport type ExcludeResourcesOption = {\n  utxos?: BytesLike[];\n  messages?: BytesLike[];\n};\n\n/** @hidden */\nexport const isRawCoin = (resource: RawResource): resource is RawCoin => 'utxoId' in resource;\n/** @hidden */\nexport const isRawMessage = (resource: RawResource): resource is RawMessage =>\n  'recipient' in resource;\n/** @hidden */\nexport const isCoin = (resource: Resource): resource is Coin => 'id' in resource;\n/** @hidden */\nexport const isMessage = (resource: Resource): resource is MessageCoin => 'recipient' in resource;\n","import { ZeroBytes32 } from '@fuel-ts/address/configs';\nimport { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport type {\n  ReceiptBurn,\n  ReceiptCall,\n  ReceiptLog,\n  ReceiptLogData,\n  ReceiptMessageOut,\n  ReceiptMint,\n  ReceiptPanic,\n  ReceiptReturn,\n  ReceiptReturnData,\n  ReceiptRevert,\n  ReceiptScriptResult,\n  ReceiptTransfer,\n  ReceiptTransferOut,\n} from '@fuel-ts/transactions';\nimport {\n  ReceiptBurnCoder,\n  ReceiptMessageOutCoder,\n  ReceiptMintCoder,\n  ReceiptType,\n} from '@fuel-ts/transactions';\nimport { FAILED_TRANSFER_TO_ADDRESS_SIGNAL } from '@fuel-ts/transactions/configs';\nimport { getBytesCopy } from 'ethers';\n\nimport type { GqlReceipt } from '../__generated__/operations';\nimport { GqlReceiptType } from '../__generated__/operations';\nimport type { TransactionResultReceipt } from '../transaction-response';\n\n/** @hidden */\nconst doesReceiptHaveMissingOutputVariables = (\n  receipt: TransactionResultReceipt\n): receipt is ReceiptRevert =>\n  receipt.type === ReceiptType.Revert &&\n  receipt.val.toString('hex') === FAILED_TRANSFER_TO_ADDRESS_SIGNAL;\n\n/** @hidden */\nconst doesReceiptHaveMissingContractId = (\n  receipt: TransactionResultReceipt\n): receipt is ReceiptPanic =>\n  receipt.type === ReceiptType.Panic &&\n  receipt.contractId !== '0x0000000000000000000000000000000000000000000000000000000000000000';\n\n/** @hidden */\nexport const getReceiptsWithMissingData = (receipts: Array<TransactionResultReceipt>) =>\n  receipts.reduce<{\n    missingOutputVariables: Array<ReceiptRevert>;\n    missingOutputContractIds: Array<ReceiptPanic>;\n  }>(\n    (memo, receipt) => {\n      if (doesReceiptHaveMissingOutputVariables(receipt)) {\n        memo.missingOutputVariables.push(receipt);\n      }\n      if (doesReceiptHaveMissingContractId(receipt)) {\n        memo.missingOutputContractIds.push(receipt);\n      }\n      return memo;\n    },\n    {\n      missingOutputVariables: [],\n      missingOutputContractIds: [],\n    }\n  );\n\nconst hexOrZero = (hex?: string | null) => hex || ZeroBytes32;\n\nexport function assembleReceiptByType(receipt: GqlReceipt) {\n  const { receiptType } = receipt;\n\n  switch (receiptType) {\n    case GqlReceiptType.Call: {\n      const callReceipt: ReceiptCall = {\n        type: ReceiptType.Call,\n        from: hexOrZero(receipt.contract?.id),\n        to: hexOrZero(receipt?.to?.id),\n        amount: bn(receipt.amount),\n        assetId: hexOrZero(receipt.assetId),\n        gas: bn(receipt.gas),\n        param1: bn(receipt.param1),\n        param2: bn(receipt.param2),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n\n      return callReceipt;\n    }\n\n    case GqlReceiptType.Return: {\n      const returnReceipt: ReceiptReturn = {\n        type: ReceiptType.Return,\n        id: hexOrZero(receipt.contract?.id),\n        val: bn(receipt.val),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n\n      return returnReceipt;\n    }\n\n    case GqlReceiptType.ReturnData: {\n      const returnDataReceipt: ReceiptReturnData = {\n        type: ReceiptType.ReturnData,\n        id: hexOrZero(receipt.contract?.id),\n        ptr: bn(receipt.ptr),\n        len: bn(receipt.len),\n        digest: hexOrZero(receipt.digest),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n\n      return returnDataReceipt;\n    }\n\n    case GqlReceiptType.Panic: {\n      const panicReceipt: ReceiptPanic = {\n        type: ReceiptType.Panic,\n        id: hexOrZero(receipt.contract?.id),\n        reason: bn(receipt.reason),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n        contractId: hexOrZero(receipt.contractId),\n      };\n\n      return panicReceipt;\n    }\n\n    case GqlReceiptType.Revert: {\n      const revertReceipt: ReceiptRevert = {\n        type: ReceiptType.Revert,\n        id: hexOrZero(receipt.contract?.id),\n        val: bn(receipt.ra),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n      return revertReceipt;\n    }\n\n    case GqlReceiptType.Log: {\n      const logReceipt: ReceiptLog = {\n        type: ReceiptType.Log,\n        id: hexOrZero(receipt.contract?.id),\n        val0: bn(receipt.ra),\n        val1: bn(receipt.rb),\n        val2: bn(receipt.rc),\n        val3: bn(receipt.rd),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n\n      return logReceipt;\n    }\n\n    case GqlReceiptType.LogData: {\n      const logDataReceipt: ReceiptLogData = {\n        type: ReceiptType.LogData,\n        id: hexOrZero(receipt.contract?.id),\n        val0: bn(receipt.ra),\n        val1: bn(receipt.rb),\n        ptr: bn(receipt.ptr),\n        len: bn(receipt.len),\n        digest: hexOrZero(receipt.digest),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n      return logDataReceipt;\n    }\n\n    case GqlReceiptType.Transfer: {\n      const transferReceipt: ReceiptTransfer = {\n        type: ReceiptType.Transfer,\n        from: hexOrZero(receipt.contract?.id),\n        to: hexOrZero(receipt.toAddress || receipt?.to?.id),\n        amount: bn(receipt.amount),\n        assetId: hexOrZero(receipt.assetId),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n\n      return transferReceipt;\n    }\n\n    case GqlReceiptType.TransferOut: {\n      const transferOutReceipt: ReceiptTransferOut = {\n        type: ReceiptType.TransferOut,\n        from: hexOrZero(receipt.contract?.id),\n        to: hexOrZero(receipt.toAddress || receipt.to?.id),\n        amount: bn(receipt.amount),\n        assetId: hexOrZero(receipt.assetId),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n      return transferOutReceipt;\n    }\n\n    case GqlReceiptType.ScriptResult: {\n      const scriptResultReceipt: ReceiptScriptResult = {\n        type: ReceiptType.ScriptResult,\n        result: bn(receipt.result),\n        gasUsed: bn(receipt.gasUsed),\n      };\n\n      return scriptResultReceipt;\n    }\n\n    case GqlReceiptType.MessageOut: {\n      const sender = hexOrZero(receipt.sender);\n      const recipient = hexOrZero(receipt.recipient);\n      const nonce = hexOrZero(receipt.nonce);\n      const amount = bn(receipt.amount);\n      const data = receipt.data ? getBytesCopy(receipt.data) : Uint8Array.from([]);\n      const digest = hexOrZero(receipt.digest);\n\n      const messageId = ReceiptMessageOutCoder.getMessageId({\n        sender,\n        recipient,\n        nonce,\n        amount,\n        data,\n      });\n\n      const receiptMessageOut: ReceiptMessageOut = {\n        type: ReceiptType.MessageOut,\n        sender,\n        recipient,\n        amount,\n        nonce,\n        data,\n        digest,\n        messageId,\n      };\n\n      return receiptMessageOut;\n    }\n\n    case GqlReceiptType.Mint: {\n      const contractId = hexOrZero(receipt.contract?.id);\n      const subId = hexOrZero(receipt.subId);\n      const assetId = ReceiptMintCoder.getAssetId(contractId, subId);\n\n      const mintReceipt: ReceiptMint = {\n        type: ReceiptType.Mint,\n        subId,\n        contractId,\n        assetId,\n        val: bn(receipt.val),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n\n      return mintReceipt;\n    }\n\n    case GqlReceiptType.Burn: {\n      const contractId = hexOrZero(receipt.contract?.id);\n      const subId = hexOrZero(receipt.subId);\n      const assetId = ReceiptBurnCoder.getAssetId(contractId, subId);\n\n      const burnReceipt: ReceiptBurn = {\n        type: ReceiptType.Burn,\n        subId,\n        contractId,\n        assetId,\n        val: bn(receipt.val),\n        pc: bn(receipt.pc),\n        is: bn(receipt.is),\n      };\n\n      return burnReceipt;\n    }\n\n    default:\n      throw new FuelError(ErrorCode.INVALID_RECEIPT_TYPE, `Invalid receipt type: ${receiptType}.`);\n  }\n}\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nconst DEFAULT_BLOCK_EXPLORER_URL = 'https://fuellabs.github.io/block-explorer-v2';\n\n/** @hidden */\nconst getPathFromInput = (\n  key: BuildBlockExplorerUrlHelperParam,\n  value: string | number | undefined\n) => {\n  const pathMap = {\n    address: `address`,\n    txId: `transaction`,\n    blockNumber: `block`,\n  };\n  const path = pathMap[key] || key;\n  return `${path}/${value}`;\n};\n\ntype BuildBlockExplorerUrlHelperParam = 'address' | 'txId' | 'blockNumber';\n\n/**\n * @hidden\n *\n * Builds a block explorer url based on and the given path, block explorer URL and provider URL\n */\nexport const buildBlockExplorerUrl = (\n  options: {\n    blockExplorerUrl?: string;\n    path?: string;\n    providerUrl?: string;\n    address?: string;\n    txId?: string;\n    blockNumber?: number;\n  } = {}\n) => {\n  const { blockExplorerUrl, path, providerUrl, address, txId, blockNumber } = options;\n  const explorerUrl = blockExplorerUrl || DEFAULT_BLOCK_EXPLORER_URL;\n\n  // make sure that only ONE or none of the following is defined: address, txId, blockNumber\n  const customInputParams = [\n    {\n      key: 'address',\n      value: address,\n    },\n    {\n      key: 'txId',\n      value: txId,\n    },\n    {\n      key: 'blockNumber',\n      value: blockNumber,\n    },\n  ];\n\n  const definedValues = customInputParams\n    .filter((param) => !!param.value)\n    .map(({ key, value }) => ({\n      key,\n      value,\n    }));\n\n  const hasAnyDefinedValues = definedValues.length > 0;\n\n  if (definedValues.length > 1) {\n    throw new FuelError(\n      ErrorCode.ERROR_BUILDING_BLOCK_EXPLORER_URL,\n      `Only one of the following can be passed in to buildBlockExplorerUrl: ${customInputParams\n        .map((param) => param.key)\n        .join(', ')}.`\n    );\n  }\n\n  if (path && definedValues.length > 0) {\n    const inputKeys = customInputParams.map(({ key }) => key).join(', ');\n    throw new FuelError(\n      ErrorCode.ERROR_BUILDING_BLOCK_EXPLORER_URL,\n      `You cannot pass in a path to 'buildBlockExplorerUrl' along with any of the following: ${inputKeys}.`\n    );\n  }\n\n  const pathGeneratedFromInputParams = hasAnyDefinedValues\n    ? getPathFromInput(\n        definedValues[0].key as BuildBlockExplorerUrlHelperParam,\n        definedValues[0].value\n      )\n    : '';\n\n  // Remove leading and trailing slashes from the path and block explorer url respectively, if present\n  const trimSlashes = /^\\/|\\/$/gm;\n  const cleanPath = path ? path.replace(trimSlashes, '') : pathGeneratedFromInputParams;\n  const cleanBlockExplorerUrl = explorerUrl.replace(trimSlashes, '');\n  const cleanProviderUrl = providerUrl?.replace(trimSlashes, '');\n  const encodedProviderUrl = cleanProviderUrl ? encodeURIComponent(cleanProviderUrl) : undefined;\n\n  // if the block explorer url doesn't have a protocol i.e. http:// or https://, add https://\n  const protocol = cleanBlockExplorerUrl.match(/^https?:\\/\\//) ? '' : 'https://';\n  const providerUrlProtocol = cleanProviderUrl?.match(/^https?:\\/\\//) ? '' : 'https://';\n\n  const url = `${protocol}${cleanBlockExplorerUrl}/${cleanPath}${\n    encodedProviderUrl ? `?providerUrl=${providerUrlProtocol}${encodedProviderUrl}` : ''\n  }`;\n\n  return url;\n};\n","import type { BN, BNInput } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport { ReceiptType, type Input } from '@fuel-ts/transactions';\nimport { getBytesCopy } from 'ethers';\n\nimport type { GqlDependentCost, GqlGasCosts } from '../__generated__/operations';\nimport type { TransactionRequestInput } from '../transaction-request';\nimport type {\n  TransactionResultReceipt,\n  TransactionResultScriptResultReceipt,\n} from '../transaction-response';\n\n/** @hidden */\nexport const calculatePriceWithFactor = (gas: BN, gasPrice: BN, priceFactor: BN): BN =>\n  bn(Math.ceil(gas.mul(gasPrice).toNumber() / priceFactor.toNumber()));\n\n/** @hidden */\nexport const getGasUsedFromReceipts = (receipts: Array<TransactionResultReceipt>): BN => {\n  const scriptResult = receipts.filter(\n    (receipt) => receipt.type === ReceiptType.ScriptResult\n  ) as TransactionResultScriptResultReceipt[];\n\n  const gasUsed = scriptResult.reduce((prev, receipt) => prev.add(receipt.gasUsed), bn(0));\n\n  return gasUsed;\n};\n\nexport function resolveGasDependentCosts(byteSize: BNInput, gasDependentCost: GqlDependentCost) {\n  const base = bn(gasDependentCost.base);\n  let dependentValue = bn(0);\n  if (gasDependentCost.__typename === 'LightOperation') {\n    dependentValue = bn(byteSize).div(bn(gasDependentCost.unitsPerGas));\n  }\n  if (gasDependentCost.__typename === 'HeavyOperation') {\n    dependentValue = bn(byteSize).mul(bn(gasDependentCost.gasPerUnit));\n  }\n  return base.add(dependentValue);\n}\n\nexport function gasUsedByInputs(\n  inputs: Array<TransactionRequestInput | Input>,\n  txBytesSize: number,\n  gasCosts: GqlGasCosts\n) {\n  const witnessCache: Array<number> = [];\n  const totalGas = inputs.reduce((total, input) => {\n    if ('predicate' in input && input.predicate && input.predicate !== '0x') {\n      return total.add(\n        resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization)\n          .add(\n            resolveGasDependentCosts(getBytesCopy(input.predicate).length, gasCosts.contractRoot)\n          )\n          .add(bn(input.predicateGasUsed))\n      );\n    }\n    if ('witnessIndex' in input && !witnessCache.includes(input.witnessIndex)) {\n      witnessCache.push(input.witnessIndex);\n      return total.add(gasCosts.ecr1);\n    }\n    return total;\n  }, bn());\n  // Never allow gas to exceed MAX_U64\n  return totalGas;\n}\n\nexport interface IGetMinGasParams {\n  inputs: Array<TransactionRequestInput | Input>;\n  gasCosts: GqlGasCosts;\n  txBytesSize: number;\n  metadataGas: BN;\n  gasPerByte: BN;\n}\n\nexport function getMinGas(params: IGetMinGasParams) {\n  const { gasCosts, gasPerByte, inputs, metadataGas, txBytesSize } = params;\n\n  const vmInitGas = resolveGasDependentCosts(txBytesSize, gasCosts.vmInitialization);\n  const bytesGas = bn(txBytesSize).mul(gasPerByte);\n  const inputsGas = gasUsedByInputs(inputs, txBytesSize, gasCosts);\n\n  const minGas = vmInitGas.add(bytesGas).add(inputsGas).add(metadataGas).maxU64();\n\n  return minGas;\n}\n\nexport interface IGetMaxGasParams {\n  witnessesLength: number;\n  witnessLimit?: BN;\n  gasPerByte: BN;\n  minGas: BN;\n  gasLimit?: BN;\n}\n\nexport function getMaxGas(params: IGetMaxGasParams) {\n  const { gasPerByte, witnessesLength, witnessLimit, minGas, gasLimit = bn(0) } = params;\n\n  let remainingAllowedWitnessGas = bn(0);\n\n  if (witnessLimit?.gt(0) && witnessLimit.gte(witnessesLength)) {\n    remainingAllowedWitnessGas = bn(witnessLimit).sub(witnessesLength).mul(gasPerByte);\n  }\n\n  return remainingAllowedWitnessGas.add(minGas).add(gasLimit);\n}\n\nexport function calculateMetadataGasForTxCreate({\n  gasCosts,\n  stateRootSize,\n  txBytesSize,\n  contractBytesSize,\n}: {\n  gasCosts: GqlGasCosts;\n  contractBytesSize: BN;\n  stateRootSize: number;\n  txBytesSize: number;\n}) {\n  const contractRootGas = resolveGasDependentCosts(contractBytesSize, gasCosts.contractRoot);\n  const stateRootGas = resolveGasDependentCosts(stateRootSize, gasCosts.stateRoot);\n  const txIdGas = resolveGasDependentCosts(txBytesSize, gasCosts.s256);\n  // See https://github.com/FuelLabs/fuel-specs/blob/master/src/identifiers/contract-id.md\n  const contractIdInputSize = bn(4 + 32 + 32 + 32);\n  const contractIdGas = resolveGasDependentCosts(contractIdInputSize, gasCosts.s256);\n  const metadataGas = contractRootGas.add(stateRootGas).add(txIdGas).add(contractIdGas);\n  return metadataGas.maxU64();\n}\n\nexport function calculateMetadataGasForTxScript({\n  gasCosts,\n  txBytesSize,\n}: {\n  gasCosts: GqlGasCosts;\n  txBytesSize: number;\n}) {\n  return resolveGasDependentCosts(txBytesSize, gasCosts.s256);\n}\n","/* eslint-disable no-param-reassign */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { hexlify } from 'ethers';\nimport { clone } from 'ramda';\n\n// When parsing a Transaction to JSON we need\n// to convert special types into each respective\n// JSON friendly value. This enables a tx to be\n// stringified and parsed back into a Transaction\n/** @hidden */\nfunction normalize(object: any) {\n  Object.keys(object).forEach((key) => {\n    switch (object[key]?.constructor.name) {\n      case 'Uint8Array':\n        object[key] = hexlify(object[key]);\n        break;\n      case 'Array':\n        object[key] = normalize(object[key]);\n        break;\n      case 'BN':\n        object[key] = object[key].toHex();\n        break;\n      case 'Address':\n        object[key] = object[key].toB256();\n        break;\n      case 'Object':\n        object[key] = normalize(object[key]);\n        break;\n      default:\n        break;\n    }\n  });\n  return object;\n}\n\n/**\n * Stringify Transaction to a JSON object\n * compatible with the Transaction class constructor.\n */\n/** @hidden */\nexport function normalizeJSON(root: any) {\n  // Do a single deep clone before normalizing\n  // to avoid mutating the original object\n  // and doing extra clones on each iteration\n  return normalize(clone(root));\n}\n","/** @hidden */\nexport function sleep(time: number) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(true);\n    }, time);\n  });\n}\n","/**\n * @hidden\n *\n * Converts a TAI64 timestamp to a Unix timestamp in milliseconds.\n *\n * TAI64 is a 64-bit unsigned integer format that represents a point in time\n * as the number of TAI seconds elapsed since 00:00:00 TAI, January 1, 1970.\n *\n * Unix timestamp, on the other hand, represents the number of milliseconds\n * elapsed since 00:00:00 UTC, January 1, 1970.\n *\n * To convert a TAI64 timestamp to a Unix timestamp, we need to subtract the\n * TAI64 epoch time (00:00:00 TAI, January 1, 1970) from the TAI64 timestamp\n * and then add the Unix epoch time (00:00:00 UTC, January 1, 1970). The epoch\n * time difference between TAI64 and Unix is 2 ** 62 + 10.\n *\n * @param tai64Timestamp - The TAI64 timestamp to convert.\n * @returns - The Unix timestamp in milliseconds.\n */\nexport const fromTai64ToUnix = (tai64Timestamp: string) =>\n  Number(BigInt(tai64Timestamp) - BigInt(2 ** 62) - BigInt(10));\n\n/**\n * @hidden\n *\n * Converts a Unix timestamp in milliseconds to a TAI64 timestamp.\n *\n * Unix timestamp represents the number of milliseconds elapsed since\n * 00:00:00 UTC, January 1, 1970. TAI64 timestamp is a 64-bit unsigned\n * integer format that represents a point in time as the number of TAI\n * seconds elapsed since 00:00:00 TAI, January 1, 1970.\n *\n * To convert a Unix timestamp to a TAI64 timestamp, we need to add the\n * TAI64 epoch time (00:00:00 TAI, January 1, 1970) to the Unix timestamp\n * and then subtract the Unix epoch time (00:00:00 UTC, January 1, 1970).\n * The epoch time difference between TAI64 and Unix is 2 ** 62 + 10.\n *\n * @param unixTimestampMs - The Unix timestamp in milliseconds to convert.\n * @returns - The TAI64 timestamp as a string.\n */\nexport const fromUnixToTai64 = (unixTimestampMs: number) =>\n  (BigInt(unixTimestampMs) + BigInt(2 ** 62) + BigInt(10)).toString();\n","/* eslint-disable max-classes-per-file */\nimport type { AbstractAddress } from '@fuel-ts/interfaces';\n\n/**\n * @hidden\n */\nexport class ChangeOutputCollisionError extends Error {\n  name = 'ChangeOutputCollisionError';\n  message = 'A ChangeOutput with the same \"assetId\" already exists for a different \"to\" address';\n}\n\n/**\n * @hidden\n */\nexport class NoWitnessAtIndexError extends Error {\n  name = 'NoWitnessAtIndexError';\n  constructor(public readonly index: number) {\n    super();\n    this.message = `Witness at index \"${index}\" was not found`;\n  }\n}\n\n/**\n * @hidden\n */\nexport class NoWitnessByOwnerError extends Error {\n  name = 'NoWitnessByOwnerError';\n  constructor(public readonly owner: AbstractAddress) {\n    super();\n    this.message = `A witness for the given owner \"${owner}\" was not found`;\n  }\n}\n","import type { Witness } from '@fuel-ts/transactions';\nimport { getBytesCopy, hexlify } from 'ethers';\nimport type { BytesLike } from 'ethers';\n\nexport type TransactionRequestWitness = BytesLike;\n\nexport const witnessify = (value: TransactionRequestWitness): Witness => {\n  const data = getBytesCopy(value);\n\n  return {\n    data: hexlify(data),\n    dataLength: data.length,\n  };\n};\n","import { ZeroBytes32 } from '@fuel-ts/address/configs';\nimport { bn, type BN } from '@fuel-ts/math';\nimport type { TransactionCreate } from '@fuel-ts/transactions';\nimport { TransactionType, OutputType } from '@fuel-ts/transactions';\nimport { getBytesCopy, hexlify } from 'ethers';\nimport type { BytesLike } from 'ethers';\n\nimport type { GqlGasCosts } from '../__generated__/operations';\nimport { calculateMetadataGasForTxCreate } from '../utils/gas';\n\nimport { hashTransaction } from './hash-transaction';\nimport type { ContractCreatedTransactionRequestOutput } from './output';\nimport type { TransactionRequestStorageSlot } from './storage-slot';\nimport { storageSlotify } from './storage-slot';\nimport { BaseTransactionRequest } from './transaction-request';\nimport type { BaseTransactionRequestLike } from './transaction-request';\n\n/**\n * @hidden\n */\nexport interface CreateTransactionRequestLike extends BaseTransactionRequestLike {\n  /** Witness index of contract bytecode to create */\n  bytecodeWitnessIndex?: number;\n  /** Salt */\n  salt?: BytesLike;\n  /** List of storage slots to initialize */\n  storageSlots?: TransactionRequestStorageSlot[];\n}\n\n/**\n * `CreateTransactionRequest` provides functionalities for creating a transaction request that creates a contract.\n */\nexport class CreateTransactionRequest extends BaseTransactionRequest {\n  static from(obj: CreateTransactionRequestLike) {\n    if (obj instanceof this) {\n      return obj;\n    }\n    return new this(obj);\n  }\n\n  /** Type of the transaction */\n  type = TransactionType.Create as const;\n  /** Witness index of contract bytecode to create */\n  bytecodeWitnessIndex: number;\n  /** Salt */\n  salt: string;\n  /** List of storage slots to initialize */\n  storageSlots: TransactionRequestStorageSlot[];\n\n  /**\n   * Creates an instance `CreateTransactionRequest`.\n   *\n   * @param createTransactionRequestLike - The initial values for the instance\n   */\n  constructor({\n    bytecodeWitnessIndex,\n    salt,\n    storageSlots,\n    ...rest\n  }: CreateTransactionRequestLike = {}) {\n    super(rest);\n    this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;\n    this.salt = hexlify(salt ?? ZeroBytes32);\n    this.storageSlots = [...(storageSlots ?? [])];\n  }\n\n  /**\n   * Converts the transaction request to a `TransactionCreate`.\n   *\n   * @returns The transaction create object.\n   */\n  toTransaction(): TransactionCreate {\n    const baseTransaction = this.getBaseTransaction();\n    const bytecodeWitnessIndex = this.bytecodeWitnessIndex;\n    const storageSlots = this.storageSlots?.map(storageSlotify) ?? [];\n    return {\n      type: TransactionType.Create,\n      ...baseTransaction,\n      bytecodeLength: baseTransaction.witnesses[bytecodeWitnessIndex].dataLength / 4,\n      bytecodeWitnessIndex,\n      storageSlotsCount: storageSlots.length,\n      salt: this.salt ? hexlify(this.salt) : ZeroBytes32,\n      storageSlots,\n    };\n  }\n\n  /**\n   * Get contract created outputs for the transaction.\n   *\n   * @returns An array of contract created transaction request outputs.\n   */\n  getContractCreatedOutputs(): ContractCreatedTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ContractCreatedTransactionRequestOutput =>\n        output.type === OutputType.ContractCreated\n    );\n  }\n\n  /**\n   * Gets the Transaction Request by hashing the transaction.\n   *\n   * @param chainId - The chain ID.\n   *\n   * @returns - A hash of the transaction, which is the transaction ID.\n   */\n  getTransactionId(chainId: number): string {\n    return hashTransaction(this, chainId);\n  }\n\n  /**\n   * Adds a contract created output to the transaction request.\n   *\n   * @param contractId - The contract ID.\n   * @param stateRoot - The state root.\n   */\n  addContractCreatedOutput(\n    /** Contract ID */\n    contractId: BytesLike,\n    /** State Root */\n    stateRoot: BytesLike\n  ) {\n    this.pushOutput({\n      type: OutputType.ContractCreated,\n      contractId,\n      stateRoot,\n    });\n  }\n\n  metadataGas(gasCosts: GqlGasCosts): BN {\n    return calculateMetadataGasForTxCreate({\n      contractBytesSize: bn(getBytesCopy(this.witnesses[this.bytecodeWitnessIndex] || '0x').length),\n      gasCosts,\n      stateRootSize: this.storageSlots.length,\n      txBytesSize: this.byteSize(),\n    });\n  }\n}\n","import { ZeroBytes32 } from '@fuel-ts/address/configs';\nimport { uint64ToBytesBE } from '@fuel-ts/hasher';\nimport { bn } from '@fuel-ts/math';\nimport { TransactionType, InputType, OutputType, TransactionCoder } from '@fuel-ts/transactions';\nimport { concat, sha256 } from 'ethers';\nimport { clone } from 'ramda';\n\nimport type { TransactionRequest } from './types';\n\n/**\n * Hash transaction request with sha256. [Read more](https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/identifiers.md#transaction-id)\n *\n * @param transactionRequest - Transaction request to be hashed\n * @returns sha256 hash of the transaction\n */\nexport function hashTransaction(transactionRequest: TransactionRequest, chainId: number) {\n  const transaction = transactionRequest.toTransaction();\n\n  if (transaction.type === TransactionType.Script) {\n    transaction.receiptsRoot = ZeroBytes32;\n  }\n\n  // Zero out input fields\n  transaction.inputs = transaction.inputs.map((input) => {\n    const inputClone = clone(input);\n\n    switch (inputClone.type) {\n      // Zero out on signing: txPointer, predicateGasUsed\n      case InputType.Coin: {\n        inputClone.txPointer = {\n          blockHeight: 0,\n          txIndex: 0,\n        };\n        inputClone.predicateGasUsed = bn(0);\n        return inputClone;\n      }\n      // Zero out on signing: predicateGasUsed\n      case InputType.Message: {\n        inputClone.predicateGasUsed = bn(0);\n        return inputClone;\n      }\n      // Zero out on signing: txID, outputIndex, balanceRoot, stateRoot, and txPointer\n      case InputType.Contract: {\n        inputClone.txPointer = {\n          blockHeight: 0,\n          txIndex: 0,\n        };\n        inputClone.txID = ZeroBytes32;\n        inputClone.outputIndex = 0;\n        inputClone.balanceRoot = ZeroBytes32;\n        inputClone.stateRoot = ZeroBytes32;\n        return inputClone;\n      }\n      default:\n        return inputClone;\n    }\n  });\n  // Zero out output fields\n  transaction.outputs = transaction.outputs.map((output) => {\n    const outputClone = clone(output);\n\n    switch (outputClone.type) {\n      // Zero out on signing: balanceRoot, stateRoot\n      case OutputType.Contract: {\n        outputClone.balanceRoot = ZeroBytes32;\n        outputClone.stateRoot = ZeroBytes32;\n        return outputClone;\n      }\n      // Zero out on signing: amount\n      case OutputType.Change: {\n        outputClone.amount = bn(0);\n        return outputClone;\n      }\n      // Zero out on signing: amount, to and assetId\n      case OutputType.Variable: {\n        outputClone.to = ZeroBytes32;\n        outputClone.amount = bn(0);\n        outputClone.assetId = ZeroBytes32;\n        return outputClone;\n      }\n      default:\n        return outputClone;\n    }\n  });\n  transaction.witnessesCount = 0;\n  transaction.witnesses = [];\n\n  const chainIdBytes = uint64ToBytesBE(chainId);\n  const concatenatedData = concat([chainIdBytes, new TransactionCoder().encode(transaction)]);\n  return sha256(concatenatedData);\n}\n","import type { StorageSlot } from '@fuel-ts/transactions';\nimport { getBytesCopy, hexlify } from 'ethers';\nimport type { BytesLike } from 'ethers';\n\nexport type TransactionRequestStorageSlot =\n  | {\n      /** Key */\n      key: BytesLike;\n      /** Value */\n      value: BytesLike;\n    }\n  | [key: BytesLike, value: BytesLike];\n\n// Make sure all values have 32 bytes\nconst getStorageValue = (value: BytesLike): Uint8Array => {\n  const v = new Uint8Array(32);\n  v.set(getBytesCopy(value));\n  return v;\n};\n\nexport const storageSlotify = (storageSlot: TransactionRequestStorageSlot): StorageSlot => {\n  let key;\n  let value;\n\n  if (Array.isArray(storageSlot)) {\n    key = storageSlot[0];\n    value = storageSlot[1];\n  } else {\n    key = storageSlot.key;\n    value = storageSlot.value;\n  }\n\n  return {\n    key: hexlify(key),\n    value: hexlify(getStorageValue(value)),\n  };\n};\n","import type { InputValue, JsonAbi } from '@fuel-ts/abi-coder';\nimport { Interface } from '@fuel-ts/abi-coder';\nimport { addressify } from '@fuel-ts/address';\nimport { ZeroBytes32 } from '@fuel-ts/address/configs';\nimport type { AbstractScriptRequest, ContractIdLike } from '@fuel-ts/interfaces';\nimport { bn } from '@fuel-ts/math';\nimport type { BN, BigNumberish } from '@fuel-ts/math';\nimport type { TransactionScript } from '@fuel-ts/transactions';\nimport { InputType, OutputType, TransactionType } from '@fuel-ts/transactions';\nimport { getBytesCopy, hexlify } from 'ethers';\nimport type { BytesLike } from 'ethers';\n\nimport type { GqlGasCosts } from '../__generated__/operations';\nimport type { ChainInfo } from '../provider';\nimport { calculateMetadataGasForTxScript, getMaxGas } from '../utils/gas';\n\nimport { hashTransaction } from './hash-transaction';\nimport type { ContractTransactionRequestInput } from './input';\nimport type { ContractTransactionRequestOutput, VariableTransactionRequestOutput } from './output';\nimport { returnZeroScript } from './scripts';\nimport type { BaseTransactionRequestLike } from './transaction-request';\nimport { BaseTransactionRequest } from './transaction-request';\n\n/**\n * @hidden\n */\nexport interface ScriptTransactionRequestLike extends BaseTransactionRequestLike {\n  /** Gas limit for transaction */\n  gasLimit?: BigNumberish;\n  /** Script to execute */\n  script?: BytesLike;\n  /** Script input data (parameters) */\n  scriptData?: BytesLike;\n}\n\n/**\n * `ScriptTransactionRequest` provides functionalities for creating a transaction request that uses a script.\n */\nexport class ScriptTransactionRequest extends BaseTransactionRequest {\n  static from(obj: ScriptTransactionRequestLike) {\n    if (obj instanceof this) {\n      return obj;\n    }\n    return new this(obj);\n  }\n\n  /** Type of the transaction */\n  type = TransactionType.Script as const;\n  /** Gas limit for transaction */\n  gasLimit: BN;\n  /** Script to execute */\n  script: Uint8Array;\n  /** Script input data (parameters) */\n  scriptData: Uint8Array;\n\n  /**\n   * Constructor for `ScriptTransactionRequest`.\n   *\n   * @param scriptTransactionRequestLike - The initial values for the instance.\n   */\n  constructor({ script, scriptData, gasLimit, ...rest }: ScriptTransactionRequestLike = {}) {\n    super(rest);\n    this.gasLimit = bn(gasLimit);\n    this.script = getBytesCopy(script ?? returnZeroScript.bytes);\n    this.scriptData = getBytesCopy(scriptData ?? returnZeroScript.encodeScriptData());\n  }\n\n  /**\n   * Converts the transaction request to a `TransactionScript`.\n   *\n   * @returns The transaction script object.\n   */\n  toTransaction(): TransactionScript {\n    const script = getBytesCopy(this.script ?? '0x');\n    const scriptData = getBytesCopy(this.scriptData ?? '0x');\n    return {\n      type: TransactionType.Script,\n      scriptGasLimit: this.gasLimit,\n      ...super.getBaseTransaction(),\n      scriptLength: script.length,\n      scriptDataLength: scriptData.length,\n      receiptsRoot: ZeroBytes32,\n      script: hexlify(script),\n      scriptData: hexlify(scriptData),\n    };\n  }\n\n  /**\n   * Get contract inputs for the transaction.\n   *\n   * @returns An array of contract transaction request inputs.\n   */\n  getContractInputs(): ContractTransactionRequestInput[] {\n    return this.inputs.filter(\n      (input): input is ContractTransactionRequestInput => input.type === InputType.Contract\n    );\n  }\n\n  /**\n   * Get contract outputs for the transaction.\n   *\n   * @returns An array of contract transaction request outputs.\n   */\n  getContractOutputs(): ContractTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is ContractTransactionRequestOutput => output.type === OutputType.Contract\n    );\n  }\n\n  /**\n   * Get variable outputs for the transaction.\n   *\n   * @returns An array of variable transaction request outputs.\n   */\n  getVariableOutputs(): VariableTransactionRequestOutput[] {\n    return this.outputs.filter(\n      (output): output is VariableTransactionRequestOutput => output.type === OutputType.Variable\n    );\n  }\n\n  /**\n   * Set the script and its data.\n   *\n   * @param script - The abstract script request.\n   * @param data - The script data.\n   */\n  setScript<T>(script: AbstractScriptRequest<T>, data: T) {\n    this.scriptData = script.encodeScriptData(data);\n    this.script = script.bytes;\n  }\n\n  /**\n   * Adds variable outputs to the transaction request.\n   *\n   * @param numberOfVariables - The number of variables to add.\n   * @returns The new length of the outputs array.\n   */\n  addVariableOutputs(numberOfVariables: number = 1) {\n    let outputsNumber = numberOfVariables;\n\n    while (outputsNumber) {\n      this.pushOutput({\n        type: OutputType.Variable,\n      });\n      outputsNumber -= 1;\n    }\n\n    return this.outputs.length - 1;\n  }\n\n  calculateMaxGas(chainInfo: ChainInfo, minGas: BN): BN {\n    const { consensusParameters } = chainInfo;\n    const { gasPerByte } = consensusParameters;\n\n    const witnessesLength = this.toTransaction().witnesses.reduce(\n      (acc, wit) => acc + wit.dataLength,\n      0\n    );\n\n    return getMaxGas({\n      gasPerByte,\n      minGas,\n      witnessesLength,\n      witnessLimit: this.witnessLimit,\n      gasLimit: this.gasLimit,\n    });\n  }\n\n  /**\n   * Adds a contract input and output to the transaction request.\n   *\n   * @param contract - The contract ID.\n   * @returns The current instance of the `ScriptTransactionRequest`.\n   */\n  addContractInputAndOutput(contract: ContractIdLike): ScriptTransactionRequest {\n    const contractAddress = addressify(contract);\n\n    // Add only one input contract per contractId\n    if (this.getContractInputs().find((i) => i.contractId === contractAddress.toB256())) {\n      return this;\n    }\n\n    const inputIndex = super.pushInput({\n      type: InputType.Contract,\n      contractId: contractAddress.toB256(),\n      txPointer: '0x00000000000000000000000000000000',\n    });\n\n    this.pushOutput({\n      type: OutputType.Contract,\n      inputIndex,\n    });\n\n    return this;\n  }\n\n  /**\n   * Gets the Transaction Request by hashing the transaction.\n   *\n   * @param chainId - The chain ID.\n   *\n   * @returns - A hash of the transaction, which is the transaction ID.\n   */\n  getTransactionId(chainId: number): string {\n    return hashTransaction(this, chainId);\n  }\n\n  /**\n   * Sets the data for the transaction request.\n   *\n   * @param abi - Script JSON ABI.\n   * @param args - The input arguments.\n   * @returns The current instance of the `ScriptTransactionRequest`.\n   */\n  setData(abi: JsonAbi, args: InputValue[]): ScriptTransactionRequest {\n    const abiInterface = new Interface(abi);\n    this.scriptData = abiInterface.functions.main.encodeArguments(args);\n    return this;\n  }\n\n  metadataGas(gasCosts: GqlGasCosts): BN {\n    return calculateMetadataGasForTxScript({\n      gasCosts,\n      txBytesSize: this.byteSize(),\n    });\n  }\n}\n","import type { AbstractScriptRequest } from '@fuel-ts/interfaces';\nimport { getBytesCopy } from 'ethers';\n\n// We can't import this from `@fuel-ts/script` because it causes\n// cyclic dependency errors so we duplicate it here.\n/** @hidden */\nexport const returnZeroScript: AbstractScriptRequest<void> = {\n  /*\n      Opcode::RET(REG_ZERO)\n      Opcode::NOOP\n    */\n  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281\n  bytes: getBytesCopy('0x24000000'),\n  encodeScriptData: () => new Uint8Array(0),\n};\n\n/** @hidden */\nexport const withdrawScript: AbstractScriptRequest<void> = {\n  /*\n          The following code loads some basic values into registers and calls SMO to create an output message\n          5040C010 \t- ADDI r16 $is i16   [r16 now points to memory 16 bytes from the start of this program (start of receiver data)]\n          5D44C006\t- LW r17 $is i6      [r17 set to the 6th word in this program (6*8=48 bytes from the start of this program)]\n          4C400011\t- SMO r16 r0 r0 r17  [send message out to address starting at memory position r16 with amount in r17]\n          24000000\t- RET                [return 0]\n          00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [recipient address]\n          00000000 00000000 [amount value]\n      */\n  // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281\n  bytes: getBytesCopy('0x5040C0105D44C0064C40001124000000'),\n  encodeScriptData: () => new Uint8Array(0),\n};\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { TransactionType } from '@fuel-ts/transactions';\n\nimport { CreateTransactionRequest } from './create-transaction-request';\nimport { ScriptTransactionRequest } from './script-transaction-request';\nimport type { TransactionRequestLike, TransactionRequest } from './types';\n\n/** @hidden */\nexport const transactionRequestify = (obj: TransactionRequestLike): TransactionRequest => {\n  if (obj instanceof ScriptTransactionRequest || obj instanceof CreateTransactionRequest) {\n    return obj;\n  }\n\n  const { type } = obj;\n\n  switch (obj.type) {\n    case TransactionType.Script: {\n      return ScriptTransactionRequest.from(obj);\n    }\n    case TransactionType.Create: {\n      return CreateTransactionRequest.from(obj);\n    }\n    default: {\n      throw new FuelError(ErrorCode.INVALID_TRANSACTION_TYPE, `Invalid transaction type: ${type}.`);\n    }\n  }\n};\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type {\n  ReceiptCall,\n  ReceiptLog,\n  ReceiptLogData,\n  ReceiptPanic,\n  ReceiptReturn,\n  ReceiptReturnData,\n  ReceiptRevert,\n  ReceiptTransfer,\n  ReceiptTransferOut,\n  ReceiptScriptResult,\n  ReceiptMessageOut,\n  Transaction,\n  ReceiptMint,\n  ReceiptBurn,\n} from '@fuel-ts/transactions';\nimport { TransactionCoder } from '@fuel-ts/transactions';\nimport { getBytesCopy } from 'ethers';\n\nimport type Provider from '../provider';\nimport { assembleTransactionSummary } from '../transaction-summary/assemble-transaction-summary';\nimport { processGqlReceipt } from '../transaction-summary/receipt';\nimport type {\n  TransactionSummary,\n  FailureStatus,\n  GqlTransaction,\n  AbiMap,\n} from '../transaction-summary/types';\nimport { sleep } from '../utils';\n\n/** @hidden */\nexport type TransactionResultCallReceipt = ReceiptCall;\n/** @hidden */\nexport type TransactionResultReturnReceipt = ReceiptReturn;\n/** @hidden */\nexport type TransactionResultReturnDataReceipt = ReceiptReturnData & { data: string };\n/** @hidden */\nexport type TransactionResultPanicReceipt = ReceiptPanic;\n/** @hidden */\nexport type TransactionResultRevertReceipt = ReceiptRevert;\n/** @hidden */\nexport type TransactionResultLogReceipt = ReceiptLog;\n/** @hidden */\nexport type TransactionResultLogDataReceipt = ReceiptLogData & { data: string };\n/** @hidden */\nexport type TransactionResultTransferReceipt = ReceiptTransfer;\n/** @hidden */\nexport type TransactionResultTransferOutReceipt = ReceiptTransferOut;\n/** @hidden */\nexport type TransactionResultScriptResultReceipt = ReceiptScriptResult;\n/** @hidden */\nexport type TransactionResultMessageOutReceipt = ReceiptMessageOut;\nexport type TransactionResultMintReceipt = ReceiptMint;\nexport type TransactionResultBurnReceipt = ReceiptBurn;\n\n/** @hidden */\nexport type TransactionResultReceipt =\n  | ReceiptCall\n  | ReceiptReturn\n  | (ReceiptReturnData & { data: string })\n  | ReceiptPanic\n  | ReceiptRevert\n  | ReceiptLog\n  | (ReceiptLogData & { data: string })\n  | ReceiptTransfer\n  | ReceiptTransferOut\n  | ReceiptScriptResult\n  | ReceiptMessageOut\n  | TransactionResultMintReceipt\n  | TransactionResultBurnReceipt;\n\nconst STATUS_POLLING_INTERVAL_MAX_MS = 5000;\nconst STATUS_POLLING_INTERVAL_MIN_MS = 1000;\n\n/** @hidden */\nexport type TransactionResult<TTransactionType = void> = TransactionSummary<TTransactionType> & {\n  gqlTransaction: GqlTransaction;\n};\n\n/**\n * Represents a response for a transaction.\n */\nexport class TransactionResponse {\n  /** Transaction ID */\n  id: string;\n  /** Current provider */\n  provider: Provider;\n  /** Gas used on the transaction */\n  gasUsed: BN = bn(0);\n  /** Number of attempts made to fetch the transaction */\n  fetchAttempts: number = 0;\n  /** Number of attempts made to retrieve a processed transaction. */\n  resultAttempts: number = 0;\n  /** The graphql Transaction with receipts object. */\n  gqlTransaction?: GqlTransaction;\n\n  /**\n   * Constructor for `TransactionResponse`.\n   *\n   * @param id - The transaction ID.\n   * @param provider - The provider.\n   */\n  constructor(id: string, provider: Provider) {\n    this.id = id;\n    this.provider = provider;\n  }\n\n  /**\n   * Async constructor for `TransactionResponse`. This method can be used to create\n   * an instance of `TransactionResponse` and wait for the transaction to be fetched\n   * from the chain, ensuring that the `gqlTransaction` property is set.\n   *\n   * @param id - The transaction ID.\n   * @param provider - The provider.\n   */\n  static async create(id: string, provider: Provider): Promise<TransactionResponse> {\n    const response = new TransactionResponse(id, provider);\n    await response.fetch();\n    return response;\n  }\n\n  /**\n   * Fetch the transaction with receipts from the provider.\n   *\n   * @returns Transaction with receipts query result.\n   */\n  async fetch(): Promise<GqlTransaction> {\n    const response = await this.provider.operations.getTransactionWithReceipts({\n      transactionId: this.id,\n    });\n\n    if (!response.transaction) {\n      await this.sleepBasedOnAttempts(++this.fetchAttempts);\n      return this.fetch();\n    }\n\n    this.gqlTransaction = response.transaction;\n\n    return response.transaction;\n  }\n\n  /**\n   * Decode the raw payload of the transaction.\n   *\n   * @param transactionWithReceipts - The transaction with receipts object.\n   * @returns The decoded transaction.\n   */\n  decodeTransaction<TTransactionType = void>(transactionWithReceipts: GqlTransaction) {\n    return new TransactionCoder().decode(\n      getBytesCopy(transactionWithReceipts.rawPayload),\n      0\n    )?.[0] as Transaction<TTransactionType>;\n  }\n\n  /**\n   * Retrieves the TransactionSummary. If the `gqlTransaction` is not set, it will\n   * fetch it from the provider\n   *\n   * @param contractsAbiMap - The contracts ABI map.\n   * @returns\n   */\n  async getTransactionSummary<TTransactionType = void>(\n    contractsAbiMap?: AbiMap\n  ): Promise<TransactionSummary<TTransactionType>> {\n    let transaction = this.gqlTransaction;\n\n    if (!transaction) {\n      transaction = await this.fetch();\n    }\n\n    const decodedTransaction = this.decodeTransaction<TTransactionType>(\n      transaction\n    ) as Transaction<TTransactionType>;\n\n    const receipts = transaction.receipts?.map(processGqlReceipt) || [];\n\n    const { gasPerByte, gasPriceFactor, gasCosts } = this.provider.getGasConfig();\n    const maxInputs = this.provider.getChain().consensusParameters.maxInputs;\n\n    const transactionSummary = assembleTransactionSummary<TTransactionType>({\n      id: this.id,\n      receipts,\n      transaction: decodedTransaction,\n      transactionBytes: getBytesCopy(transaction.rawPayload),\n      gqlTransactionStatus: transaction.status,\n      gasPerByte,\n      gasPriceFactor,\n      abiMap: contractsAbiMap,\n      maxInputs,\n      gasCosts,\n    });\n\n    return transactionSummary;\n  }\n\n  /**\n   * Waits for transaction to complete and returns the result.\n   *\n   * @returns The completed transaction result\n   */\n  async waitForResult<TTransactionType = void>(\n    contractsAbiMap?: AbiMap\n  ): Promise<TransactionResult<TTransactionType>> {\n    await this.fetch();\n\n    if (this.gqlTransaction?.status?.type === 'SubmittedStatus') {\n      await this.sleepBasedOnAttempts(++this.resultAttempts);\n\n      return this.waitForResult<TTransactionType>(contractsAbiMap);\n    }\n\n    const transactionSummary = await this.getTransactionSummary<TTransactionType>(contractsAbiMap);\n\n    const transactionResult: TransactionResult<TTransactionType> = {\n      gqlTransaction: this.gqlTransaction as GqlTransaction,\n      ...transactionSummary,\n    };\n\n    return transactionResult;\n  }\n\n  /**\n   * Waits for transaction to complete and returns the result.\n   *\n   * @param contractsAbiMap - The contracts ABI map.\n   */\n  async wait<TTransactionType = void>(\n    contractsAbiMap?: AbiMap\n  ): Promise<TransactionResult<TTransactionType>> {\n    const result = await this.waitForResult<TTransactionType>(contractsAbiMap);\n\n    if (result.isStatusFailure) {\n      throw new FuelError(\n        ErrorCode.TRANSACTION_FAILED,\n        `Transaction failed: ${(<FailureStatus>result.gqlTransaction.status).reason}`\n      );\n    }\n\n    return result;\n  }\n\n  /**\n   * Introduces a delay based on the number of previous attempts made.\n   *\n   * @param attempts - The number of attempts.\n   */\n  private async sleepBasedOnAttempts(attempts: number): Promise<void> {\n    // TODO: Consider adding `maxTimeout` or `maxAttempts` parameter.\n    // The aim is to avoid perpetual execution; when the limit\n    // is reached, we can throw accordingly.\n    await sleep(\n      Math.min(STATUS_POLLING_INTERVAL_MIN_MS * attempts, STATUS_POLLING_INTERVAL_MAX_MS)\n    );\n  }\n}\n","import { type BN } from '@fuel-ts/math';\nimport { type Transaction } from '@fuel-ts/transactions';\nimport { hexlify } from 'ethers';\n\nimport type { GqlGasCosts } from '../__generated__/operations';\nimport type { TransactionResultReceipt } from '../transaction-response';\nimport { getGasUsedFromReceipts } from '../utils';\n\nimport { calculateTransactionFee } from './calculate-transaction-fee';\nimport { fromTai64ToDate } from './date';\nimport {\n  getOperations,\n  getTransactionTypeName,\n  isTypeMint,\n  isTypeCreate,\n  isTypeScript,\n} from './operations';\nimport { extractBurnedAssetsFromReceipts, extractMintedAssetsFromReceipts } from './receipt';\nimport { processGraphqlStatus } from './status';\nimport type { AbiMap, GraphqlTransactionStatus, TransactionSummary } from './types';\n\nexport interface AssembleTransactionSummaryParams {\n  gasPerByte: BN;\n  gasPriceFactor: BN;\n  transaction: Transaction;\n  id?: string;\n  transactionBytes: Uint8Array;\n  gqlTransactionStatus?: GraphqlTransactionStatus;\n  receipts: TransactionResultReceipt[];\n  abiMap?: AbiMap;\n  maxInputs: BN;\n  gasCosts: GqlGasCosts;\n}\n\n/** @hidden */\nexport function assembleTransactionSummary<TTransactionType = void>(\n  params: AssembleTransactionSummaryParams\n) {\n  const {\n    id,\n    receipts,\n    gasPerByte,\n    gasPriceFactor,\n    transaction,\n    transactionBytes,\n    gqlTransactionStatus,\n    abiMap = {},\n    maxInputs,\n    gasCosts,\n  } = params;\n\n  const gasUsed = getGasUsedFromReceipts(receipts);\n\n  const rawPayload = hexlify(transactionBytes);\n\n  const operations = getOperations({\n    transactionType: transaction.type,\n    inputs: transaction.inputs || [],\n    outputs: transaction.outputs || [],\n    receipts,\n    rawPayload,\n    abiMap,\n    maxInputs,\n  });\n\n  const typeName = getTransactionTypeName(transaction.type);\n\n  const { fee } = calculateTransactionFee({\n    gasUsed,\n    rawPayload,\n    consensusParameters: {\n      gasCosts,\n      feeParams: {\n        gasPerByte,\n        gasPriceFactor,\n      },\n    },\n  });\n\n  const { isStatusFailure, isStatusPending, isStatusSuccess, blockId, status, time } =\n    processGraphqlStatus(gqlTransactionStatus);\n\n  const mintedAssets = extractMintedAssetsFromReceipts(receipts);\n  const burnedAssets = extractBurnedAssetsFromReceipts(receipts);\n\n  let date: Date | undefined;\n\n  if (time) {\n    date = fromTai64ToDate(time);\n  }\n\n  const transactionSummary: TransactionSummary<TTransactionType> = {\n    id,\n    fee,\n    gasUsed,\n    operations,\n    type: typeName,\n    blockId,\n    time,\n    status,\n    receipts,\n    mintedAssets,\n    burnedAssets,\n    isTypeMint: isTypeMint(transaction.type),\n    isTypeCreate: isTypeCreate(transaction.type),\n    isTypeScript: isTypeScript(transaction.type),\n    isStatusFailure,\n    isStatusSuccess,\n    isStatusPending,\n    date,\n    transaction: transaction as Transaction<TTransactionType>,\n  };\n\n  return transactionSummary;\n}\n","import type { BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type { TransactionCreate, TransactionScript } from '@fuel-ts/transactions';\nimport { PolicyType, TransactionCoder, TransactionType } from '@fuel-ts/transactions';\nimport { getBytesCopy } from 'ethers';\n\nimport type { GqlConsensusParameters, GqlFeeParameters } from '../__generated__/operations';\nimport { calculatePriceWithFactor } from '../utils';\nimport {\n  calculateMetadataGasForTxCreate,\n  calculateMetadataGasForTxScript,\n  getMaxGas,\n  getMinGas,\n} from '../utils/gas';\n\ntype FeeParams =\n  | Pick<GqlFeeParameters, 'gasPerByte' | 'gasPriceFactor'>\n  | {\n      gasPerByte: BN | number;\n      gasPriceFactor: BN | number;\n    };\n\nexport type CalculateTransactionFeeParams = {\n  gasUsed: BN;\n  rawPayload: string;\n  consensusParameters: Pick<GqlConsensusParameters, 'gasCosts'> & { feeParams: FeeParams };\n};\n\nexport const calculateTransactionFee = (params: CalculateTransactionFeeParams) => {\n  const {\n    gasUsed,\n    rawPayload,\n    consensusParameters: { gasCosts, feeParams },\n  } = params;\n\n  const gasPerByte = bn(feeParams.gasPerByte);\n  const gasPriceFactor = bn(feeParams.gasPriceFactor);\n\n  const transactionBytes = getBytesCopy(rawPayload);\n\n  const [transaction] = new TransactionCoder().decode(transactionBytes, 0);\n\n  if (transaction.type === TransactionType.Mint) {\n    return {\n      fee: bn(0),\n      minFee: bn(0),\n      maxFee: bn(0),\n      feeFromGasUsed: bn(0),\n    };\n  }\n\n  const { type, witnesses, inputs, policies } = transaction as\n    | TransactionCreate\n    | TransactionScript;\n\n  let metadataGas = bn(0);\n  let gasLimit = bn(0);\n\n  if (type === TransactionType.Create) {\n    const { bytecodeWitnessIndex, storageSlots } = transaction as TransactionCreate;\n\n    const contractBytesSize = bn(getBytesCopy(witnesses[bytecodeWitnessIndex].data).length);\n\n    metadataGas = calculateMetadataGasForTxCreate({\n      contractBytesSize,\n      gasCosts,\n      stateRootSize: storageSlots.length || 0,\n      txBytesSize: transactionBytes.length,\n    });\n  } else {\n    const { scriptGasLimit } = transaction;\n\n    if (scriptGasLimit) {\n      gasLimit = scriptGasLimit;\n    }\n\n    metadataGas = calculateMetadataGasForTxScript({\n      gasCosts,\n      txBytesSize: transactionBytes.length,\n    });\n  }\n\n  const minGas = getMinGas({\n    gasCosts,\n    gasPerByte: bn(gasPerByte),\n    inputs,\n    metadataGas,\n    txBytesSize: transactionBytes.length,\n  });\n\n  const gasPrice = bn(policies.find((policy) => policy.type === PolicyType.GasPrice)?.data);\n  const witnessLimit = policies.find((policy) => policy.type === PolicyType.WitnessLimit)?.data as\n    | BN\n    | undefined;\n\n  const witnessesLength = witnesses.reduce((acc, wit) => acc + wit.dataLength, 0);\n\n  const maxGas = getMaxGas({\n    gasPerByte,\n    minGas,\n    witnessesLength,\n    gasLimit,\n    witnessLimit,\n  });\n\n  const feeFromGasUsed = calculatePriceWithFactor(gasUsed, gasPrice, gasPriceFactor);\n  const minFee = calculatePriceWithFactor(minGas, gasPrice, gasPriceFactor);\n  const maxFee = calculatePriceWithFactor(maxGas, gasPrice, gasPriceFactor);\n  const fee = minFee.add(feeFromGasUsed);\n\n  return {\n    fee,\n    minFee,\n    maxFee,\n    feeFromGasUsed,\n  };\n};\n","import { TAI64 } from 'tai64';\n\nexport const fromTai64ToDate = (tai64Timestamp: string) => {\n  const timestamp = TAI64.fromString(tai64Timestamp, 10).toUnix();\n  return new Date(timestamp * 1000);\n};\n\nexport const fromDateToTai64 = (date: Date) =>\n  TAI64.fromUnix(Math.floor(date.getTime() / 1000)).toString(10);\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport { ReceiptType, TransactionType } from '@fuel-ts/transactions';\nimport type { Output } from '@fuel-ts/transactions';\n\nimport type {\n  TransactionResultReceipt,\n  TransactionResultCallReceipt,\n  TransactionResultMessageOutReceipt,\n  TransactionResultTransferOutReceipt,\n  TransactionResultTransferReceipt,\n} from '../transaction-response';\n\nimport { getFunctionCall } from './call';\nimport {\n  getInputFromAssetId,\n  getInputAccountAddress,\n  getInputContractFromIndex,\n  getInputsCoin,\n  getInputsContract,\n} from './input';\nimport {\n  getOutputsChange,\n  getOutputsCoin,\n  getOutputsContract,\n  getOutputsContractCreated,\n} from './output';\nimport { AddressType, ChainName, OperationName, TransactionTypeName } from './types';\nimport type {\n  InputOutputParam,\n  InputParam,\n  OperationCoin,\n  RawPayloadParam,\n  ReceiptParam,\n  Operation,\n  GetOperationParams,\n  GetTransferOperationsParams,\n} from './types';\n\n/** @hidden */\nexport function getReceiptsByType<T = TransactionResultReceipt>(\n  receipts: TransactionResultReceipt[],\n  type: ReceiptType\n) {\n  return (receipts ?? []).filter((r) => r.type === type) as T[];\n}\n\n/** @hidden */\nexport function getTransactionTypeName(transactionType: TransactionType): TransactionTypeName {\n  switch (transactionType) {\n    case TransactionType.Mint:\n      return TransactionTypeName.Mint;\n    case TransactionType.Create:\n      return TransactionTypeName.Create;\n    case TransactionType.Script:\n      return TransactionTypeName.Script;\n    default:\n      throw new FuelError(\n        ErrorCode.INVALID_TRANSACTION_TYPE,\n        `Invalid transaction type: ${transactionType}.`\n      );\n  }\n}\n\n/** @hidden */\nexport function isType(transactionType: TransactionType, type: TransactionTypeName) {\n  const txType = getTransactionTypeName(transactionType);\n\n  return txType === type;\n}\n\n/** @hidden */\nexport function isTypeMint(transactionType: TransactionType) {\n  return isType(transactionType, TransactionTypeName.Mint);\n}\n\n/** @hidden */\nexport function isTypeCreate(transactionType: TransactionType) {\n  return isType(transactionType, TransactionTypeName.Create);\n}\n\n/** @hidden */\nexport function isTypeScript(transactionType: TransactionType) {\n  return isType(transactionType, TransactionTypeName.Script);\n}\n\n/** @hidden */\nexport function hasSameAssetId(a: OperationCoin) {\n  return (b: OperationCoin) => a.assetId === b.assetId;\n}\n\n/** @hidden */\nexport function getReceiptsCall(receipts: TransactionResultReceipt[]) {\n  return getReceiptsByType<TransactionResultCallReceipt>(receipts, ReceiptType.Call);\n}\n\n/** @hidden */\nexport function getReceiptsMessageOut(receipts: TransactionResultReceipt[]) {\n  return getReceiptsByType<TransactionResultMessageOutReceipt>(receipts, ReceiptType.MessageOut);\n}\n\n/** @hidden */\nconst mergeAssets = (op1: Operation, op2: Operation) => {\n  const assets1 = op1.assetsSent || [];\n  const assets2 = op2.assetsSent || [];\n  const filtered = assets2.filter((c) => !assets1.some(hasSameAssetId(c)));\n  return assets1\n    .map((coin) => {\n      const asset = assets2.find(hasSameAssetId(coin));\n      if (!asset) {\n        return coin;\n      }\n      return { ...coin, amount: bn(coin.amount).add(asset.amount) };\n    })\n    .concat(filtered);\n};\n\n/** @hidden */\nfunction isSameOperation(a: Operation, b: Operation) {\n  return (\n    a.name === b.name &&\n    a.from?.address === b.from?.address &&\n    a.to?.address === b.to?.address &&\n    a.from?.type === b.from?.type &&\n    a.to?.type === b.to?.type\n  );\n}\n\n/** @hidden */\nexport function addOperation(operations: Operation[], toAdd: Operation) {\n  const ops = operations\n    .map((op) => {\n      // if it's not same operation, don't change. we just wanna stack the same operation\n      if (!isSameOperation(op, toAdd)) {\n        return null;\n      }\n\n      let newOp = { ...op };\n\n      // if it's adding new assets\n      if (toAdd.assetsSent?.length) {\n        // if prev op had assets, merge them. Otherwise just add the new assets\n        newOp = {\n          ...newOp,\n          assetsSent: op.assetsSent?.length ? mergeAssets(op, toAdd) : toAdd.assetsSent,\n        };\n      }\n\n      // if it's adding new calls,\n      if (toAdd.calls?.length) {\n        /*\n[]          for calls we don't stack as grouping is not desired.\n          we wanna show all calls in the same operation\n          with each respective assets, amounts, functions, arguments.\n        */\n        newOp = {\n          ...newOp,\n          calls: [...(op.calls || []), ...(toAdd.calls || [])],\n        };\n      }\n\n      return newOp;\n    })\n    .filter(Boolean) as Operation[];\n\n  // if this operation didn't exist before just add it to the end\n  return ops.length ? ops : [...operations, toAdd];\n}\n\n/** @hidden */\nexport function getReceiptsTransferOut(receipts: TransactionResultReceipt[]) {\n  return getReceiptsByType<TransactionResultTransferOutReceipt>(receipts, ReceiptType.TransferOut);\n}\n\n/** @hidden */\nexport function getContractTransferOperations({ receipts }: ReceiptParam): Operation[] {\n  const transferOutReceipts = getReceiptsTransferOut(receipts);\n\n  const contractTransferOperations = transferOutReceipts.reduce(\n    (prevContractTransferOps, receipt) => {\n      const newContractTransferOps = addOperation(prevContractTransferOps, {\n        name: OperationName.contractTransfer,\n        from: {\n          type: AddressType.contract,\n          address: receipt.from,\n        },\n        to: {\n          type: AddressType.account,\n          address: receipt.to,\n        },\n        assetsSent: [\n          {\n            amount: receipt.amount,\n            assetId: receipt.assetId,\n          },\n        ],\n      });\n\n      return newContractTransferOps;\n    },\n    [] as Operation[]\n  );\n\n  return contractTransferOperations;\n}\n\n/** @hidden */\nexport function getWithdrawFromFuelOperations({\n  inputs,\n  receipts,\n}: InputParam & ReceiptParam): Operation[] {\n  const messageOutReceipts = getReceiptsMessageOut(receipts);\n\n  const withdrawFromFuelOperations = messageOutReceipts.reduce(\n    (prevWithdrawFromFuelOps, receipt) => {\n      // TODO: replace this hardcode with receipt.assetId when assetId gets added to MessageOutReceipt\n      const assetId = '0x0000000000000000000000000000000000000000000000000000000000000000';\n      const input = getInputFromAssetId(inputs, assetId);\n      if (input) {\n        const inputAddress = getInputAccountAddress(input);\n        const newWithdrawFromFuelOps = addOperation(prevWithdrawFromFuelOps, {\n          name: OperationName.withdrawFromFuel,\n          from: {\n            type: AddressType.account,\n            address: inputAddress,\n          },\n          to: {\n            type: AddressType.account,\n            address: receipt.recipient.toString(),\n            chain: ChainName.ethereum,\n          },\n          assetsSent: [\n            {\n              amount: receipt.amount,\n              assetId,\n            },\n          ],\n        });\n\n        return newWithdrawFromFuelOps;\n      }\n\n      return prevWithdrawFromFuelOps;\n    },\n    [] as Operation[]\n  );\n\n  return withdrawFromFuelOperations;\n}\n\n/** @hidden */\nexport function getContractCallOperations({\n  inputs,\n  outputs,\n  receipts,\n  abiMap,\n  rawPayload,\n  maxInputs,\n}: InputOutputParam &\n  ReceiptParam &\n  Pick<GetOperationParams, 'abiMap' | 'maxInputs'> &\n  RawPayloadParam): Operation[] {\n  const contractCallReceipts = getReceiptsCall(receipts);\n  const contractOutputs = getOutputsContract(outputs);\n\n  const contractCallOperations = contractOutputs.reduce((prevOutputCallOps, output) => {\n    const contractInput = getInputContractFromIndex(inputs, output.inputIndex);\n\n    if (contractInput) {\n      const newCallOps = contractCallReceipts.reduce((prevContractCallOps, receipt) => {\n        if (receipt.to === contractInput.contractID) {\n          const input = getInputFromAssetId(inputs, receipt.assetId);\n          if (input) {\n            const inputAddress = getInputAccountAddress(input);\n            const calls = [];\n\n            const abi = abiMap?.[contractInput.contractID];\n            if (abi) {\n              calls.push(\n                getFunctionCall({\n                  abi,\n                  receipt,\n                  rawPayload,\n                  maxInputs,\n                })\n              );\n            }\n\n            const newContractCallOps = addOperation(prevContractCallOps, {\n              name: OperationName.contractCall,\n              from: {\n                type: AddressType.account,\n                address: inputAddress,\n              },\n              to: {\n                type: AddressType.contract,\n                address: receipt.to,\n              },\n              // if no amount is forwarded to the contract, skip showing assetsSent\n              assetsSent: receipt.amount?.isZero()\n                ? undefined\n                : [\n                    {\n                      amount: receipt.amount,\n                      assetId: receipt.assetId,\n                    },\n                  ],\n              calls,\n            });\n\n            return newContractCallOps;\n          }\n        }\n        return prevContractCallOps;\n      }, prevOutputCallOps as Operation[]);\n\n      return newCallOps;\n    }\n\n    return prevOutputCallOps;\n  }, [] as Operation[]);\n\n  return contractCallOperations;\n}\n\n/** @hidden */\nexport function getTransferOperations({\n  inputs,\n  outputs,\n  receipts,\n}: GetTransferOperationsParams): Operation[] {\n  const coinOutputs = getOutputsCoin(outputs);\n\n  const [transferReceipt] = getReceiptsByType<TransactionResultTransferReceipt>(\n    receipts,\n    ReceiptType.Transfer\n  );\n\n  let operations: Operation[] = [];\n\n  // Possible transfer to contract\n  if (transferReceipt) {\n    const changeOutputs = getOutputsChange(outputs);\n    changeOutputs.forEach((output) => {\n      const { assetId } = output;\n      const [contractInput] = getInputsContract(inputs);\n      const utxo = getInputFromAssetId(inputs, assetId);\n\n      if (utxo && contractInput) {\n        const inputAddress = getInputAccountAddress(utxo);\n        operations = addOperation(operations, {\n          name: OperationName.transfer,\n          from: {\n            type: AddressType.account,\n            address: inputAddress,\n          },\n          to: {\n            type: AddressType.contract,\n            address: contractInput.contractID,\n          },\n          assetsSent: [\n            {\n              assetId: assetId.toString(),\n              amount: transferReceipt.amount,\n            },\n          ],\n        });\n      }\n    });\n  } else {\n    coinOutputs.forEach((output) => {\n      const input = getInputFromAssetId(inputs, output.assetId);\n      if (input) {\n        const inputAddress = getInputAccountAddress(input);\n        operations = addOperation(operations, {\n          name: OperationName.transfer,\n          from: {\n            type: AddressType.account,\n            address: inputAddress,\n          },\n          to: {\n            type: AddressType.account,\n            address: output.to.toString(),\n          },\n          assetsSent: [\n            {\n              assetId: output.assetId.toString(),\n              amount: output.amount,\n            },\n          ],\n        });\n      }\n    });\n  }\n\n  return operations;\n}\n\n/** @hidden */\nexport function getPayProducerOperations(outputs: Output[]): Operation[] {\n  const coinOutputs = getOutputsCoin(outputs);\n  const payProducerOperations = coinOutputs.reduce((prev, output) => {\n    const operations = addOperation(prev, {\n      name: OperationName.payBlockProducer,\n      from: {\n        type: AddressType.account,\n        address: 'Network',\n      },\n      to: {\n        type: AddressType.account,\n        address: output.to.toString(),\n      },\n      assetsSent: [\n        {\n          assetId: output.assetId.toString(),\n          amount: output.amount,\n        },\n      ],\n    });\n\n    return operations;\n  }, [] as Operation[]);\n\n  return payProducerOperations;\n}\n\n/** @hidden */\nexport function getContractCreatedOperations({ inputs, outputs }: InputOutputParam): Operation[] {\n  const contractCreatedOutputs = getOutputsContractCreated(outputs);\n  const input = getInputsCoin(inputs)[0];\n  const fromAddress = getInputAccountAddress(input);\n  const contractCreatedOperations = contractCreatedOutputs.reduce((prev, contractCreatedOutput) => {\n    const operations = addOperation(prev, {\n      name: OperationName.contractCreated,\n      from: {\n        type: AddressType.account,\n        address: fromAddress,\n      },\n      to: {\n        type: AddressType.contract,\n        address: contractCreatedOutput?.contractId || '',\n      },\n    });\n\n    return operations;\n  }, [] as Operation[]);\n\n  return contractCreatedOperations;\n}\n\n/** @hidden */\nexport function getOperations({\n  transactionType,\n  inputs,\n  outputs,\n  receipts,\n  abiMap,\n  rawPayload,\n  maxInputs,\n}: GetOperationParams): Operation[] {\n  if (isTypeCreate(transactionType)) {\n    return [\n      ...getContractCreatedOperations({ inputs, outputs }),\n      ...getTransferOperations({ inputs, outputs, receipts }),\n    ];\n  }\n\n  if (isTypeScript(transactionType)) {\n    return [\n      ...getTransferOperations({ inputs, outputs, receipts }),\n      ...getContractCallOperations({\n        inputs,\n        outputs,\n        receipts,\n        abiMap,\n        rawPayload,\n        maxInputs,\n      }),\n      ...getContractTransferOperations({ receipts }),\n      ...getWithdrawFromFuelOperations({ inputs, receipts }),\n    ];\n  }\n  // at this point we are sure it's a mint transaction\n  return [...getPayProducerOperations(outputs)];\n}\n","import { Interface, type JsonAbi, calculateVmTxMemory } from '@fuel-ts/abi-coder';\nimport type { BN } from '@fuel-ts/math';\nimport { bn } from '@fuel-ts/math';\nimport type { ReceiptCall } from '@fuel-ts/transactions';\n\ntype GetFunctionCallProps = {\n  abi: JsonAbi;\n  receipt: ReceiptCall;\n  rawPayload?: string;\n  maxInputs: BN;\n};\n\nexport const getFunctionCall = ({ abi, receipt, rawPayload, maxInputs }: GetFunctionCallProps) => {\n  const abiInterface = new Interface(abi);\n  const callFunctionSelector = receipt.param1.toHex(8);\n  const functionFragment = abiInterface.getFunction(callFunctionSelector);\n  const inputs = functionFragment.jsonFn.inputs;\n\n  let encodedArgs;\n\n  // if has more than 1 input or input type is bigger than 8 bytes, then it's a pointer to data\n  if (functionFragment.isInputDataPointer) {\n    if (rawPayload) {\n      // calculate offset to get function params from rawPayload. should also consider vm offset\n      const argsOffset = bn(receipt.param2)\n        .sub(calculateVmTxMemory({ maxInputs: maxInputs.toNumber() }))\n        .toNumber();\n\n      // slice(2) to remove first 0x, then slice again to remove offset and get only args\n      encodedArgs = `0x${rawPayload.slice(2).slice(argsOffset * 2)}`;\n    }\n  } else {\n    // for small inputs, param2 is directly the value\n    encodedArgs = receipt.param2.toHex();\n  }\n\n  let argumentsProvided;\n  if (encodedArgs) {\n    // use bytes got from rawPayload to decode function params\n    const data = functionFragment.decodeArguments(encodedArgs);\n    if (data) {\n      // put together decoded data with input names from abi\n      argumentsProvided = inputs.reduce((prev, input, index) => {\n        const value = data[index];\n        const name = input.name;\n\n        if (name) {\n          return {\n            ...prev,\n            // reparse to remove bn\n            [name]: JSON.parse(JSON.stringify(value)),\n          };\n        }\n\n        return prev;\n      }, {});\n    }\n  }\n\n  const call = {\n    functionSignature: functionFragment.signature,\n    functionName: functionFragment.name,\n    argumentsProvided,\n    ...(receipt.amount?.isZero() ? {} : { amount: receipt.amount, assetId: receipt.assetId }),\n  };\n\n  return call;\n};\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport type { Input, InputCoin, InputContract, InputMessage } from '@fuel-ts/transactions';\nimport { InputType } from '@fuel-ts/transactions';\n\n/** @hidden */\nexport function getInputsByType<T = Input>(inputs: Input[], type: InputType) {\n  return inputs.filter((i) => i.type === type) as T[];\n}\n\n/** @hidden */\nexport function getInputsCoin(inputs: Input[]) {\n  return getInputsByType<InputCoin>(inputs, InputType.Coin);\n}\n\n/** @hidden */\nexport function getInputsMessage(inputs: Input[]) {\n  return getInputsByType<InputMessage>(inputs, InputType.Message);\n}\n\n/** @hidden */\nexport function getInputsContract(inputs: Input[]) {\n  return getInputsByType<InputContract>(inputs, InputType.Contract);\n}\n\n/** @hidden */\nexport function getInputFromAssetId(inputs: Input[], assetId: string) {\n  const coinInputs = getInputsCoin(inputs);\n  const messageInputs = getInputsMessage(inputs);\n  const coinInput = coinInputs.find((i) => i.assetId === assetId);\n  // TODO: should include assetId in InputMessage as well. for now we're mocking ETH\n  const messageInput = messageInputs.find(\n    (_) => assetId === '0x0000000000000000000000000000000000000000000000000000000000000000'\n  );\n\n  return coinInput || messageInput;\n}\n\n/** @hidden */\nexport function getInputContractFromIndex(\n  inputs: Input[],\n  inputIndex: number\n): InputContract | undefined {\n  if (inputIndex == null) {\n    return undefined;\n  }\n\n  const contractInput = inputs?.[inputIndex];\n\n  if (!contractInput) {\n    return undefined;\n  }\n  if (contractInput.type !== InputType.Contract) {\n    throw new FuelError(\n      ErrorCode.INVALID_TRANSACTION_INPUT,\n      `Contract input should be of type 'contract'.`\n    );\n  }\n\n  return contractInput as InputContract;\n}\n\n/** @hidden */\nexport function getInputAccountAddress(input: Input) {\n  if (input.type === InputType.Coin) {\n    return input.owner.toString();\n  }\n\n  if (input.type === InputType.Message) {\n    return input.recipient.toString();\n  }\n\n  return '';\n}\n","import type {\n  Output,\n  OutputCoin,\n  OutputContract,\n  OutputContractCreated,\n  OutputVariable,\n} from '@fuel-ts/transactions';\nimport { OutputType } from '@fuel-ts/transactions';\n\n/** @hidden */\nexport function getOutputsByType<T = Output>(outputs: Output[], type: OutputType) {\n  return outputs.filter((o) => o.type === type) as T[];\n}\n\n/** @hidden */\nexport function getOutputsContractCreated(outputs: Output[]) {\n  return getOutputsByType<OutputContractCreated>(outputs, OutputType.ContractCreated);\n}\n\n/** @hidden */\nexport function getOutputsCoin(outputs: Output[]) {\n  return getOutputsByType<OutputCoin>(outputs, OutputType.Coin);\n}\n\n/** @hidden */\nexport function getOutputsChange(outputs: Output[]) {\n  return getOutputsByType<OutputCoin>(outputs, OutputType.Change);\n}\n\n/** @hidden */\nexport function getOutputsContract(outputs: Output[]) {\n  return getOutputsByType<OutputContract>(outputs, OutputType.Contract);\n}\n\n/** @hidden */\nexport function getOutputsVariable(outputs: Output[]) {\n  return getOutputsByType<OutputVariable>(outputs, OutputType.Variable);\n}\n","import type { JsonAbi } from '@fuel-ts/abi-coder';\nimport type { B256Address } from '@fuel-ts/interfaces';\nimport type { BN, BNInput } from '@fuel-ts/math';\nimport type { Input, Output, Transaction, TransactionType } from '@fuel-ts/transactions';\n\nimport type { GqlGetTransactionQuery } from '../__generated__/operations';\nimport type { TransactionResultReceipt } from '../transaction-response';\n\nexport type GqlTransaction = NonNullable<GqlGetTransactionQuery['transaction']>;\n\nexport type GraphqlTransactionStatus = GqlTransaction['status'];\n\nexport type SuccessStatus = Extract<GraphqlTransactionStatus, { __typename: 'SuccessStatus' }>;\nexport type FailureStatus = Extract<GraphqlTransactionStatus, { __typename: 'FailureStatus' }>;\nexport type SubmittedStatus = Extract<GraphqlTransactionStatus, { __typename: 'SubmittedStatus' }>;\nexport type SqueezedOutStatus = Extract<\n  GraphqlTransactionStatus,\n  { __typename: 'SqueezedOutStatus' }\n>;\n\nexport type Reason = FailureStatus['reason'];\nexport type ProgramState = SuccessStatus['programState'];\nexport type Time = SubmittedStatus['time'] | SuccessStatus['time'] | FailureStatus['time'];\nexport type BlockId = SuccessStatus['block']['id'] | FailureStatus['block']['id'];\n\n/**\n * @hidden\n */\nexport enum TransactionTypeName {\n  Create = 'Create',\n  Mint = 'Mint',\n  Script = 'Script',\n}\n\n/**\n * @hidden\n */\nexport enum TransactionStatus {\n  submitted = 'submitted',\n  success = 'success',\n  squeezedout = 'squeezedout',\n  failure = 'failure',\n}\n\n/**\n * @hidden\n */\nexport type GqlTransactionStatusesNames =\n  | 'FailureStatus'\n  | 'SubmittedStatus'\n  | 'SuccessStatus'\n  | 'SqueezedOutStatus';\n\n/**\n * @hidden\n */\nexport enum OperationName {\n  payBlockProducer = 'Pay network fee to block producer',\n  contractCreated = 'Contract created',\n  transfer = 'Transfer asset',\n  contractCall = 'Contract call',\n  contractTransfer = 'Contract transfer',\n  receive = 'Receive asset',\n  mint = 'Mint asset',\n  predicatecall = 'Predicate call',\n  script = 'Script',\n  sent = 'Sent asset',\n  withdrawFromFuel = 'Withdraw from Fuel',\n}\n\nexport type OperationCoin = {\n  assetId: string;\n  amount: BNInput;\n};\n\nexport type OperationFunctionCall = {\n  functionSignature: string;\n  functionName: string;\n  argumentsProvided?: Record<string, unknown>;\n} & Partial<OperationCoin>;\n\nexport type Operation = {\n  name?: OperationName;\n  from?: OperationTransactionAddress;\n  to?: OperationTransactionAddress;\n  assetsSent?: Array<OperationCoin>;\n  calls?: Array<OperationFunctionCall>;\n};\n\n/**\n * @hidden\n */\nexport enum AddressType {\n  contract,\n  account,\n}\n\n/**\n * @hidden\n */\nexport enum ChainName {\n  ethereum = 'ethereum',\n  fuel = 'fuel',\n}\n\nexport type OperationTransactionAddress = {\n  address: string;\n  type: AddressType;\n  chain?: ChainName;\n};\n\nexport type InputParam = {\n  inputs: Input[];\n};\n\nexport type OutputParam = {\n  outputs: Output[];\n};\n\nexport type ReceiptParam = {\n  receipts: TransactionResultReceipt[];\n};\n\nexport type AbiMap = Record<string, JsonAbi>;\n\nexport type RawPayloadParam = {\n  rawPayload?: string;\n};\n\nexport type InputOutputParam = InputParam & OutputParam;\n\nexport interface GetTransferOperationsParams extends InputOutputParam {\n  receipts: TransactionResultReceipt[];\n}\n\nexport type GetOperationParams = {\n  transactionType: TransactionType;\n  abiMap?: AbiMap;\n  maxInputs: BN;\n} & InputOutputParam &\n  ReceiptParam &\n  RawPayloadParam;\n\nexport interface MintedAsset {\n  subId: B256Address;\n  contractId: B256Address;\n  assetId: B256Address;\n  amount: BN;\n}\n\nexport type BurnedAsset = MintedAsset;\n\nexport type TransactionSummary<TTransactionType = void> = {\n  id?: string;\n  time?: string;\n  operations: Operation[];\n  gasUsed: BN;\n  fee: BN;\n  type: TransactionTypeName;\n  blockId?: BlockId;\n  status?: TransactionStatus;\n  isTypeMint: boolean;\n  isTypeCreate: boolean;\n  isTypeScript: boolean;\n  isStatusPending: boolean;\n  isStatusSuccess: boolean;\n  isStatusFailure: boolean;\n  mintedAssets: MintedAsset[];\n  burnedAssets: BurnedAsset[];\n  date?: Date;\n  receipts: TransactionResultReceipt[];\n  transaction: Transaction<TTransactionType>;\n};\n","import { ReceiptType } from '@fuel-ts/transactions';\n\nimport type { GqlReceipt } from '../__generated__/operations';\nimport type { TransactionResultReceipt } from '../transaction-response';\nimport { assembleReceiptByType } from '../utils';\n\nimport type { BurnedAsset, MintedAsset } from './types';\n\nexport const processGqlReceipt = (gqlReceipt: GqlReceipt): TransactionResultReceipt => {\n  const receipt = assembleReceiptByType(gqlReceipt);\n\n  switch (receipt.type) {\n    case ReceiptType.ReturnData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data || '0x',\n      };\n    }\n    case ReceiptType.LogData: {\n      return {\n        ...receipt,\n        data: gqlReceipt.data || '0x',\n      };\n    }\n    default:\n      return receipt;\n  }\n};\n\nexport const extractMintedAssetsFromReceipts = (\n  receipts: Array<TransactionResultReceipt>\n): MintedAsset[] => {\n  const mintedAssets: MintedAsset[] = [];\n\n  receipts.forEach((receipt) => {\n    if (receipt.type === ReceiptType.Mint) {\n      mintedAssets.push({\n        subId: receipt.subId,\n        contractId: receipt.contractId,\n        assetId: receipt.assetId,\n        amount: receipt.val,\n      });\n    }\n  });\n\n  return mintedAssets;\n};\n\nexport const extractBurnedAssetsFromReceipts = (\n  receipts: Array<TransactionResultReceipt>\n): BurnedAsset[] => {\n  const burnedAssets: BurnedAsset[] = [];\n\n  receipts.forEach((receipt) => {\n    if (receipt.type === ReceiptType.Burn) {\n      burnedAssets.push({\n        subId: receipt.subId,\n        contractId: receipt.contractId,\n        assetId: receipt.assetId,\n        amount: receipt.val,\n      });\n    }\n  });\n\n  return burnedAssets;\n};\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\n\nimport type {\n  BlockId,\n  GqlTransactionStatusesNames,\n  GraphqlTransactionStatus,\n  Time,\n  TransactionSummary,\n} from './types';\nimport { TransactionStatus } from './types';\n\n/** @hidden */\nexport const getTransactionStatusName = (gqlStatus: GqlTransactionStatusesNames) => {\n  switch (gqlStatus) {\n    case 'FailureStatus':\n      return TransactionStatus.failure;\n    case 'SuccessStatus':\n      return TransactionStatus.success;\n    case 'SubmittedStatus':\n      return TransactionStatus.submitted;\n    case 'SqueezedOutStatus':\n      return TransactionStatus.squeezedout;\n    default:\n      throw new FuelError(\n        ErrorCode.INVALID_TRANSACTION_STATUS,\n        `Invalid transaction status: ${gqlStatus}.`\n      );\n  }\n};\n\ntype IProcessGraphqlStatusResponse = Pick<\n  TransactionSummary,\n  'time' | 'blockId' | 'isStatusPending' | 'isStatusSuccess' | 'isStatusFailure' | 'status'\n>;\n\n/** @hidden */\nexport const processGraphqlStatus = (gqlTransactionStatus?: GraphqlTransactionStatus) => {\n  let time: Time;\n  let blockId: BlockId | undefined;\n  let status: TransactionStatus | undefined;\n\n  let isStatusFailure = false;\n  let isStatusSuccess = false;\n  let isStatusPending = false;\n\n  if (gqlTransactionStatus?.type) {\n    status = getTransactionStatusName(gqlTransactionStatus.type);\n\n    switch (gqlTransactionStatus.type) {\n      case 'SuccessStatus':\n        time = gqlTransactionStatus.time;\n        blockId = gqlTransactionStatus.block.id;\n        isStatusSuccess = true;\n        break;\n\n      case 'FailureStatus':\n        time = gqlTransactionStatus.time;\n        blockId = gqlTransactionStatus.block.id;\n        isStatusFailure = true;\n        break;\n\n      case 'SubmittedStatus':\n        time = gqlTransactionStatus.time;\n        isStatusPending = true;\n        break;\n      default:\n    }\n  }\n\n  const processedGraphqlStatus: IProcessGraphqlStatusResponse = {\n    time,\n    blockId,\n    status,\n    isStatusFailure,\n    isStatusSuccess,\n    isStatusPending,\n  };\n\n  return processedGraphqlStatus;\n};\n","import type { Interface } from '@fuel-ts/abi-coder';\nimport { U64Coder } from '@fuel-ts/abi-coder';\nimport { ReceiptType } from '@fuel-ts/transactions';\n\nimport type { TransactionResultReceipt } from './transaction-response';\n\n/** @hidden */\nexport function getDecodedLogs<T = unknown>(\n  receipts: Array<TransactionResultReceipt>,\n  abiInterface: Interface\n): T[] {\n  return receipts.reduce((logs: T[], r) => {\n    if (r.type === ReceiptType.LogData) {\n      logs.push(abiInterface.decodeLog(r.data, r.val1.toNumber(), r.id)[0]);\n    }\n\n    if (r.type === ReceiptType.Log) {\n      logs.push(abiInterface.decodeLog(new U64Coder().encode(r.val0), r.val1.toNumber(), r.id)[0]);\n    }\n\n    return logs;\n  }, []);\n}\n","import type { BN } from '@fuel-ts/math';\n\nimport type { CoinQuantity } from '../coin-quantity';\n\nexport const mergeQuantities = (arr1: CoinQuantity[], arr2: CoinQuantity[]): CoinQuantity[] => {\n  const resultMap: { [key: string]: BN } = {};\n\n  function addToMap({ amount, assetId }: CoinQuantity) {\n    if (resultMap[assetId]) {\n      resultMap[assetId] = resultMap[assetId].add(amount);\n    } else {\n      resultMap[assetId] = amount;\n    }\n  }\n\n  // Process both arrays\n  arr1.forEach(addToMap);\n  arr2.forEach(addToMap);\n\n  // Convert the resultMap back to an array\n  return Object.entries(resultMap).map(([assetId, amount]) => ({ assetId, amount }));\n};\n","import { ErrorCode, FuelError } from '@fuel-ts/errors';\nimport { bn } from '@fuel-ts/math';\nimport { TransactionCoder } from '@fuel-ts/transactions';\nimport { getBytesCopy } from 'ethers';\n\nimport type {\n  GqlGetTransactionsByOwnerQueryVariables,\n  GqlPageInfo,\n} from '../__generated__/operations';\nimport type Provider from '../provider';\nimport type { TransactionRequest } from '../transaction-request';\nimport type { TransactionResult } from '../transaction-response';\n\nimport { assembleTransactionSummary } from './assemble-transaction-summary';\nimport { processGqlReceipt } from './receipt';\nimport type { AbiMap, TransactionSummary } from './types';\n\n/** @hidden */\nexport interface GetTransactionSummaryParams {\n  id: string;\n  provider: Provider;\n  abiMap?: AbiMap;\n}\n\nexport async function getTransactionSummary<TTransactionType = void>(\n  params: GetTransactionSummaryParams\n): Promise<TransactionResult> {\n  const { id, provider, abiMap } = params;\n\n  const { transaction: gqlTransaction } = await provider.operations.getTransactionWithReceipts({\n    transactionId: id,\n  });\n\n  if (!gqlTransaction) {\n    throw new FuelError(\n      ErrorCode.TRANSACTION_NOT_FOUND,\n      `Transaction not found for given id: ${id}.`\n    );\n  }\n\n  const [decodedTransaction] = new TransactionCoder().decode(\n    getBytesCopy(gqlTransaction.rawPayload),\n    0\n  );\n\n  const receipts = gqlTransaction.receipts?.map(processGqlReceipt) || [];\n\n  const {\n    consensusParameters: { gasPerByte, gasPriceFactor, maxInputs, gasCosts },\n  } = provider.getChain();\n\n  const transactionInfo = assembleTransactionSummary<TTransactionType>({\n    id: gqlTransaction.id,\n    receipts,\n    transaction: decodedTransaction,\n    transactionBytes: getBytesCopy(gqlTransaction.rawPayload),\n    gqlTransactionStatus: gqlTransaction.status,\n    gasPerByte: bn(gasPerByte),\n    gasPriceFactor: bn(gasPriceFactor),\n    abiMap,\n    maxInputs,\n    gasCosts,\n  });\n\n  return {\n    gqlTransaction,\n    ...transactionInfo,\n  };\n}\n\nexport interface GetTransactionSummaryFromRequestParams {\n  transactionRequest: TransactionRequest;\n  provider: Provider;\n  abiMap?: AbiMap;\n}\n\n/** @hidden */\nexport async function getTransactionSummaryFromRequest<TTransactionType = void>(\n  params: GetTransactionSummaryFromRequestParams\n): Promise<TransactionSummary<TTransactionType>> {\n  const { provider, transactionRequest, abiMap } = params;\n\n  const { receipts } = await provider.call(transactionRequest);\n\n  const { gasPerByte, gasPriceFactor, gasCosts } = provider.getGasConfig();\n  const maxInputs = provider.getChain().consensusParameters.maxInputs;\n\n  const transaction = transactionRequest.toTransaction();\n  const transactionBytes = transactionRequest.toTransactionBytes();\n\n  const transactionSummary = assembleTransactionSummary<TTransactionType>({\n    receipts,\n    transaction,\n    transactionBytes,\n    abiMap,\n    gasPerByte,\n    gasPriceFactor,\n    maxInputs,\n    gasCosts,\n  });\n\n  return transactionSummary;\n}\n\nexport interface GetTransactionsSummariesParams {\n  provider: Provider;\n  filters: GqlGetTransactionsByOwnerQueryVariables;\n  abiMap?: AbiMap;\n}\n\nexport interface GetTransactionsSummariesReturns {\n  transactions: TransactionResult[];\n  pageInfo: GqlPageInfo;\n}\n\n/** @hidden */\nexport async function getTransactionsSummaries(\n  params: GetTransactionsSummariesParams\n): Promise<GetTransactionsSummariesReturns> {\n  const { filters, provider, abiMap } = params;\n\n  const { transactionsByOwner } = await provider.operations.getTransactionsByOwner(filters);\n\n  const { edges, pageInfo } = transactionsByOwner;\n\n  const {\n    consensusParameters: { gasPerByte, gasPriceFactor, maxInputs, gasCosts },\n  } = provider.getChain();\n\n  const transactions = edges.map((edge) => {\n    const { node: gqlTransaction } = edge;\n\n    const { id, rawPayload, receipts: gqlReceipts, status } = gqlTransaction;\n\n    const [decodedTransaction] = new TransactionCoder().decode(getBytesCopy(rawPayload), 0);\n\n    const receipts = gqlReceipts?.map(processGqlReceipt) || [];\n\n    const transactionSummary = assembleTransactionSummary({\n      id,\n      receipts,\n      transaction: decodedTransaction,\n      transactionBytes: getBytesCopy(rawPayload),\n      gqlTransactionStatus: status,\n      abiMap,\n      gasPerByte,\n      gasPriceFactor,\n      maxInputs,\n      gasCosts,\n    });\n\n    const output: TransactionResult = {\n      gqlTransaction,\n      ...transactionSummary,\n    };\n\n    return output;\n  });\n\n  return {\n    transactions,\n    pageInfo,\n  };\n}\n"],"mappings":"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","names":["max","Address","ErrorCode","FuelError","bn","InputType","TransactionType","TransactionCoder","getBytesCopy","hexlify","clone","hexlify","ErrorCode","FuelError","bn","hexlify","ZeroBytes32","ErrorCode","FuelError","bn","hexlify","BaseAssetId","ZeroBytes32","bn","InputType","OutputType","getBytesCopy","hexlify","ZeroBytes32","ErrorCode","FuelError","bn","getBytesCopy","ZeroBytes32","bn","getBytesCopy","FuelError","ErrorCode","ErrorCode","FuelError","bn","ReceiptType","getBytesCopy","hexlify","getBytesCopy","hexlify","bn","ZeroBytes32","InputType","OutputType","hexlify","BaseAssetId","getBytesCopy","ZeroBytes32","bn","TransactionType","OutputType","getBytesCopy","hexlify","ZeroBytes32","bn","TransactionType","InputType","OutputType","TransactionCoder","concat","clone","getBytesCopy","hexlify","TransactionType","hexlify","ZeroBytes32","OutputType","bn","getBytesCopy","addressify","ZeroBytes32","bn","InputType","OutputType","TransactionType","getBytesCopy","hexlify","getBytesCopy","TransactionType","bn","getBytesCopy","ZeroBytes32","hexlify","InputType","OutputType","addressify","ErrorCode","FuelError","TransactionType","TransactionType","FuelError","ErrorCode","ErrorCode","FuelError","bn","TransactionCoder","getBytesCopy","hexlify","bn","PolicyType","TransactionCoder","TransactionType","getBytesCopy","bn","getBytesCopy","TransactionCoder","TransactionType","PolicyType","ErrorCode","FuelError","bn","ReceiptType","TransactionType","Interface","bn","ErrorCode","FuelError","InputType","OutputType","TransactionTypeName","TransactionStatus","OperationName","AddressType","ChainName","TransactionType","FuelError","ErrorCode","ReceiptType","bn","ReceiptType","ReceiptType","ErrorCode","FuelError","FuelError","ErrorCode","hexlify","bn","TransactionCoder","getBytesCopy","FuelError","ErrorCode","ReceiptType","bn","FuelError","ErrorCode","hexlify","TransactionType","TransactionCoder","getBytesCopy","Address","clone","InputType","ErrorCode","FuelError","bn","TransactionCoder","getBytesCopy","FuelError","ErrorCode","TransactionCoder","getBytesCopy","bn"]}