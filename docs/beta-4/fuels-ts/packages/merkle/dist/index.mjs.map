{"version":3,"sources":["../src/common/common.ts","../src/common/cryptography.ts","../src/binary/types/node.ts","../src/binary/binaryMerkleTree.ts","../src/sparse/treeHasher.ts","../src/sparse/types/sparseCompactMerkleProof.ts","../src/sparse/types/sparseMerkleProof.ts","../src/sparse/utils.ts","../src/sparse/proofs.ts","../src/sparse/sparseMerkleTree.ts"],"sourcesContent":["/// @dev The Fuel testing Merkle trees.\n/// A set of useful helper methods for testing and deploying Merkle trees.\n\nexport const EMPTY = '0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855';\nexport const ZERO = '0x0000000000000000000000000000000000000000000000000000000000000000';\nexport const MAX_HEIGHT = 256;\n","import type { BytesLike } from 'ethers';\nimport { sha256 } from 'ethers';\n\n/**\n * The primary hash function for Fuel\n * SHA-256\n */\nexport function hash(data: BytesLike): string {\n  return sha256(data);\n}\n","class Node {\n  left: number;\n  right: number;\n  parent: number;\n  hash: string;\n  data: string;\n  index: number;\n\n  constructor(\n    left: number,\n    right: number,\n    parent: number,\n    hash: string,\n    data: string,\n    index: number = 0\n  ) {\n    this.left = left;\n    this.right = right;\n    this.parent = parent;\n    this.hash = hash;\n    this.data = data;\n    this.index = index;\n  }\n}\n\nexport default Node;\n","// A set of useful helper methods for testing binary Merkle trees.\nimport { EMPTY, hash } from '../common';\n\nimport Node from './types/node';\n\n/**\n * Slice off the '0x' on each argument to simulate abi.encodePacked\n */\nexport function hashLeaf(data: string): string {\n  return hash('0x00'.concat(data.slice(2)));\n}\n\n/**\n * Slice off the '0x' on each argument to simulate abi.encodePacked\n * hash(prefix +  left + right)\n */\nexport function hashNode(left: string, right: string): string {\n  return hash('0x01'.concat(left.slice(2)).concat(right.slice(2)));\n}\n\n/**\n * Construct tree\n */\nexport function constructTree(data: string[]): Node[] {\n  const nodes = [];\n  for (let i = 0; i < data.length; i += 1) {\n    const hashed = hashLeaf(data[i]);\n    const leaf = new Node(-1, -1, -1, hashed, data[i]);\n    leaf.index = i;\n    nodes.push(leaf);\n  }\n\n  const nodesList = [...nodes];\n  let pNodes = [...nodes];\n\n  let size = (nodes.length + 1) >> 1;\n  let odd = nodes.length & 1;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let i = 0;\n    for (; i < size - odd; i += 1) {\n      const j = i << 1;\n      const hashed = hashNode(pNodes[j].hash, pNodes[j + 1].hash);\n      nodes[i] = new Node(pNodes[j].index, pNodes[j + 1].index, -1, hashed, '');\n      const nextIndex = nodesList.length;\n      nodes[i].index = nextIndex;\n\n      nodesList[pNodes[j].index].parent = nextIndex;\n      nodesList[pNodes[j + 1].index].parent = nextIndex;\n      nodesList.push(nodes[i]);\n    }\n\n    if (size === 1) {\n      break;\n    }\n\n    if (odd === 1) {\n      nodes[i] = pNodes[i << 1];\n    }\n\n    odd = size & 1;\n    size = (size + 1) >> 1;\n    pNodes = [...nodes];\n  }\n  return nodesList;\n}\n\n/**\n * Compute the merkle root\n */\nexport function calcRoot(data: string[]): string {\n  if (!data.length) {\n    return EMPTY;\n  }\n  const nodes = [];\n  for (let i = 0; i < data.length; i += 1) {\n    const hashed = hashLeaf(data[i]);\n    nodes.push(new Node(-1, -1, -1, hashed, data[i]));\n  }\n  let pNodes = nodes;\n  let size = (nodes.length + 1) >> 1;\n  let odd = nodes.length & 1;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let i = 0;\n    for (; i < size - odd; i += 1) {\n      const j = i << 1;\n      const hashed = hashNode(pNodes[j].hash, pNodes[j + 1].hash);\n      nodes[i] = new Node(pNodes[j].index, pNodes[j + 1].index, -1, hashed, '');\n    }\n    if (odd === 1) {\n      nodes[i] = pNodes[i << 1];\n    }\n    if (size === 1) {\n      break;\n    }\n    odd = size & 1;\n    size = (size + 1) >> 1;\n    pNodes = nodes;\n  }\n  return nodes[0].hash;\n}\n\n/**\n * Get proof for the leaf\n */\nexport function getProof(nodes: Node[], id: number): string[] {\n  const proof: string[] = [];\n  for (let prev = id, cur = nodes[id].parent; cur !== -1; prev = cur, cur = nodes[cur].parent) {\n    if (nodes[cur].left === prev) {\n      proof.push(nodes[nodes[cur].right].hash);\n    } else {\n      proof.push(nodes[nodes[cur].left].hash);\n    }\n  }\n  return proof;\n}\n","import { hash } from '../common';\n\nexport const leafPrefix = '0x00';\nexport const nodePrefix = '0x01';\n\n/**\n * Slice off the '0x' on each argument to simulate abi.encode\n * prefix + key + hash(data)\n */\nexport function hashLeaf(key: string, data: string): [string, string] {\n  const value = '0x00'.concat(key.slice(2)).concat(hash(data).slice(2));\n  return [hash(value), value];\n}\n\n/**\n * Slice off the '0x' on each argument to simulate abi.encodePacked\n * prefix + key + hash(data)\n */\nexport function hashNode(left: string, right: string): [string, string] {\n  const value = '0x01'.concat(left.slice(2)).concat(right.slice(2));\n  return [hash(value), value];\n}\n\n/**\n * Parse a leaf\n */\nexport function parseLeaf(data: string): [string, string] {\n  const len = nodePrefix.length;\n  return ['0x'.concat(data.slice(len, len + 64)), '0x'.concat(data.slice(len + 64))];\n}\n\n/**\n * Parse a nodes\n */\nexport function parseNode(data: string): [string, string] {\n  const len = nodePrefix.length;\n  return ['0x'.concat(data.slice(len, len + 64)), '0x'.concat(data.slice(len + 64))];\n}\n\n/**\n * Check if data is a leaf by checking prefix\n */\nexport function isLeaf(data: string): boolean {\n  return data.slice(0, 4) === leafPrefix;\n}\n","class SparseCompactMerkleProof {\n  SideNodes: string[];\n  NonMembershipLeafData: string;\n  BitMask: number[];\n  NumSideNodes: number;\n  SiblingData: string;\n\n  constructor(\n    SideNodes: string[],\n    NonMembershipLeafData: string,\n    Bitmask: number[],\n    NumSideNodes: number,\n    SiblingData: string\n  ) {\n    this.SideNodes = SideNodes;\n    this.NonMembershipLeafData = NonMembershipLeafData;\n    this.BitMask = Bitmask;\n    this.NumSideNodes = NumSideNodes;\n    this.SiblingData = SiblingData;\n  }\n}\n\nexport default SparseCompactMerkleProof;\n","// Sparse Merkle proof\nclass SparseMerkleProof {\n  SideNodes: string[];\n  NonMembershipLeafData: string;\n  SiblingData: string;\n\n  constructor(sideNodes: string[], NonMembershipLeafData: string, SiblingData: string) {\n    this.SideNodes = sideNodes;\n    this.NonMembershipLeafData = NonMembershipLeafData;\n    this.SiblingData = SiblingData;\n  }\n}\n\nexport default SparseMerkleProof;\n","export const ZERO = '0x0000000000000000000000000000000000000000000000000000000000000000';\nexport const EMPTY = '0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855';\nexport const MAX_HEIGHT = 256;\n\nexport interface MapStore {\n  [key: string]: string;\n}\n\n/**\n * Gets the bit at an offset from the most significant bit\n */\nexport function getBitAtFromMSB(data: string, position: number): number {\n  // if int(data[position / 8]) & (1 << (8 - 1 - uint(position) % 8)) > 0\n\n  // Slice off '0x'\n  const slicedData = data.slice(2);\n  // Get byte that contains the specified position\n  const byte = '0x'.concat(\n    slicedData.slice(Math.floor(position / 8) * 2, Math.floor(position / 8) * 2 + 2)\n  );\n  // Get bits from specified position within that byte\n  const bits = Number(byte) & (1 << (8 - 1 - (position % 8)));\n\n  // Bit at position = 0 IFF bits > 0.\n  if (bits > 0) {\n    return 1;\n  }\n  return 0;\n}\n/**\n * Reverse the nodes position\n */\nexport function reverseSideNodes(sideNodes: string[]): string[] {\n  let left = 0;\n  let right = sideNodes.length - 1;\n  const reversedSideNodes: string[] = sideNodes;\n\n  while (left < right) {\n    [reversedSideNodes[left], reversedSideNodes[right]] = [\n      reversedSideNodes[right],\n      reversedSideNodes[left],\n    ];\n    left += 1;\n    right -= 1;\n  }\n\n  return reversedSideNodes;\n}\n\n/**\n * Counts the common bit at at an offset from the most significant bit\n * between two inputs\n */\nexport function countCommonPrefix(data1: string, data2: string): number {\n  let count = 0;\n  for (let i = 0; i < MAX_HEIGHT; i += 1) {\n    if (getBitAtFromMSB(data1, i) === getBitAtFromMSB(data2, i)) {\n      count += 1;\n    } else {\n      break;\n    }\n  }\n  return count;\n}\n","import { hash } from '../common';\n\nimport { hashLeaf, hashNode, parseLeaf } from './treeHasher';\nimport SparseCompactMerkleProof from './types/sparseCompactMerkleProof';\nimport SparseMerkleProof from './types/sparseMerkleProof';\nimport { getBitAtFromMSB, ZERO } from './utils';\n\n/**\n * Verify a merkle proof\n */\nexport function verifyProof(\n  proof: SparseMerkleProof,\n  root: string,\n  key: string,\n  value: string\n): [boolean, string[][]] {\n  const updates: string[][] = [[]];\n\n  // Detemine what the leaf hash should be\n  let currentHash;\n  let currentData;\n  let actualPath;\n  let valueHash;\n\n  if (value === ZERO) {\n    // Non-membership proof\n    if (proof.NonMembershipLeafData === '') {\n      currentHash = ZERO;\n    } else {\n      // leaf is an unrelated leaf\n      [actualPath, valueHash] = parseLeaf(proof.NonMembershipLeafData);\n      if (actualPath === key) {\n        // Leaf does exist : non-membership proof failed\n        return [false, []];\n      }\n      [currentHash, currentData] = hashLeaf(actualPath, valueHash);\n      updates.push([currentHash, currentData]);\n    }\n  } else {\n    // Membership proof\n    valueHash = hash(value);\n    updates.push([valueHash, value]);\n\n    [currentHash, currentData] = hashLeaf(key, value);\n    updates.push([currentHash, currentData]);\n  }\n\n  // Recompute root\n  for (let i = 0; i < proof.SideNodes.length; i += 1) {\n    const node = proof.SideNodes[i];\n\n    if (getBitAtFromMSB(key, proof.SideNodes.length - 1 - i) === 1) {\n      [currentHash, currentData] = hashNode(node, currentHash);\n    } else {\n      [currentHash, currentData] = hashNode(currentHash, node);\n    }\n\n    updates.push([currentHash, currentData]);\n  }\n\n  return [currentHash === root, updates];\n}\n\n/**\n * Compact a Sparse Merkle Proof using a bitmask\n */\nexport function compactProof(proof: SparseMerkleProof): SparseCompactMerkleProof {\n  const bitMask: number[] = [];\n  const compactedSideNodes: string[] = [];\n  let node;\n\n  for (let i = 0; i < proof.SideNodes.length; i += 1) {\n    node = proof.SideNodes[i];\n    if (node === ZERO) {\n      bitMask.push(0);\n    } else {\n      compactedSideNodes.push(node);\n      bitMask.push(1);\n    }\n  }\n  const compactedProof = new SparseCompactMerkleProof(\n    compactedSideNodes,\n    proof.NonMembershipLeafData,\n    bitMask,\n    proof.SideNodes.length,\n    proof.SiblingData\n  );\n  return compactedProof;\n}\n\n/**\n * Decompact a Sparse Merkle Proof\n */\nexport function decompactProof(proof: SparseCompactMerkleProof): SparseMerkleProof {\n  const decompactedSideNodes: string[] = [];\n  let position = 0;\n\n  for (let i = 0; i < proof.NumSideNodes; i += 1) {\n    if (proof.BitMask[i] === 0) {\n      decompactedSideNodes[i] = ZERO;\n    } else {\n      decompactedSideNodes[i] = proof.SideNodes[position];\n      position += 1;\n    }\n  }\n  const decompactedProof = new SparseMerkleProof(\n    decompactedSideNodes,\n    proof.NonMembershipLeafData,\n    proof.SiblingData\n  );\n\n  return decompactedProof;\n}\n","/// @dev The Fuel testing Merkle trees.\n/// A set of useful helper methods for testing and deploying Merkle trees.\nimport { hash } from '../common';\n\nimport { compactProof } from './proofs';\nimport { isLeaf, hashLeaf, hashNode, parseLeaf, parseNode } from './treeHasher';\nimport type SparseCompactMerkleProof from './types/sparseCompactMerkleProof';\nimport SparseMerkleProof from './types/sparseMerkleProof';\nimport type { MapStore } from './utils';\nimport { ZERO, MAX_HEIGHT, getBitAtFromMSB, reverseSideNodes, countCommonPrefix } from './utils';\n\nexport class SparseMerkleTree {\n  ms: MapStore;\n\n  root: string;\n\n  constructor() {\n    const ms: MapStore = {};\n    this.ms = ms;\n    this.root = ZERO;\n    this.ms[this.root] = ZERO;\n  }\n\n  get(key: string): string {\n    return this.ms[key];\n  }\n\n  set(key: string, value: string): void {\n    this.ms[key] = value;\n  }\n\n  setRoot(root: string): void {\n    this.root = root;\n  }\n\n  sideNodesForRoot(key: string, root: string): [string[], string, string, string] {\n    const sideNodes: string[] = [];\n\n    // If the root is a placeholder, there are no sidenodes to return.\n    // The data is nil, and the sibling is nil\n    if (root === ZERO) {\n      return [sideNodes, ZERO, '', ''];\n    }\n\n    let currentData = this.get(root);\n\n    // If the root is a leaf, there are also no sidenodes to return.\n    // The data is the leaf data, and the sibling is nil\n    if (isLeaf(currentData)) {\n      return [sideNodes, root, currentData, ''];\n    }\n\n    let leftNode;\n    let rightNode;\n    let nodeHash = '';\n    let sideNode = '';\n\n    for (let i = 0; i < MAX_HEIGHT; i += 1) {\n      [leftNode, rightNode] = parseNode(currentData);\n\n      if (getBitAtFromMSB(key, i) === 1) {\n        sideNode = leftNode;\n        nodeHash = rightNode;\n      } else {\n        sideNode = rightNode;\n        nodeHash = leftNode;\n      }\n\n      sideNodes.push(sideNode);\n\n      // If the node is a placeholder, we've reached the end.\n      if (nodeHash === ZERO) {\n        currentData = '';\n        break;\n      }\n\n      currentData = this.get(nodeHash);\n\n      // If the node is a leaf, we've reached the end.\n      if (isLeaf(currentData)) {\n        break;\n      }\n    }\n\n    const siblingData = this.get(sideNode);\n\n    return [reverseSideNodes(sideNodes), nodeHash, currentData, siblingData];\n  }\n\n  deleteWithSideNodes(\n    key: string,\n    sideNodes: string[],\n    oldLeafHash: string,\n    oldLeafData: string\n  ): string {\n    // If value already zero, deletion changes nothing. Just return current root\n\n    if (oldLeafHash === ZERO) {\n      return this.root;\n    }\n\n    // If key is already empty (different key found in its place), deletion changed nothing. Just return current root\n    const [actualPath] = parseLeaf(oldLeafData);\n\n    if (actualPath !== key) {\n      return this.root;\n    }\n\n    let currentHash = '';\n    let currentData = '';\n    let sideNode = '';\n    let sideNodeValue = '';\n    let nonPlaceholderReached = false;\n\n    for (let i = 0; i < sideNodes.length; i += 1) {\n      if (sideNodes[i] === '') {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      sideNode = sideNodes[i];\n\n      if (currentData === '') {\n        sideNodeValue = this.get(sideNode);\n\n        if (isLeaf(sideNodeValue)) {\n          // This is the leaf sibling that needs to be percolated up the tree.\n          currentHash = sideNode;\n          currentData = sideNode;\n          // eslint-disable-next-line no-continue\n          continue;\n        } else {\n          // This is the node sibling that needs to be left in its place.\n          currentData = ZERO;\n          nonPlaceholderReached = true;\n        }\n      }\n\n      if (!nonPlaceholderReached && sideNode === ZERO) {\n        // We found another placeholder sibling node, keep going up the\n        // tree until we find the first sibling that is not a placeholder.\n        // eslint-disable-next-line no-continue\n        continue;\n      } else if (!nonPlaceholderReached) {\n        // We found the first sibling node that is not a placeholder, it is\n        // time to insert our leaf sibling node here.\n        nonPlaceholderReached = true;\n      }\n\n      if (getBitAtFromMSB(key, sideNodes.length - 1 - i) === 1) {\n        [currentHash, currentData] = hashNode(sideNode, currentData);\n      } else {\n        [currentHash, currentData] = hashNode(currentData, sideNode);\n      }\n      this.set(currentHash, currentData);\n      currentData = currentHash;\n    }\n\n    // The tree is empty; return placeholder value as root.\n    // How can currentHash be '' / nil if it's a hash ?\n    if (currentHash === '') {\n      currentHash = ZERO;\n    }\n\n    return currentHash;\n  }\n\n  updateWithSideNodes(\n    key: string,\n    value: string,\n    sideNodes: string[],\n    oldLeafHash: string,\n    oldLeafData: string\n  ): string {\n    let currentHash;\n    let currentData;\n\n    this.set(hash(value), value);\n\n    [currentHash, currentData] = hashLeaf(key, value);\n    this.set(currentHash, currentData);\n\n    currentData = currentHash;\n\n    // If the leaf node that sibling nodes lead to has a different actual path\n    // than the leaf node being updated, we need to create an intermediate node\n    // with this leaf node and the new leaf node as children.\n    //\n    // First, get the number of bits that the paths of the two leaf nodes share\n    // in common as a prefix.\n\n    let commonPrefixCount;\n\n    if (oldLeafHash === ZERO) {\n      commonPrefixCount = MAX_HEIGHT;\n    } else {\n      const [actualPath] = parseLeaf(oldLeafData);\n      commonPrefixCount = countCommonPrefix(key, actualPath);\n    }\n\n    if (commonPrefixCount !== MAX_HEIGHT) {\n      if (getBitAtFromMSB(key, commonPrefixCount) === 1) {\n        [currentHash, currentData] = hashNode(oldLeafHash, currentData);\n      } else {\n        [currentHash, currentData] = hashNode(currentData, oldLeafHash);\n      }\n      this.set(currentHash, currentData);\n      currentData = currentHash;\n    }\n\n    for (let i = 0; i < MAX_HEIGHT; i += 1) {\n      let sideNode;\n      const offsetOfSideNodes = MAX_HEIGHT - sideNodes.length;\n\n      // If there are no sidenodes at this height, but the number of\n      // bits that the paths of the two leaf nodes share in common is\n      // greater than this height, then we need to build up the tree\n      // to this height with placeholder values at siblings.\n\n      if (i - offsetOfSideNodes < 0 || sideNodes[i - offsetOfSideNodes] === '') {\n        if (commonPrefixCount !== MAX_HEIGHT && commonPrefixCount > MAX_HEIGHT - 1 - i) {\n          sideNode = ZERO;\n        } else {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n      } else {\n        sideNode = sideNodes[i - offsetOfSideNodes];\n      }\n\n      if (getBitAtFromMSB(key, MAX_HEIGHT - 1 - i) === 1) {\n        [currentHash, currentData] = hashNode(sideNode, currentData);\n      } else {\n        [currentHash, currentData] = hashNode(currentData, sideNode);\n      }\n\n      this.set(currentHash, currentData);\n      currentData = currentHash;\n    }\n\n    return currentHash;\n  }\n\n  update(key: string, value: string): void {\n    const [sideNodes, oldLeafHash, oldLeafData] = this.sideNodesForRoot(key, this.root);\n    const newRoot = this.updateWithSideNodes(key, value, sideNodes, oldLeafHash, oldLeafData);\n    this.setRoot(newRoot);\n  }\n\n  delete(key: string): void {\n    const [sideNodes, oldLeafHash, oldLeafData] = this.sideNodesForRoot(key, this.root);\n    const newRoot = this.deleteWithSideNodes(key, sideNodes, oldLeafHash, oldLeafData);\n    this.setRoot(newRoot);\n  }\n\n  prove(key: string): SparseMerkleProof {\n    const [sideNodes, leafHash, leafData, siblingData] = this.sideNodesForRoot(key, this.root);\n\n    const nonEmptySideNodes: string[] = [];\n\n    for (let i = 0; i < sideNodes.length; i += 1) {\n      if (sideNodes[i] !== '') {\n        nonEmptySideNodes.push(sideNodes[i]);\n      }\n    }\n\n    // Deal with non-membership proofs. If the leaf hash is the placeholder\n    // value, we do not need to add anything else to the proof.\n    let nonMembershipLeafData = '';\n    if (leafHash !== ZERO) {\n      const [actualPath] = parseLeaf(leafData);\n      if (actualPath !== key) {\n        // This is a non-membership proof that involves showing a different leaf.\n        // Add the leaf data to the proof.\n        nonMembershipLeafData = leafData;\n      }\n    }\n\n    const proof = new SparseMerkleProof(nonEmptySideNodes, nonMembershipLeafData, siblingData);\n    return proof;\n  }\n\n  proveCompacted(key: string): SparseCompactMerkleProof {\n    const proof = this.prove(key);\n    const compactedProof = compactProof(proof);\n    return compactedProof;\n  }\n}\n"],"mappings":"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","names":["hash","hashLeaf","hashNode","hashNode","hashLeaf"]}